define("node_modules/@joelek/ts-autoguard/build/autoguard-lib/guards", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Union = exports.Undefined = exports.Tuple = exports.StringLiteral = exports.String = exports.Reference = exports.Record = exports.Object = exports.NumberLiteral = exports.Number = exports.Null = exports.Intersection = exports.BooleanLiteral = exports.Boolean = exports.Array = exports.Any = void 0;
    exports.Any = {
        as(subject, path = "") {
            return subject;
        },
        is(subject) {
            try {
                this.as(subject);
            }
            catch (error) {
                return false;
            }
            return true;
        }
    };
    exports.Array = {
        of(guard) {
            return {
                as(subject, path = "") {
                    if ((subject != null) && (subject.constructor === globalThis.Array)) {
                        for (let i = 0; i < subject.length; i++) {
                            guard.as(subject[i], path + "[" + i + "]");
                        }
                        return subject;
                    }
                    throw "Expected an array at " + path + "!";
                },
                is(subject) {
                    try {
                        this.as(subject);
                    }
                    catch (error) {
                        return false;
                    }
                    return true;
                }
            };
        }
    };
    exports.Boolean = {
        as(subject, path = "") {
            if ((subject != null) && (subject.constructor === globalThis.Boolean)) {
                return subject;
            }
            throw "Expected a boolean at " + path + "!";
        },
        is(subject) {
            try {
                this.as(subject);
            }
            catch (error) {
                return false;
            }
            return true;
        }
    };
    exports.BooleanLiteral = {
        of(value) {
            return {
                as(subject, path = "") {
                    if (subject === value) {
                        return subject;
                    }
                    throw "Expected " + value + " at " + path + "!";
                },
                is(subject) {
                    try {
                        this.as(subject);
                    }
                    catch (error) {
                        return false;
                    }
                    return true;
                }
            };
        }
    };
    exports.Intersection = {
        of(...guards) {
            return {
                as(subject, path = "") {
                    for (let guard of guards) {
                        guard.as(subject, path);
                    }
                    return subject;
                },
                is(subject) {
                    try {
                        this.as(subject);
                    }
                    catch (error) {
                        return false;
                    }
                    return true;
                }
            };
        }
    };
    exports.Null = {
        as(subject, path = "") {
            if (subject === null) {
                return subject;
            }
            throw "Expected null at " + path + "!";
        },
        is(subject) {
            try {
                this.as(subject);
            }
            catch (error) {
                return false;
            }
            return true;
        }
    };
    exports.Number = {
        as(subject, path = "") {
            if ((subject != null) && (subject.constructor === globalThis.Number)) {
                return subject;
            }
            throw "Expected a number at " + path + "!";
        },
        is(subject) {
            try {
                this.as(subject);
            }
            catch (error) {
                return false;
            }
            return true;
        }
    };
    exports.NumberLiteral = {
        of(value) {
            return {
                as(subject, path = "") {
                    if (subject === value) {
                        return subject;
                    }
                    throw "Expected " + value + " at " + path + "!";
                },
                is(subject) {
                    try {
                        this.as(subject);
                    }
                    catch (error) {
                        return false;
                    }
                    return true;
                }
            };
        }
    };
    exports.Object = {
        of(guards) {
            return {
                as(subject, path = "") {
                    if ((subject != null) && (subject.constructor === globalThis.Object)) {
                        for (let key in guards) {
                            guards[key].as(subject[key], path + /^([a-z][a-z0-9_]*)$/is.test(key) ? "." + key : "[\"" + key + "\"]");
                        }
                        return subject;
                    }
                    throw "Expected an object at " + path + "!";
                },
                is(subject) {
                    try {
                        this.as(subject);
                    }
                    catch (error) {
                        return false;
                    }
                    return true;
                }
            };
        }
    };
    exports.Record = {
        of(guard) {
            return {
                as(subject, path = "") {
                    if ((subject != null) && (subject.constructor === globalThis.Object)) {
                        for (let key of globalThis.Object.keys(subject)) {
                            guard.as(subject[key], path + "[\"" + key + "\"]");
                        }
                        return subject;
                    }
                    throw "Expected a record at " + path + "!";
                },
                is(subject) {
                    try {
                        this.as(subject);
                    }
                    catch (error) {
                        return false;
                    }
                    return true;
                }
            };
        }
    };
    exports.Reference = {
        of(guard) {
            return {
                as(subject, path = "") {
                    return guard().as(subject, path);
                },
                is(subject) {
                    return guard().is(subject);
                }
            };
        }
    };
    exports.String = {
        as(subject, path = "") {
            if ((subject != null) && (subject.constructor === globalThis.String)) {
                return subject;
            }
            throw "Expected a string at " + path + "!";
        },
        is(subject) {
            try {
                this.as(subject);
            }
            catch (error) {
                return false;
            }
            return true;
        }
    };
    exports.StringLiteral = {
        of(value) {
            return {
                as(subject, path = "") {
                    if (subject === value) {
                        return subject;
                    }
                    throw "Expected \"" + value + "\" at " + path + "!";
                },
                is(subject) {
                    try {
                        this.as(subject);
                    }
                    catch (error) {
                        return false;
                    }
                    return true;
                }
            };
        }
    };
    exports.Tuple = {
        of(...guards) {
            return {
                as(subject, path = "") {
                    if ((subject != null) && (subject.constructor === globalThis.Array)) {
                        for (let i = 0; i < guards.length; i++) {
                            guards[i].as(subject[i], path + "[" + i + "]");
                        }
                        return subject;
                    }
                    throw "Expected a tuple at " + path + "!";
                },
                is(subject) {
                    try {
                        this.as(subject);
                    }
                    catch (error) {
                        return false;
                    }
                    return true;
                }
            };
        }
    };
    exports.Undefined = {
        as(subject, path = "") {
            if (subject === undefined) {
                return subject;
            }
            throw "Expected undefined at " + path + "!";
        },
        is(subject) {
            try {
                this.as(subject);
            }
            catch (error) {
                return false;
            }
            return true;
        }
    };
    exports.Union = {
        of(...guards) {
            return {
                as(subject, path = "") {
                    for (let guard of guards) {
                        try {
                            return guard.as(subject, path);
                        }
                        catch (error) { }
                    }
                    throw "Expected a union at " + path + "!";
                },
                is(subject) {
                    try {
                        this.as(subject);
                    }
                    catch (error) {
                        return false;
                    }
                    return true;
                }
            };
        }
    };
});
define("node_modules/@joelek/ts-autoguard/build/autoguard-lib/tokenization", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.expect = exports.Tokenizer = exports.Families = void 0;
    exports.Families = ((...tuple) => tuple)("WS", "(", ")", "[", "]", "{", "}", "?", "|", ".", "..", "/", "&", "@", ",", ":", "any", "boolean", "false", "null", "number", "string", "true", "undefined", "IDENTIFIER", "NUMBER_LITERAL", "STRING_LITERAL");
    class Tokenizer {
        constructor(string) {
            let matchers = {
                "WS": /^([\t\r\n ]+)/isu,
                "(": /^([\(])/isu,
                ")": /^([\)])/isu,
                "[": /^([\[])/isu,
                "]": /^([\]])/isu,
                "{": /^([\{])/isu,
                "}": /^([\}])/isu,
                "?": /^([\?])/isu,
                "|": /^([\|])/isu,
                ".": /^([\.])/isu,
                "..": /^([\.][\.])/isu,
                "/": /^([\/])/isu,
                "&": /^([&])/isu,
                "@": /^([@])/isu,
                ",": /^([,])/isu,
                ":": /^([:])/isu,
                "any": /^(any)/isu,
                "boolean": /^(boolean)/isu,
                "false": /^(false)/isu,
                "null": /^(null)/isu,
                "number": /^(number)/isu,
                "string": /^(string)/isu,
                "true": /^(true)/isu,
                "undefined": /^(undefined)/isu,
                "IDENTIFIER": /^([a-z][a-z0-9_]*)/isu,
                "NUMBER_LITERAL": /^(([1-9][0-9]+)|([0-9]))/isu,
                "STRING_LITERAL": /^(["][^"]*["])/isu
            };
            let tokens = new Array();
            let row = 1;
            let col = 1;
            while (string.length > 0) {
                let token;
                for (let key in matchers) {
                    let type = key;
                    let exec = matchers[type].exec(string);
                    if (exec == null) {
                        continue;
                    }
                    if ((token == null) || (exec[1].length > token[1].length)) {
                        token = [type, exec[1]];
                    }
                }
                if (token == null) {
                    throw `Unrecognized token at row ${row}, col ${col}!`;
                }
                tokens.push({
                    family: token[0],
                    value: token[1],
                    row: row,
                    col: col
                });
                string = string.slice(token[1].length);
                let lines = token[1].split(/\r?\n/);
                if (lines.length > 1) {
                    row += lines.length - 1;
                    col = 1;
                }
                col += lines[lines.length - 1].length;
            }
            this.tokens = tokens.filter((token) => {
                return token.family !== "WS";
            });
            this.offset = 0;
        }
        peek() {
            return this.tokens[this.offset];
        }
        read() {
            if (this.offset >= this.tokens.length) {
                throw `Unexpectedly reached end of stream!`;
            }
            return this.tokens[this.offset++];
        }
        newContext(producer) {
            let offset = this.offset;
            try {
                return producer(() => this.read(), () => this.peek());
            }
            catch (error) {
                this.offset = offset;
                throw error;
            }
        }
    }
    exports.Tokenizer = Tokenizer;
    ;
    function expect(token, family) {
        let families = Array.isArray(family) ? family : [family];
        if (!families.includes(token.family)) {
            throw `Unexpected ${token.family} at row ${token.row}, col ${token.col}!`;
        }
        return token;
    }
    exports.expect = expect;
    ;
});
define("node_modules/@joelek/ts-autoguard/build/autoguard-lib/language", ["require", "exports", "node_modules/@joelek/ts-autoguard/build/autoguard-lib/tokenization"], function (require, exports, tokenization) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Schema = exports.UnionType = exports.UndefinedType = exports.TupleType = exports.StringLiteralType = exports.StringType = exports.ReferenceType = exports.RecordType = exports.ObjectType = exports.NumberLiteralType = exports.NumberType = exports.NullType = exports.IntersectionType = exports.GroupType = exports.BooleanLiteralType = exports.BooleanType = exports.ArrayType = exports.AnyType = exports.Type = void 0;
    ;
    exports.Type = {
        parse(tokenizer, ...exclude) {
            try {
                return UnionType.parse(tokenizer, ...exclude);
            }
            catch (error) { }
            try {
                return IntersectionType.parse(tokenizer, ...exclude);
            }
            catch (error) { }
            try {
                return ArrayType.parse(tokenizer, ...exclude);
            }
            catch (error) { }
            try {
                return AnyType.parse(tokenizer);
            }
            catch (error) { }
            try {
                return BooleanType.parse(tokenizer);
            }
            catch (error) { }
            try {
                return BooleanLiteralType.parse(tokenizer);
            }
            catch (error) { }
            try {
                return NullType.parse(tokenizer);
            }
            catch (error) { }
            try {
                return NumberType.parse(tokenizer);
            }
            catch (error) { }
            try {
                return NumberLiteralType.parse(tokenizer);
            }
            catch (error) { }
            try {
                return StringType.parse(tokenizer);
            }
            catch (error) { }
            try {
                return StringLiteralType.parse(tokenizer);
            }
            catch (error) { }
            try {
                return UndefinedType.parse(tokenizer);
            }
            catch (error) { }
            try {
                return ReferenceType.parse(tokenizer);
            }
            catch (error) { }
            try {
                return TupleType.parse(tokenizer);
            }
            catch (error) { }
            try {
                return ObjectType.parse(tokenizer);
            }
            catch (error) { }
            try {
                return GroupType.parse(tokenizer);
            }
            catch (error) { }
            try {
                return RecordType.parse(tokenizer);
            }
            catch (error) { }
            return tokenizer.newContext((read, peek) => {
                let token = read();
                throw `Unexpected ${token.family} at row ${token.row}, col ${token.col}!`;
            });
        }
    };
    class AnyType {
        constructor() {
        }
        generateType(options) {
            return "any";
        }
        generateTypeGuard(options) {
            let lines = new Array();
            if (options.standalone) {
                lines.push("(subject, path) => {");
                lines.push("	return subject;");
                lines.push("}");
            }
            else {
                lines.push("autoguard.Any");
            }
            return lines.join(options.eol);
        }
        getImports() {
            return [];
        }
        static parse(tokenizer) {
            return tokenizer.newContext((read, peek) => {
                tokenization.expect(read(), "any");
                return AnyType.INSTANCE;
            });
        }
    }
    exports.AnyType = AnyType;
    AnyType.INSTANCE = new AnyType();
    ;
    class ArrayType {
        constructor(type) {
            this.type = type;
        }
        generateType(options) {
            return this.type.generateType(options) + "[]";
        }
        generateTypeGuard(options) {
            let lines = new Array();
            if (options.standalone) {
                lines.push("(subject, path) => {");
                lines.push("	if ((subject != null) && (subject.constructor === globalThis.Array)) {");
                lines.push("		for (let i = 0; i < subject.length; i++) {");
                lines.push("			(" + this.type.generateTypeGuard(Object.assign(Object.assign({}, options), { eol: options.eol + "\t\t\t" })) + ")(subject[i], path + \"[\" + i + \"]\");");
                lines.push("		}");
                lines.push("		return subject;");
                lines.push("	}");
                lines.push("	throw \"Expected an array at \" + path + \"!\";");
                lines.push("}");
            }
            else {
                lines.push("autoguard.Array.of(" + this.type.generateTypeGuard(Object.assign(Object.assign({}, options), { eol: options.eol })) + ")");
            }
            return lines.join(options.eol);
        }
        getImports() {
            return this.type.getImports();
        }
        static parse(tokenizer, ...exclude) {
            if (exclude.includes("Array")) {
                throw `Recursion prevention!`;
            }
            return tokenizer.newContext((read, peek) => {
                let type = exports.Type.parse(tokenizer, ...exclude, "Array");
                tokenization.expect(read(), "[");
                tokenization.expect(read(), "]");
                let array = new ArrayType(type);
                while (true) {
                    try {
                        tokenizer.newContext((read, peek) => {
                            tokenization.expect(read(), "[");
                            tokenization.expect(read(), "]");
                            array = new ArrayType(array);
                        });
                    }
                    catch (error) {
                        break;
                    }
                }
                return array;
            });
        }
    }
    exports.ArrayType = ArrayType;
    ;
    class BooleanType {
        constructor() {
        }
        generateType(options) {
            return "boolean";
        }
        generateTypeGuard(options) {
            let lines = new Array();
            if (options.standalone) {
                lines.push("(subject, path) => {");
                lines.push("	if ((subject != null) && (subject.constructor === globalThis.Boolean)) {");
                lines.push("		return subject as boolean;");
                lines.push("	}");
                lines.push("	throw \"Expected a boolean at \" + path + \"!\";");
                lines.push("}");
            }
            else {
                lines.push("autoguard.Boolean");
            }
            return lines.join(options.eol);
        }
        getImports() {
            return [];
        }
        static parse(tokenizer) {
            return tokenizer.newContext((read, peek) => {
                tokenization.expect(read(), "boolean");
                return BooleanType.INSTANCE;
            });
        }
    }
    exports.BooleanType = BooleanType;
    BooleanType.INSTANCE = new BooleanType();
    ;
    class BooleanLiteralType {
        constructor(value) {
            this.value = value;
        }
        generateType(options) {
            return "" + this.value;
        }
        generateTypeGuard(options) {
            let lines = new Array();
            if (options.standalone) {
                lines.push("(subject, path) => {");
                lines.push("	if (subject === " + this.generateType(Object.assign(Object.assign({}, options), { eol: options.eol + "\t" })) + ") {");
                lines.push("		return subject;");
                lines.push("	}");
                lines.push("	throw \"Expected " + this.value + " at \" + path + \"!\";");
                lines.push("}");
            }
            else {
                lines.push("autoguard.BooleanLiteral.of(" + this.generateType(Object.assign(Object.assign({}, options), { eol: options.eol })) + ")");
            }
            return lines.join(options.eol);
        }
        getImports() {
            return [];
        }
        static parse(tokenizer) {
            return tokenizer.newContext((read, peek) => {
                let token = tokenization.expect(read(), [
                    "true",
                    "false"
                ]);
                if (token.family === "true") {
                    return BooleanLiteralType.INSTANCE_TRUE;
                }
                else {
                    return BooleanLiteralType.INSTANCE_FALSE;
                }
            });
        }
    }
    exports.BooleanLiteralType = BooleanLiteralType;
    BooleanLiteralType.INSTANCE_TRUE = new BooleanLiteralType(true);
    BooleanLiteralType.INSTANCE_FALSE = new BooleanLiteralType(false);
    ;
    class GroupType {
        constructor(type) {
            this.type = type;
        }
        generateType(options) {
            return "(" + this.type.generateType(options) + ")";
        }
        generateTypeGuard(options) {
            return this.type.generateTypeGuard(options);
        }
        getImports() {
            return this.type.getImports();
        }
        static parse(tokenizer) {
            return tokenizer.newContext((read, peek) => {
                tokenization.expect(read(), "(");
                let type = exports.Type.parse(tokenizer);
                tokenization.expect(read(), ")");
                return new GroupType(type);
            });
        }
    }
    exports.GroupType = GroupType;
    ;
    class IntersectionType {
        constructor() {
            this.types = new Set();
        }
        add(type) {
            this.types.add(type);
            return this;
        }
        generateType(options) {
            let lines = new Array();
            for (let type of this.types) {
                lines.push(type.generateType(options));
            }
            let string = lines.join(" & ");
            return string;
        }
        generateTypeGuard(options) {
            let lines = new Array();
            if (options.standalone) {
                lines.push("(subject, path) => {");
                for (let type of this.types) {
                    lines.push("	(" + type.generateTypeGuard(Object.assign(Object.assign({}, options), { eol: options.eol + "\t" })) + ")(subject, path);");
                }
                lines.push("	return subject;");
                lines.push("}");
                return lines.join(options.eol);
            }
            else {
                for (let type of this.types) {
                    lines.push("	" + type.generateTypeGuard(Object.assign(Object.assign({}, options), { eol: options.eol + "\t" })));
                }
                return "autoguard.Intersection.of(" + options.eol + lines.join("," + options.eol) + options.eol + ")";
            }
        }
        getImports() {
            let imports = new Array();
            for (let type of this.types) {
                imports.push(...type.getImports());
            }
            return imports;
        }
        static parse(tokenizer, ...exclude) {
            if (exclude.includes("Intersection")) {
                throw `Recursion prevention!`;
            }
            return tokenizer.newContext((read, peek) => {
                var _a;
                let type = exports.Type.parse(tokenizer, ...exclude, "Intersection");
                let instance = new IntersectionType();
                instance.add(type);
                while (true) {
                    if (((_a = peek()) === null || _a === void 0 ? void 0 : _a.value) !== "&") {
                        break;
                    }
                    tokenization.expect(read(), "&");
                    let type = exports.Type.parse(tokenizer, ...exclude, "Intersection");
                    instance.add(type);
                }
                if (instance.types.size === 1) {
                    return type;
                }
                return instance;
            });
        }
    }
    exports.IntersectionType = IntersectionType;
    ;
    class NullType {
        constructor() {
        }
        generateType(options) {
            return "null";
        }
        generateTypeGuard(options) {
            let lines = new Array();
            if (options.standalone) {
                lines.push("(subject, path) => {");
                lines.push("	if (subject === null) {");
                lines.push("		return subject;");
                lines.push("	}");
                lines.push("	throw \"Expected null at \" + path + \"!\";");
                lines.push("}");
            }
            else {
                lines.push("autoguard.Null");
            }
            return lines.join(options.eol);
        }
        getImports() {
            return [];
        }
        static parse(tokenizer) {
            return tokenizer.newContext((read, peek) => {
                tokenization.expect(read(), "null");
                return NullType.INSTANCE;
            });
        }
    }
    exports.NullType = NullType;
    NullType.INSTANCE = new NullType();
    ;
    class NumberType {
        constructor() {
        }
        generateType(options) {
            return "number";
        }
        generateTypeGuard(options) {
            let lines = new Array();
            if (options.standalone) {
                lines.push("(subject, path) => {");
                lines.push("	if ((subject != null) && (subject.constructor === globalThis.Number)) {");
                lines.push("		return subject as number;");
                lines.push("	}");
                lines.push("	throw \"Expected a number at \" + path + \"!\";");
                lines.push("}");
            }
            else {
                lines.push("autoguard.Number");
            }
            return lines.join(options.eol);
        }
        getImports() {
            return [];
        }
        static parse(tokenizer) {
            return tokenizer.newContext((read, peek) => {
                tokenization.expect(read(), "number");
                return NumberType.INSTANCE;
            });
        }
    }
    exports.NumberType = NumberType;
    NumberType.INSTANCE = new NumberType();
    ;
    class NumberLiteralType {
        constructor(value) {
            this.value = value;
        }
        generateType(options) {
            return "" + this.value;
        }
        generateTypeGuard(options) {
            let lines = new Array();
            if (options.standalone) {
                lines.push("(subject, path) => {");
                lines.push("	if (subject === " + this.generateType(Object.assign(Object.assign({}, options), { eol: options.eol + "\t" })) + ") {");
                lines.push("		return subject;");
                lines.push("	}");
                lines.push("	throw \"Expected " + this.value + " at \" + path + \"!\";");
                lines.push("}");
            }
            else {
                lines.push("autoguard.NumberLiteral.of(" + this.generateType(Object.assign(Object.assign({}, options), { eol: options.eol })) + ")");
            }
            return lines.join(options.eol);
        }
        getImports() {
            return [];
        }
        static parse(tokenizer) {
            return tokenizer.newContext((read, peek) => {
                let value = tokenization.expect(read(), "NUMBER_LITERAL").value;
                return new NumberLiteralType(Number.parseInt(value));
            });
        }
    }
    exports.NumberLiteralType = NumberLiteralType;
    ;
    class ObjectType {
        constructor() {
            this.members = new Map();
        }
        add(key, value) {
            this.members.set(key, value);
            return this;
        }
        generateType(options) {
            if (this.members.size === 0) {
                return "{}";
            }
            let lines = new Array();
            for (let [key, value] of this.members) {
                lines.push("	\"" + key + "\"" + (value.optional ? "?" : "") + ": " + value.type.generateType(Object.assign(Object.assign({}, options), { eol: options.eol + "\t" })));
            }
            let string = lines.length > 0 ? options.eol + lines.join("," + options.eol) + options.eol : "";
            return "{" + string + "}";
        }
        generateTypeGuard(options) {
            let lines = new Array();
            if (options.standalone) {
                lines.push("(subject, path) => {");
                lines.push("	if ((subject != null) && (subject.constructor === globalThis.Object)) {");
                for (let [key, value] of this.members) {
                    let type = value.type;
                    if (value.optional) {
                        let union = new UnionType();
                        union.add(UndefinedType.INSTANCE);
                        union.add(type);
                        type = union;
                    }
                    let tail = /^([a-z][a-z0-9_]*)$/is.test(key) ? "\"." + key + "\"" : "\"[\\\"" + key + "\\\"]\"";
                    lines.push("		(" + type.generateTypeGuard(Object.assign(Object.assign({}, options), { eol: options.eol + "\t\t" })) + ")(subject[\"" + key + "\"], path + " + tail + ");");
                }
                lines.push("		return subject;");
                lines.push("	}");
                lines.push("	throw \"Expected an object at \" + path + \"!\";");
                lines.push("}");
                return lines.join(options.eol);
            }
            else {
                for (let [key, value] of this.members) {
                    let type = value.type;
                    if (value.optional) {
                        let union = new UnionType();
                        union.add(UndefinedType.INSTANCE);
                        union.add(type);
                        type = union;
                    }
                    lines.push("	\"" + key + "\": " + type.generateTypeGuard(Object.assign(Object.assign({}, options), { eol: options.eol + "\t" })));
                }
                let type = this.typename != null ? this.typename : this.generateType(options);
                let guard = lines.length > 0 ? options.eol + lines.join("," + options.eol) + options.eol : "";
                return "autoguard.Object.of<" + type + ">({" + guard + "})";
            }
        }
        getImports() {
            let imports = new Array();
            for (let [key, value] of this.members) {
                let type = value.type;
                imports.push(...type.getImports());
            }
            return imports;
        }
        setTypename(typename) {
            this.typename = typename;
        }
        static parse(tokenizer) {
            return tokenizer.newContext((read, peek) => {
                var _a, _b, _c;
                tokenization.expect(read(), "{");
                let instance = new ObjectType();
                if (((_a = peek()) === null || _a === void 0 ? void 0 : _a.value) !== "}") {
                    while (true) {
                        let optional = false;
                        let token = tokenization.expect(read(), [
                            "any",
                            "boolean",
                            "false",
                            "null",
                            "number",
                            "string",
                            "true",
                            "undefined",
                            "IDENTIFIER",
                            "STRING_LITERAL"
                        ]);
                        let key = token.family === "STRING_LITERAL" ? token.value.slice(1, -1) : token.value;
                        if (((_b = peek()) === null || _b === void 0 ? void 0 : _b.value) === "?") {
                            read();
                            optional = true;
                        }
                        tokenization.expect(read(), ":");
                        let type = exports.Type.parse(tokenizer);
                        instance.add(key, {
                            type,
                            optional
                        });
                        if (((_c = peek()) === null || _c === void 0 ? void 0 : _c.value) !== ",") {
                            break;
                        }
                        tokenization.expect(read(), ",");
                    }
                }
                tokenization.expect(read(), "}");
                return instance;
            });
        }
    }
    exports.ObjectType = ObjectType;
    ;
    class RecordType {
        constructor(type) {
            this.type = type;
        }
        generateType(options) {
            return "Record<string, undefined | " + this.type.generateType(options) + ">";
        }
        generateTypeGuard(options) {
            let lines = new Array();
            if (options.standalone) {
                lines.push("(subject, path) => {");
                lines.push("	if ((subject != null) && (subject.constructor === globalThis.Object)) {");
                lines.push("		for (let key of globalThis.Object.keys(subject)) {");
                lines.push("			(" + this.type.generateTypeGuard(Object.assign(Object.assign({}, options), { eol: options.eol + "\t\t\t" })) + ")(subject[key], path + \"[\\\"\" + key + \"\\\"]\");");
                lines.push("		}");
                lines.push("		return subject;");
                lines.push("	}");
                lines.push("	throw \"Expected a record at \" + path + \"!\";");
                lines.push("}");
            }
            else {
                lines.push("autoguard.Record.of(" + this.type.generateTypeGuard(Object.assign(Object.assign({}, options), { eol: options.eol })) + ")");
            }
            return lines.join(options.eol);
        }
        getImports() {
            return this.type.getImports();
        }
        static parse(tokenizer) {
            return tokenizer.newContext((read, peek) => {
                tokenization.expect(read(), "{");
                let type = exports.Type.parse(tokenizer);
                tokenization.expect(read(), "}");
                return new RecordType(type);
            });
        }
    }
    exports.RecordType = RecordType;
    ;
    class ReferenceType {
        constructor(path, typename) {
            this.path = path;
            this.typename = typename;
        }
        generateType(options) {
            return this.typename;
        }
        generateTypeGuard(options) {
            if (options.standalone) {
                return this.typename + ".as";
            }
            else {
                return "autoguard.Reference.of<" + this.typename + ">(() => " + this.typename + ")";
            }
        }
        getImports() {
            if (this.path.length > 0) {
                return [
                    {
                        path: this.path,
                        typename: this.typename
                    }
                ];
            }
            return [];
        }
        static parse(tokenizer) {
            return tokenizer.newContext((read, peek) => {
                var _a, _b;
                if (((_a = peek()) === null || _a === void 0 ? void 0 : _a.family) === "@") {
                    tokenization.expect(read(), "@");
                }
                let tokens = new Array();
                while (true) {
                    let token = read();
                    tokenization.expect(token, [".", "..", "IDENTIFIER"]);
                    tokens.push(token);
                    if (((_b = peek()) === null || _b === void 0 ? void 0 : _b.family) !== "/") {
                        break;
                    }
                    tokenization.expect(read(), "/");
                }
                let last = tokens.pop();
                tokenization.expect(last, "IDENTIFIER");
                return new ReferenceType(tokens.map((token) => token.value), last.value);
            });
        }
    }
    exports.ReferenceType = ReferenceType;
    ;
    class StringType {
        constructor() {
        }
        generateType(options) {
            return "string";
        }
        generateTypeGuard(options) {
            let lines = new Array();
            if (options.standalone) {
                lines.push("(subject, path) => {");
                lines.push("	if ((subject != null) && (subject.constructor === globalThis.String)) {");
                lines.push("		return subject as string;");
                lines.push("	}");
                lines.push("	throw \"Expected a string at \" + path + \"!\";");
                lines.push("}");
            }
            else {
                lines.push("autoguard.String");
            }
            return lines.join(options.eol);
        }
        getImports() {
            return [];
        }
        static parse(tokenizer) {
            return tokenizer.newContext((read, peek) => {
                tokenization.expect(read(), "string");
                return StringType.INSTANCE;
            });
        }
    }
    exports.StringType = StringType;
    StringType.INSTANCE = new StringType();
    ;
    class StringLiteralType {
        constructor(value) {
            this.value = value;
        }
        generateType(options) {
            return "\"" + this.value + "\"";
        }
        generateTypeGuard(options) {
            let lines = new Array();
            if (options.standalone) {
                lines.push("(subject, path) => {");
                lines.push("	if (subject === " + this.generateType(Object.assign(Object.assign({}, options), { eol: options.eol + "\t" })) + ") {");
                lines.push("		return subject;");
                lines.push("	}");
                lines.push("	throw \"Expected \\\"" + this.value + "\\\" at \" + path + \"!\";");
                lines.push("}");
            }
            else {
                lines.push("autoguard.StringLiteral.of(\"" + this.value + "\")");
            }
            return lines.join(options.eol);
        }
        getImports() {
            return [];
        }
        static parse(tokenizer) {
            return tokenizer.newContext((read, peek) => {
                let value = tokenization.expect(read(), "STRING_LITERAL").value;
                return new StringLiteralType(value.slice(1, -1));
            });
        }
    }
    exports.StringLiteralType = StringLiteralType;
    ;
    class TupleType {
        constructor() {
            this.types = new Array();
        }
        add(type) {
            this.types.push(type);
            return this;
        }
        generateType(options) {
            let strings = new Array();
            for (let type of this.types) {
                strings.push("	" + type.generateType(Object.assign(Object.assign({}, options), { eol: options.eol + "\t" })));
            }
            let string = strings.length > 0 ? options.eol + strings.join("," + options.eol) + options.eol : "";
            return "[" + string + "]";
        }
        generateTypeGuard(options) {
            let lines = new Array();
            if (options.standalone) {
                lines.push("(subject, path) => {");
                lines.push("	if ((subject != null) && (subject.constructor === globalThis.Array)) {");
                for (let i = 0; i < this.types.length; i++) {
                    let type = this.types[i];
                    lines.push("		(" + type.generateTypeGuard(Object.assign(Object.assign({}, options), { eol: options.eol + "\t\t" })) + ")(subject[" + i + "], path + \"[" + i + "]\");");
                }
                lines.push("		return subject as " + this.generateType(Object.assign(Object.assign({}, options), { eol: options.eol + "\t\t" })) + ";");
                lines.push("	}");
                lines.push("	throw \"Expected a tuple at \" + path + \"!\";");
                lines.push("}");
                return lines.join(options.eol);
            }
            else {
                for (let type of this.types) {
                    lines.push("	" + type.generateTypeGuard(Object.assign(Object.assign({}, options), { eol: options.eol + "\t" })));
                }
                let string = lines.length > 0 ? options.eol + lines.join("," + options.eol) + options.eol : "";
                return "autoguard.Tuple.of(" + string + ")";
            }
        }
        getImports() {
            let imports = new Array();
            for (let type of this.types) {
                imports.push(...type.getImports());
            }
            return imports;
        }
        static parse(tokenizer) {
            return tokenizer.newContext((read, peek) => {
                var _a, _b;
                tokenization.expect(read(), "[");
                let instance = new TupleType();
                if (((_a = peek()) === null || _a === void 0 ? void 0 : _a.value) !== "]") {
                    while (true) {
                        let type = exports.Type.parse(tokenizer);
                        instance.add(type);
                        if (((_b = peek()) === null || _b === void 0 ? void 0 : _b.value) !== ",") {
                            break;
                        }
                        tokenization.expect(read(), ",");
                    }
                }
                tokenization.expect(read(), "]");
                return instance;
            });
        }
    }
    exports.TupleType = TupleType;
    ;
    class UndefinedType {
        constructor() {
        }
        generateType(options) {
            return "undefined";
        }
        generateTypeGuard(options) {
            let lines = new Array();
            if (options.standalone) {
                lines.push("(subject, path) => {");
                lines.push("	if (subject === undefined) {");
                lines.push("		return subject;");
                lines.push("	}");
                lines.push("	throw \"Expected undefined at \" + path + \"!\";");
                lines.push("}");
            }
            else {
                lines.push("autoguard.Undefined");
            }
            return lines.join(options.eol);
        }
        getImports() {
            return [];
        }
        static parse(tokenizer) {
            return tokenizer.newContext((read, peek) => {
                tokenization.expect(read(), "undefined");
                return UndefinedType.INSTANCE;
            });
        }
    }
    exports.UndefinedType = UndefinedType;
    UndefinedType.INSTANCE = new UndefinedType();
    ;
    class UnionType {
        constructor() {
            this.types = new Set();
        }
        add(type) {
            this.types.add(type);
            return this;
        }
        generateType(options) {
            let lines = new Array();
            for (let type of this.types) {
                lines.push(type.generateType(options));
            }
            let string = lines.join(" | ");
            return string;
        }
        generateTypeGuard(options) {
            let lines = new Array();
            if (options.standalone) {
                lines.push("(subject, path) => {");
                for (let type of this.types) {
                    lines.push("	try {");
                    lines.push("		return (" + type.generateTypeGuard(Object.assign(Object.assign({}, options), { eol: options.eol + "\t\t" })) + ")(subject, path);");
                    lines.push("	} catch (error) {}");
                }
                lines.push("	throw \"Expected a union at \" + path + \"!\";");
                lines.push("}");
                return lines.join(options.eol);
            }
            else {
                for (let type of this.types) {
                    lines.push("	" + type.generateTypeGuard(Object.assign(Object.assign({}, options), { eol: options.eol + "\t" })));
                }
                return "autoguard.Union.of(" + options.eol + lines.join("," + options.eol) + options.eol + ")";
            }
        }
        getImports() {
            let imports = new Array();
            for (let type of this.types) {
                imports.push(...type.getImports());
            }
            return imports;
        }
        static parse(tokenizer, ...exclude) {
            if (exclude.includes("Union")) {
                throw `Recursion prevention!`;
            }
            return tokenizer.newContext((read, peek) => {
                var _a;
                let type = exports.Type.parse(tokenizer, ...exclude, "Union");
                let instance = new UnionType();
                instance.add(type);
                while (true) {
                    if (((_a = peek()) === null || _a === void 0 ? void 0 : _a.value) !== "|") {
                        break;
                    }
                    tokenization.expect(read(), "|");
                    let type = exports.Type.parse(tokenizer, ...exclude, "Union");
                    instance.add(type);
                }
                if (instance.types.size === 1) {
                    return type;
                }
                return instance;
            });
        }
    }
    exports.UnionType = UnionType;
    ;
    class Schema {
        constructor() {
            this.types = new Map();
        }
        getImports() {
            let imports = new Map();
            for (let [key, value] of this.types) {
                let entries = value.getImports();
                for (let entry of entries) {
                    imports.set(entry.typename, entry.path);
                }
            }
            return Array.from(imports.entries())
                .sort((one, two) => one[0].localeCompare(two[0]))
                .map((entry) => {
                return {
                    path: entry[1],
                    typename: entry[0]
                };
            });
        }
        add(key, value) {
            this.types.set(key, value);
            return this;
        }
        generateModule(options) {
            let lines = new Array();
            lines.push("// This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.");
            lines.push("");
            let imports = this.getImports();
            for (let entry of imports) {
                lines.push("import { " + entry.typename + " } from \"" + entry.path.join("/") + "\";");
            }
            if (!options.standalone) {
                lines.push("import { guards as autoguard } from \"@joelek/ts-autoguard\";");
            }
            lines.push("");
            for (let [key, value] of this.types) {
                lines.push("export type " + key + " = " + value.generateType(options) + ";");
                lines.push("");
                if (options.standalone) {
                    lines.push("export const " + key + " = {");
                    lines.push("	as(subject: any, path: string = \"\"): " + key + " {");
                    lines.push("		return (" + value.generateTypeGuard(Object.assign(Object.assign({}, options), { eol: options.eol + "\t\t" })) + ")(subject, path);");
                    lines.push("	},");
                    lines.push("	is(subject: any): subject is " + key + " {");
                    lines.push("		try {");
                    lines.push("			this.as(subject);");
                    lines.push("		} catch (error) {");
                    lines.push("			return false;");
                    lines.push("		}");
                    lines.push("		return true;");
                    lines.push("	}");
                    lines.push("};");
                    lines.push("");
                }
                else {
                    lines.push("export const " + key + " = " + value.generateTypeGuard(Object.assign(Object.assign({}, options), { eol: options.eol })) + ";");
                    lines.push("");
                }
            }
            let autoguard = new ObjectType();
            for (let [key, value] of this.types) {
                autoguard.add(key, {
                    type: new ReferenceType([], key),
                    optional: false
                });
            }
            lines.push("export type Autoguard = " + autoguard.generateType(options) + ";");
            lines.push("");
            lines.push("export const Autoguard = " + autoguard.generateType(options) + ";");
            lines.push("");
            return lines.join(options.eol);
        }
        static parse(tokenizer) {
            return tokenizer.newContext((read, peek) => {
                var _a, _b, _c;
                tokenization.expect(read(), "{");
                let instance = new Schema();
                if (((_a = peek()) === null || _a === void 0 ? void 0 : _a.value) !== "}") {
                    while (true) {
                        let identifier = tokenization.expect(read(), "IDENTIFIER").value;
                        tokenization.expect(read(), ":");
                        let type = exports.Type.parse(tokenizer);
                        (_b = type.setTypename) === null || _b === void 0 ? void 0 : _b.call(type, identifier);
                        instance.add(identifier, type);
                        if (((_c = peek()) === null || _c === void 0 ? void 0 : _c.value) !== ",") {
                            break;
                        }
                        tokenization.expect(read(), ",");
                    }
                }
                tokenization.expect(read(), "}");
                if (peek() != null) {
                    throw `Expected end of stream!`;
                }
                return instance;
            });
        }
    }
    exports.Schema = Schema;
    ;
});
define("node_modules/@joelek/ts-autoguard/build/autoguard-lib/serialization", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MessageSerializer = void 0;
    class MessageSerializer {
        constructor(guards) {
            this.guards = guards;
        }
        deserialize(string, cb) {
            let json = JSON.parse(string);
            if ((json != null) && (json.constructor === Object)) {
                if ((json.type != null) && (json.type.constructor === String)) {
                    let type = json.type;
                    let data = json.data;
                    let guard = this.guards[type];
                    if (guard === undefined) {
                        throw "Unknown message type \"" + type + "\"!";
                    }
                    cb(type, guard.as(data));
                    return;
                }
            }
            throw "Invalid message envelope!";
        }
        serialize(type, data) {
            return JSON.stringify({
                type,
                data
            });
        }
    }
    exports.MessageSerializer = MessageSerializer;
    ;
});
define("node_modules/@joelek/ts-autoguard/build/autoguard-lib/index", ["require", "exports", "node_modules/@joelek/ts-autoguard/build/autoguard-lib/guards", "node_modules/@joelek/ts-autoguard/build/autoguard-lib/language", "node_modules/@joelek/ts-autoguard/build/autoguard-lib/serialization", "node_modules/@joelek/ts-autoguard/build/autoguard-lib/tokenization"], function (require, exports, guards, language, serialization, tokenization) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.transform = exports.tokenization = exports.serialization = exports.language = exports.guards = void 0;
    exports.guards = guards;
    exports.language = language;
    exports.serialization = serialization;
    exports.tokenization = tokenization;
    function transform(string, options) {
        let tokenizer = new tokenization.Tokenizer(string);
        let schema = language.Schema.parse(tokenizer);
        return schema.generateModule(options);
    }
    exports.transform = transform;
});
define("build/database/schema", ["require", "exports", "node_modules/@joelek/ts-autoguard/build/autoguard-lib/index"], function (require, exports, ts_autoguard_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.Year = exports.PlaylistItem = exports.Playlist = exports.Stream = exports.Token = exports.Key = exports.User = exports.Cue = exports.Subtitle = exports.ShowGenre = exports.MovieGenre = exports.Genre = exports.ShowActor = exports.MovieActor = exports.Actor = exports.MovieFile = exports.Movie = exports.EpisodeFile = exports.Episode = exports.Season = exports.ShowFile = exports.Show = exports.TrackArtist = exports.AlbumArtist = exports.TrackFile = exports.Track = exports.Disc = exports.AlbumFile = exports.Album = exports.Artist = exports.VideoSubtitle = exports.VideoFile = exports.SubtitleFile = exports.MetadataFile = exports.ImageFile = exports.AudioFile = exports.File = exports.Directory = void 0;
    exports.Directory = ts_autoguard_1.guards.Object.of({
        "directory_id": ts_autoguard_1.guards.String,
        "name": ts_autoguard_1.guards.String,
        "parent_directory_id": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.String)
    });
    exports.File = ts_autoguard_1.guards.Object.of({
        "file_id": ts_autoguard_1.guards.String,
        "name": ts_autoguard_1.guards.String,
        "parent_directory_id": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.String),
        "index_timestamp": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.Number)
    });
    exports.AudioFile = ts_autoguard_1.guards.Object.of({
        "file_id": ts_autoguard_1.guards.String,
        "mime": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.StringLiteral.of("audio/mp4"), ts_autoguard_1.guards.StringLiteral.of("audio/mp3")),
        "duration_ms": ts_autoguard_1.guards.Number
    });
    exports.ImageFile = ts_autoguard_1.guards.Object.of({
        "file_id": ts_autoguard_1.guards.String,
        "mime": ts_autoguard_1.guards.StringLiteral.of("image/jpeg"),
        "width": ts_autoguard_1.guards.Number,
        "height": ts_autoguard_1.guards.Number
    });
    exports.MetadataFile = ts_autoguard_1.guards.Object.of({
        "file_id": ts_autoguard_1.guards.String,
        "mime": ts_autoguard_1.guards.StringLiteral.of("application/json")
    });
    exports.SubtitleFile = ts_autoguard_1.guards.Object.of({
        "file_id": ts_autoguard_1.guards.String,
        "mime": ts_autoguard_1.guards.StringLiteral.of("text/vtt"),
        "duration_ms": ts_autoguard_1.guards.Number,
        "language": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.String)
    });
    exports.VideoFile = ts_autoguard_1.guards.Object.of({
        "file_id": ts_autoguard_1.guards.String,
        "mime": ts_autoguard_1.guards.StringLiteral.of("video/mp4"),
        "duration_ms": ts_autoguard_1.guards.Number,
        "width": ts_autoguard_1.guards.Number,
        "height": ts_autoguard_1.guards.Number
    });
    exports.VideoSubtitle = ts_autoguard_1.guards.Object.of({
        "video_file_id": ts_autoguard_1.guards.String,
        "subtitle_file_id": ts_autoguard_1.guards.String
    });
    exports.Artist = ts_autoguard_1.guards.Object.of({
        "artist_id": ts_autoguard_1.guards.String,
        "name": ts_autoguard_1.guards.String
    });
    exports.Album = ts_autoguard_1.guards.Object.of({
        "album_id": ts_autoguard_1.guards.String,
        "title": ts_autoguard_1.guards.String,
        "year": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.Number)
    });
    exports.AlbumFile = ts_autoguard_1.guards.Object.of({
        "album_id": ts_autoguard_1.guards.String,
        "file_id": ts_autoguard_1.guards.String
    });
    exports.Disc = ts_autoguard_1.guards.Object.of({
        "disc_id": ts_autoguard_1.guards.String,
        "album_id": ts_autoguard_1.guards.String,
        "number": ts_autoguard_1.guards.Number
    });
    exports.Track = ts_autoguard_1.guards.Object.of({
        "track_id": ts_autoguard_1.guards.String,
        "disc_id": ts_autoguard_1.guards.String,
        "title": ts_autoguard_1.guards.String,
        "number": ts_autoguard_1.guards.Number
    });
    exports.TrackFile = ts_autoguard_1.guards.Object.of({
        "track_id": ts_autoguard_1.guards.String,
        "file_id": ts_autoguard_1.guards.String
    });
    exports.AlbumArtist = ts_autoguard_1.guards.Object.of({
        "album_id": ts_autoguard_1.guards.String,
        "artist_id": ts_autoguard_1.guards.String,
        "order": ts_autoguard_1.guards.Number
    });
    exports.TrackArtist = ts_autoguard_1.guards.Object.of({
        "track_id": ts_autoguard_1.guards.String,
        "artist_id": ts_autoguard_1.guards.String,
        "order": ts_autoguard_1.guards.Number
    });
    exports.Show = ts_autoguard_1.guards.Object.of({
        "show_id": ts_autoguard_1.guards.String,
        "name": ts_autoguard_1.guards.String,
        "summary": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.String)
    });
    exports.ShowFile = ts_autoguard_1.guards.Object.of({
        "show_id": ts_autoguard_1.guards.String,
        "file_id": ts_autoguard_1.guards.String
    });
    exports.Season = ts_autoguard_1.guards.Object.of({
        "season_id": ts_autoguard_1.guards.String,
        "show_id": ts_autoguard_1.guards.String,
        "number": ts_autoguard_1.guards.Number
    });
    exports.Episode = ts_autoguard_1.guards.Object.of({
        "episode_id": ts_autoguard_1.guards.String,
        "season_id": ts_autoguard_1.guards.String,
        "title": ts_autoguard_1.guards.String,
        "number": ts_autoguard_1.guards.Number,
        "year": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.Number),
        "summary": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.String)
    });
    exports.EpisodeFile = ts_autoguard_1.guards.Object.of({
        "episode_id": ts_autoguard_1.guards.String,
        "file_id": ts_autoguard_1.guards.String
    });
    exports.Movie = ts_autoguard_1.guards.Object.of({
        "movie_id": ts_autoguard_1.guards.String,
        "title": ts_autoguard_1.guards.String,
        "year": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.Number),
        "summary": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.String)
    });
    exports.MovieFile = ts_autoguard_1.guards.Object.of({
        "movie_id": ts_autoguard_1.guards.String,
        "file_id": ts_autoguard_1.guards.String
    });
    exports.Actor = ts_autoguard_1.guards.Object.of({
        "actor_id": ts_autoguard_1.guards.String,
        "name": ts_autoguard_1.guards.String
    });
    exports.MovieActor = ts_autoguard_1.guards.Object.of({
        "movie_id": ts_autoguard_1.guards.String,
        "actor_id": ts_autoguard_1.guards.String,
        "order": ts_autoguard_1.guards.Number
    });
    exports.ShowActor = ts_autoguard_1.guards.Object.of({
        "show_id": ts_autoguard_1.guards.String,
        "actor_id": ts_autoguard_1.guards.String,
        "order": ts_autoguard_1.guards.Number
    });
    exports.Genre = ts_autoguard_1.guards.Object.of({
        "genre_id": ts_autoguard_1.guards.String,
        "name": ts_autoguard_1.guards.String
    });
    exports.MovieGenre = ts_autoguard_1.guards.Object.of({
        "movie_id": ts_autoguard_1.guards.String,
        "genre_id": ts_autoguard_1.guards.String,
        "order": ts_autoguard_1.guards.Number
    });
    exports.ShowGenre = ts_autoguard_1.guards.Object.of({
        "show_id": ts_autoguard_1.guards.String,
        "genre_id": ts_autoguard_1.guards.String,
        "order": ts_autoguard_1.guards.Number
    });
    exports.Subtitle = ts_autoguard_1.guards.Object.of({
        "subtitle_id": ts_autoguard_1.guards.String,
        "file_id": ts_autoguard_1.guards.String
    });
    exports.Cue = ts_autoguard_1.guards.Object.of({
        "cue_id": ts_autoguard_1.guards.String,
        "subtitle_id": ts_autoguard_1.guards.String,
        "start_ms": ts_autoguard_1.guards.Number,
        "duration_ms": ts_autoguard_1.guards.Number,
        "lines": ts_autoguard_1.guards.String
    });
    exports.User = ts_autoguard_1.guards.Object.of({
        "user_id": ts_autoguard_1.guards.String,
        "name": ts_autoguard_1.guards.String,
        "username": ts_autoguard_1.guards.String,
        "password": ts_autoguard_1.guards.String
    });
    exports.Key = ts_autoguard_1.guards.Object.of({
        "key_id": ts_autoguard_1.guards.String,
        "user_id": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.String)
    });
    exports.Token = ts_autoguard_1.guards.Object.of({
        "token_id": ts_autoguard_1.guards.String,
        "user_id": ts_autoguard_1.guards.String,
        "hash": ts_autoguard_1.guards.String,
        "expires_ms": ts_autoguard_1.guards.Number
    });
    exports.Stream = ts_autoguard_1.guards.Object.of({
        "stream_id": ts_autoguard_1.guards.String,
        "user_id": ts_autoguard_1.guards.String,
        "file_id": ts_autoguard_1.guards.String,
        "timestamp_ms": ts_autoguard_1.guards.Number
    });
    exports.Playlist = ts_autoguard_1.guards.Object.of({
        "playlist_id": ts_autoguard_1.guards.String,
        "title": ts_autoguard_1.guards.String,
        "description": ts_autoguard_1.guards.String,
        "user_id": ts_autoguard_1.guards.String
    });
    exports.PlaylistItem = ts_autoguard_1.guards.Object.of({
        "playlist_item_id": ts_autoguard_1.guards.String,
        "playlist_id": ts_autoguard_1.guards.String,
        "track_id": ts_autoguard_1.guards.String,
        "number": ts_autoguard_1.guards.Number,
        "added_ms": ts_autoguard_1.guards.Number
    });
    exports.Year = ts_autoguard_1.guards.Object.of({
        "year_id": ts_autoguard_1.guards.String,
        "year": ts_autoguard_1.guards.Number
    });
    exports.Autoguard = {
        "Directory": exports.Directory,
        "File": exports.File,
        "AudioFile": exports.AudioFile,
        "ImageFile": exports.ImageFile,
        "MetadataFile": exports.MetadataFile,
        "SubtitleFile": exports.SubtitleFile,
        "VideoFile": exports.VideoFile,
        "VideoSubtitle": exports.VideoSubtitle,
        "Artist": exports.Artist,
        "Album": exports.Album,
        "AlbumFile": exports.AlbumFile,
        "Disc": exports.Disc,
        "Track": exports.Track,
        "TrackFile": exports.TrackFile,
        "AlbumArtist": exports.AlbumArtist,
        "TrackArtist": exports.TrackArtist,
        "Show": exports.Show,
        "ShowFile": exports.ShowFile,
        "Season": exports.Season,
        "Episode": exports.Episode,
        "EpisodeFile": exports.EpisodeFile,
        "Movie": exports.Movie,
        "MovieFile": exports.MovieFile,
        "Actor": exports.Actor,
        "MovieActor": exports.MovieActor,
        "ShowActor": exports.ShowActor,
        "Genre": exports.Genre,
        "MovieGenre": exports.MovieGenre,
        "ShowGenre": exports.ShowGenre,
        "Subtitle": exports.Subtitle,
        "Cue": exports.Cue,
        "User": exports.User,
        "Key": exports.Key,
        "Token": exports.Token,
        "Stream": exports.Stream,
        "Playlist": exports.Playlist,
        "PlaylistItem": exports.PlaylistItem,
        "Year": exports.Year
    };
});
define("node_modules/@joelek/ts-stdlib/build/routing/index", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NamespacedMessageRouter = exports.MessageRouter = void 0;
    class MessageRouter {
        constructor() {
            this.observers = new Map();
        }
        addObserver(type, observer) {
            let observers = this.observers.get(type);
            if (observers === undefined) {
                observers = new Set();
                this.observers.set(type, observers);
            }
            observers.add(observer);
        }
        removeObserver(type, observer) {
            let observers = this.observers.get(type);
            if (observers !== undefined) {
                observers.delete(observer);
            }
        }
        route(type, message) {
            let observers = this.observers.get(type);
            if (observers !== undefined) {
                for (let observer of observers) {
                    observer(message);
                }
            }
        }
    }
    exports.MessageRouter = MessageRouter;
    ;
    class NamespacedMessageRouter {
        constructor() {
            this.routers = new Map();
        }
        addObserver(namespace, type, observer) {
            let router = this.routers.get(namespace);
            if (router === undefined) {
                router = new MessageRouter();
                this.routers.set(namespace, router);
            }
            router.addObserver(type, observer);
        }
        removeObserver(namespace, type, observer) {
            let router = this.routers.get(namespace);
            if (router !== undefined) {
                router.removeObserver(type, observer);
            }
        }
        route(namespace, type, message) {
            let router = this.routers.get(namespace);
            if (router !== undefined) {
                router.route(type, message);
            }
        }
    }
    exports.NamespacedMessageRouter = NamespacedMessageRouter;
    ;
});
define("node_modules/@joelek/ts-stdlib/build/index", ["require", "exports", "node_modules/@joelek/ts-stdlib/build/routing/index"], function (require, exports, routing) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.routing = void 0;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.routing = routing;
});
define("build/is", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.present = exports.absent = void 0;
    function absent(subject) {
        return subject == null;
    }
    exports.absent = absent;
    function present(subject) {
        return subject != null;
    }
    exports.present = present;
});
define("build/jsondb/sorters", ["require", "exports", "build/is"], function (require, exports, is) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NumericSort = exports.LexicalSort = exports.CustomSort = exports.CombinedSort = void 0;
    exports.CombinedSort = {
        of(...rankers) {
            return (one, two) => {
                for (let ranker of rankers) {
                    let rank = ranker(one, two);
                    if (rank !== 0) {
                        return rank;
                    }
                }
                return 0;
            };
        }
    };
    exports.CustomSort = {
        decreasing(getField) {
            return (one, two) => {
                let o = getField(one);
                let t = getField(two);
                if (is.absent(o)) {
                    if (is.absent(t)) {
                        return 0;
                    }
                    else {
                        return -1;
                    }
                }
                if (is.absent(t)) {
                    if (is.absent(o)) {
                        return 0;
                    }
                    else {
                        return 1;
                    }
                }
                return (t ? 1 : 0) - (o ? 1 : 0);
            };
        },
        increasing(getField) {
            return (one, two) => {
                let o = getField(one);
                let t = getField(two);
                if (is.absent(o)) {
                    if (is.absent(t)) {
                        return 0;
                    }
                    else {
                        return 1;
                    }
                }
                if (is.absent(t)) {
                    if (is.absent(o)) {
                        return 0;
                    }
                    else {
                        return -1;
                    }
                }
                return (o ? 1 : 0) - (t ? 1 : 0);
            };
        }
    };
    exports.LexicalSort = {
        decreasing(getField) {
            return (one, two) => {
                let o = getField(one);
                let t = getField(two);
                if (is.absent(o)) {
                    if (is.absent(t)) {
                        return 0;
                    }
                    else {
                        return -1;
                    }
                }
                if (is.absent(t)) {
                    if (is.absent(o)) {
                        return 0;
                    }
                    else {
                        return 1;
                    }
                }
                return t.localeCompare(o);
            };
        },
        increasing(getField) {
            return (one, two) => {
                let o = getField(one);
                let t = getField(two);
                if (is.absent(o)) {
                    if (is.absent(t)) {
                        return 0;
                    }
                    else {
                        return 1;
                    }
                }
                if (is.absent(t)) {
                    if (is.absent(o)) {
                        return 0;
                    }
                    else {
                        return -1;
                    }
                }
                return o.localeCompare(t);
            };
        }
    };
    exports.NumericSort = {
        decreasing(getField) {
            return (one, two) => {
                let o = getField(one);
                let t = getField(two);
                if (is.absent(o)) {
                    if (is.absent(t)) {
                        return 0;
                    }
                    else {
                        return -1;
                    }
                }
                if (is.absent(t)) {
                    if (is.absent(o)) {
                        return 0;
                    }
                    else {
                        return 1;
                    }
                }
                return t - o;
            };
        },
        increasing(getField) {
            return (one, two) => {
                let o = getField(one);
                let t = getField(two);
                if (is.absent(o)) {
                    if (is.absent(t)) {
                        return 0;
                    }
                    else {
                        return 1;
                    }
                }
                if (is.absent(t)) {
                    if (is.absent(o)) {
                        return 0;
                    }
                    else {
                        return -1;
                    }
                }
                return o - t;
            };
        }
    };
});
define("build/jsondb/indices", ["require", "exports", "node_modules/@joelek/ts-stdlib/build/index", "build/is", "build/jsondb/sorters"], function (require, exports, stdlib, is, sorters) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SearchIndex = exports.getTokens = exports.RecordIndex = exports.CollectionIndex = void 0;
    class CollectionIndex {
        constructor(lookupRecord, getPrimaryKey, getIndexedValue) {
            this.getPrimaryKeysFromIndexedValue = new Map();
            this.lookupRecord = lookupRecord;
            this.getPrimaryKey = getPrimaryKey;
            this.getIndexedValue = getIndexedValue;
        }
        insert(record) {
            let indexedValue = this.getIndexedValue(record);
            let primaryKeys = this.getPrimaryKeysFromIndexedValue.get(indexedValue);
            if (is.absent(primaryKeys)) {
                primaryKeys = new Set();
                this.getPrimaryKeysFromIndexedValue.set(indexedValue, primaryKeys);
            }
            let primaryKey = this.getPrimaryKey(record);
            primaryKeys.add(primaryKey);
        }
        lookup(key) {
            let primaryKeys = this.getPrimaryKeysFromIndexedValue.get(key);
            if (is.present(primaryKeys)) {
                return Array.from(primaryKeys).map(this.lookupRecord);
            }
            return new Array();
        }
        remove(record) {
            let indexedValue = this.getIndexedValue(record);
            let primaryKeys = this.getPrimaryKeysFromIndexedValue.get(indexedValue);
            if (is.present(primaryKeys)) {
                let primaryKey = this.getPrimaryKey(record);
                primaryKeys.delete(primaryKey);
                if (primaryKeys.size === 0) {
                    this.getPrimaryKeysFromIndexedValue.delete(indexedValue);
                }
            }
        }
        update(last, next) {
            this.remove(last);
            this.insert(next);
        }
        static fromIndex(parent, child, getIndexedValue) {
            let index = new CollectionIndex((key) => child.lookup(key), (record) => child.keyof(record), getIndexedValue);
            child.on("insert", (event) => {
                index.insert(event.next);
            });
            child.on("remove", (event) => {
                index.remove(event.last);
            });
            child.on("update", (event) => {
                index.update(event.last, event.next);
            });
            parent.on("remove", (event) => {
                let key = parent.keyof(event.last);
                for (let record of index.lookup(key)) {
                    child.remove(record);
                }
            });
            return index;
        }
        static fromTable(parent, child, getIndexedValue) {
            let index = new CollectionIndex((key) => child.lookup(key), (record) => child.keyof(record), getIndexedValue);
            child.on("insert", (event) => {
                index.insert(event.next);
            });
            child.on("remove", (event) => {
                index.remove(event.last);
            });
            child.on("update", (event) => {
                index.update(event.last, event.next);
            });
            parent.on("remove", (event) => {
                let key = parent.keyof(event.last);
                for (let record of index.lookup(key)) {
                    child.remove(record);
                }
            });
            return index;
        }
    }
    exports.CollectionIndex = CollectionIndex;
    ;
    class RecordIndex {
        constructor(getKey) {
            this.getRecordFromKey = new Map();
            this.getKey = getKey;
            this.router = new stdlib.routing.MessageRouter();
        }
        insertOrUpdate(next, action = "replace") {
            let key = this.getKey(next);
            let last = this.getRecordFromKey.get(key);
            if (is.present(last)) {
                if (action === "combine") {
                    for (let key in last) {
                        let lastValue = last[key];
                        let nextValue = next[key];
                        if (is.present(lastValue) && is.absent(nextValue)) {
                            next[key] = last[key];
                        }
                    }
                }
                this.getRecordFromKey.set(key, next);
                this.router.route("update", { last, next });
                this.router.route("*", {});
            }
            else {
                this.getRecordFromKey.set(key, next);
                this.router.route("insert", { next });
                this.router.route("*", {});
            }
        }
        [Symbol.iterator]() {
            return this.getRecordFromKey.values();
        }
        insert(record, action = "replace") {
            this.insertOrUpdate(record, action);
        }
        keyof(record) {
            return this.getKey(record);
        }
        length() {
            return this.getRecordFromKey.size;
        }
        lookup(key) {
            let record = this.getRecordFromKey.get(key);
            if (is.absent(record)) {
                throw `Expected "${key}" to match a record!`;
            }
            return record;
        }
        on(type, listener) {
            this.router.addObserver(type, listener);
            if (type === "insert") {
                for (let record of this.getRecordFromKey.values()) {
                    listener({ next: record });
                }
            }
        }
        off(type, listener) {
            this.router.addObserver(type, listener);
        }
        remove(record) {
            let key = this.getKey(record);
            if (this.getRecordFromKey.has(key)) {
                this.getRecordFromKey.delete(key);
                this.router.route("remove", { last: record });
                this.router.route("*", {});
            }
        }
        update(record, action = "replace") {
            this.insertOrUpdate(record, action);
        }
        static from(records, getKey) {
            let index = new RecordIndex(getKey);
            for (let record of records) {
                index.insert(record);
            }
            return index;
        }
    }
    exports.RecordIndex = RecordIndex;
    ;
    function getTokens(query) {
        let normalized = query;
        normalized = normalized.toLowerCase();
        normalized = normalized.normalize("NFKD");
        normalized = normalized.replace(/[\p{M}]/gu, "");
        return Array.from(normalized.match(/(\p{L}+|\p{N}+)/gu) ?? []);
    }
    exports.getTokens = getTokens;
    ;
    class SearchIndex {
        constructor(lookupRecord, getPrimaryKey, getIndexedValues, minTokenLength) {
            this.getPrimaryKeysFromToken = new Map();
            this.lookupRecord = lookupRecord;
            this.getPrimaryKey = getPrimaryKey;
            this.getIndexedValues = getIndexedValues;
            this.minTokenLength = minTokenLength;
        }
        insert(record) {
            for (let value of this.getIndexedValues(record)) {
                let tokens = getTokens(value).filter((token) => token.length >= this.minTokenLength);
                for (let token of tokens) {
                    let primaryKeys = this.getPrimaryKeysFromToken.get(token);
                    if (is.absent(primaryKeys)) {
                        primaryKeys = new Set();
                        this.getPrimaryKeysFromToken.set(token, primaryKeys);
                    }
                    let primaryKey = this.getPrimaryKey(record);
                    primaryKeys.add(primaryKey);
                }
            }
        }
        lookup(query) {
            let tokens = getTokens(query).filter((token) => token.length >= this.minTokenLength);
            let primaryKeySets = tokens.map((token) => {
                return this.getPrimaryKeysFromToken.get(token);
            }).filter(is.present);
            let map = new Map();
            for (let primaryKeys of primaryKeySets) {
                for (let primaryKey of primaryKeys) {
                    let rank = map.get(primaryKey) ?? (0 - tokens.length);
                    map.set(primaryKey, rank + 2);
                }
            }
            return Array.from(map.entries())
                .filter((entry) => entry[1] >= 0)
                .sort(sorters.NumericSort.decreasing((entry) => entry[1]))
                .map((entry) => ({
                id: entry[0],
                rank: entry[1]
            }));
        }
        remove(record) {
            for (let value of this.getIndexedValues(record)) {
                let tokens = getTokens(value);
                for (let token of tokens) {
                    let primaryKeys = this.getPrimaryKeysFromToken.get(token);
                    if (is.present(primaryKeys)) {
                        let primaryKey = this.getPrimaryKey(record);
                        primaryKeys.delete(primaryKey);
                        if (primaryKeys.size === 0) {
                            this.getPrimaryKeysFromToken.delete(token);
                        }
                    }
                }
            }
        }
        update(last, next) {
            this.remove(last);
            this.insert(next);
        }
        static fromIndex(records, getIndexedValues, minTokenLength = 0) {
            let index = new SearchIndex((key) => records.lookup(key), (record) => records.keyof(record), getIndexedValues, minTokenLength);
            records.on("insert", (event) => {
                index.insert(event.next);
            });
            records.on("remove", (event) => {
                index.remove(event.last);
            });
            records.on("update", (event) => {
                index.update(event.last, event.next);
            });
            return index;
        }
        static fromTable(records, getIndexedValues, minTokenLength = 0) {
            let index = new SearchIndex((key) => records.lookup(key), (record) => records.keyof(record), getIndexedValues, minTokenLength);
            for (let record of records) {
                index.insert(record);
            }
            records.on("insert", (event) => {
                index.insert(event.next);
            });
            records.on("remove", (event) => {
                index.remove(event.last);
            });
            records.on("update", (event) => {
                index.update(event.last, event.next);
            });
            return index;
        }
    }
    exports.SearchIndex = SearchIndex;
    ;
});
define("build/jsondb/index", ["require", "exports", "build/jsondb/indices", "build/jsondb/sorters", "build/jsondb/indices", "build/jsondb/indices", "build/jsondb/indices", "build/jsondb/sorters", "build/jsondb/sorters", "build/jsondb/sorters", "build/jsondb/sorters"], function (require, exports, indices, sorters, indices_1, indices_2, indices_3, sorters_1, sorters_2, sorters_3, sorters_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sorters = exports.indices = void 0;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NumericSort = exports.LexicalSort = exports.CustomSort = exports.CombinedSort = exports.SearchIndex = exports.RecordIndex = exports.CollectionIndex = exports.sorters = exports.indices = void 0;
    exports.indices = indices;
    exports.sorters = sorters;
    Object.defineProperty(exports, "CollectionIndex", { enumerable: true, get: function () { return indices_1.CollectionIndex; } });
    Object.defineProperty(exports, "RecordIndex", { enumerable: true, get: function () { return indices_2.RecordIndex; } });
    Object.defineProperty(exports, "SearchIndex", { enumerable: true, get: function () { return indices_3.SearchIndex; } });
    Object.defineProperty(exports, "CombinedSort", { enumerable: true, get: function () { return sorters_1.CombinedSort; } });
    Object.defineProperty(exports, "CustomSort", { enumerable: true, get: function () { return sorters_2.CustomSort; } });
    Object.defineProperty(exports, "LexicalSort", { enumerable: true, get: function () { return sorters_3.LexicalSort; } });
    Object.defineProperty(exports, "NumericSort", { enumerable: true, get: function () { return sorters_4.NumericSort; } });
});
define("build/database/probes/readers", ["require", "exports", "fs"], function (require, exports, libfs) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Binary = void 0;
    class Binary {
        constructor(fd) {
            this.fd = fd;
            this.offset = 0;
        }
        read(buffer) {
            let bytes = libfs.readSync(this.fd, buffer, 0, buffer.length, this.offset);
            if (bytes !== buffer.length) {
                throw `Expected to read ${buffer.length} bytes but read ${bytes}!`;
            }
            this.offset += bytes;
            return buffer;
        }
        skip(length) {
            this.offset += length;
        }
        newContext(context) {
            let offset = this.offset;
            try {
                return context((buffer) => this.read(buffer), (length) => this.skip(length));
            }
            catch (error) {
                this.offset = offset;
                throw error;
            }
        }
    }
    exports.Binary = Binary;
    ;
});
define("build/database/probes/jpeg", ["require", "exports", "build/database/probes/readers"], function (require, exports, readers) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.probe = void 0;
    var Markers;
    (function (Markers) {
        Markers[Markers["START_OF_IMAGE"] = 65496] = "START_OF_IMAGE";
        Markers[Markers["END_OF_IMAGE"] = 65497] = "END_OF_IMAGE";
        Markers[Markers["APPLICATION_0"] = 65504] = "APPLICATION_0";
        Markers[Markers["START_OF_SCAN"] = 65498] = "START_OF_SCAN";
        Markers[Markers["START_OF_FRAME_0"] = 65472] = "START_OF_FRAME_0";
        Markers[Markers["DEFINE_QUANTIZATION_TABLE"] = 65499] = "DEFINE_QUANTIZATION_TABLE";
        Markers[Markers["DEFINE_HUFFMAN_TABLE"] = 65476] = "DEFINE_HUFFMAN_TABLE";
    })(Markers || (Markers = {}));
    function parseStartOfImage(data) {
        return {};
    }
    function parseApplication0(data) {
        let offset = 0;
        let identifier = data.slice(offset, 5);
        offset += 5;
        if (identifier.toString() !== "JFIF\0") {
            throw `Expected a JFIF tag!`;
        }
        let major = data.readUInt8(offset);
        offset += 1;
        let minor = data.readUInt8(offset);
        offset += 1;
        let units = data.readUInt8(offset);
        offset += 1;
        if ((units !== 0) && (units !== 1) && (units !== 2)) {
            throw `Expected a valid density unit!`;
        }
        let x = data.readUInt16BE(offset);
        offset += 2;
        if (x === 0) {
            throw `Expected a non-zero horisontal resolution!`;
        }
        let y = data.readUInt16BE(offset);
        offset += 2;
        if (y === 0) {
            throw `Expected a non-zero vertical resolution!`;
        }
        let w = data.readUInt8(offset);
        offset += 1;
        let h = data.readUInt8(offset);
        offset += 1;
        let preview = data.slice(offset, offset + w * h * 3);
        offset += w * h * 3;
        if (preview.length !== w * h * 3) {
            throw `Expected a valid thumbnail!`;
        }
        return {
            major,
            minor,
            units,
            x,
            y,
            w,
            h,
            preview
        };
    }
    function parseStartOfFrame0(data) {
        let offset = 0;
        let precision = data.readUInt8(offset);
        offset += 1;
        let height = data.readUInt16BE(offset);
        offset += 2;
        let width = data.readUInt16BE(offset);
        offset += 2;
        let component_count = data.readUInt8(offset);
        offset += 1;
        let components = [...Array(component_count).keys()].map(() => {
            let id = data.readUInt8(offset);
            offset += 1;
            let sampling_factors = data.readUInt8(offset);
            offset += 1;
            let quantization_table = data.readUInt8(offset);
            offset += 1;
            return {
                id,
                sampling_factors,
                quantization_table
            };
        });
        return {
            precision,
            height,
            width,
            component_count,
            components
        };
    }
    function probe(fd) {
        let reader = new readers.Binary(fd);
        return reader.newContext((read, skip) => {
            let marker = Buffer.alloc(2);
            let length = Buffer.alloc(2);
            read(marker);
            if (marker.readUInt16BE() !== Markers.START_OF_IMAGE) {
                throw `Expected SOI marker!`;
            }
            parseStartOfImage(Buffer.alloc(0));
            read(marker);
            if (marker.readUInt16BE() !== Markers.APPLICATION_0) {
                throw `Expected APP0 marker!`;
            }
            read(length);
            parseApplication0(read(Buffer.alloc(length.readUInt16BE() - 2)));
            while (true) {
                read(marker);
                read(length);
                if (marker.readUInt16BE() === Markers.START_OF_FRAME_0) {
                    let sof = parseStartOfFrame0(read(Buffer.alloc(length.readUInt16BE() - 2)));
                    let result = {
                        resources: [{
                                type: "image",
                                width: sof.width,
                                height: sof.height
                            }]
                    };
                    return result;
                }
                else {
                    skip(length.readUInt16BE() - 2);
                }
            }
        });
    }
    exports.probe = probe;
    ;
});
define("build/database/probes/schema", ["require", "exports", "node_modules/@joelek/ts-autoguard/build/autoguard-lib/index"], function (require, exports, ts_autoguard_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.Probe = exports.Resource = exports.VideoResource = exports.SubtitleResource = exports.MetadataResource = exports.ImageResource = exports.AudioResource = exports.Metadata = exports.TrackMetadata = exports.MovieMetadata = exports.EpisodeMetadata = void 0;
    exports.EpisodeMetadata = ts_autoguard_1.guards.Object.of({
        "type": ts_autoguard_1.guards.StringLiteral.of("episode"),
        "title": ts_autoguard_1.guards.String,
        "season": ts_autoguard_1.guards.Number,
        "episode": ts_autoguard_1.guards.Number,
        "year": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.Number),
        "summary": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.String),
        "show": ts_autoguard_1.guards.Object.of({
            "title": ts_autoguard_1.guards.String,
            "summary": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.String),
            "genres": ts_autoguard_1.guards.Array.of(ts_autoguard_1.guards.String),
            "actors": ts_autoguard_1.guards.Array.of(ts_autoguard_1.guards.String)
        })
    });
    exports.MovieMetadata = ts_autoguard_1.guards.Object.of({
        "type": ts_autoguard_1.guards.StringLiteral.of("movie"),
        "title": ts_autoguard_1.guards.String,
        "year": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.Number),
        "summary": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.String),
        "genres": ts_autoguard_1.guards.Array.of(ts_autoguard_1.guards.String),
        "actors": ts_autoguard_1.guards.Array.of(ts_autoguard_1.guards.String)
    });
    exports.TrackMetadata = ts_autoguard_1.guards.Object.of({
        "type": ts_autoguard_1.guards.StringLiteral.of("track"),
        "title": ts_autoguard_1.guards.String,
        "disc": ts_autoguard_1.guards.Number,
        "track": ts_autoguard_1.guards.Number,
        "album": ts_autoguard_1.guards.Object.of({
            "title": ts_autoguard_1.guards.String,
            "year": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.Number),
            "artists": ts_autoguard_1.guards.Array.of(ts_autoguard_1.guards.Object.of({
                "title": ts_autoguard_1.guards.String
            }))
        }),
        "artists": ts_autoguard_1.guards.Array.of(ts_autoguard_1.guards.Object.of({
            "title": ts_autoguard_1.guards.String
        }))
    });
    exports.Metadata = ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Reference.of(() => exports.EpisodeMetadata), ts_autoguard_1.guards.Reference.of(() => exports.MovieMetadata), ts_autoguard_1.guards.Reference.of(() => exports.TrackMetadata));
    exports.AudioResource = ts_autoguard_1.guards.Object.of({
        "type": ts_autoguard_1.guards.StringLiteral.of("audio"),
        "duration_ms": ts_autoguard_1.guards.Number
    });
    exports.ImageResource = ts_autoguard_1.guards.Object.of({
        "type": ts_autoguard_1.guards.StringLiteral.of("image"),
        "width": ts_autoguard_1.guards.Number,
        "height": ts_autoguard_1.guards.Number
    });
    exports.MetadataResource = ts_autoguard_1.guards.Object.of({
        "type": ts_autoguard_1.guards.StringLiteral.of("metadata")
    });
    exports.SubtitleResource = ts_autoguard_1.guards.Object.of({
        "type": ts_autoguard_1.guards.StringLiteral.of("subtitle"),
        "duration_ms": ts_autoguard_1.guards.Number,
        "language": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.String),
        "cues": ts_autoguard_1.guards.Array.of(ts_autoguard_1.guards.Object.of({
            "start_ms": ts_autoguard_1.guards.Number,
            "duration_ms": ts_autoguard_1.guards.Number,
            "lines": ts_autoguard_1.guards.Array.of(ts_autoguard_1.guards.String)
        }))
    });
    exports.VideoResource = ts_autoguard_1.guards.Object.of({
        "type": ts_autoguard_1.guards.StringLiteral.of("video"),
        "duration_ms": ts_autoguard_1.guards.Number,
        "width": ts_autoguard_1.guards.Number,
        "height": ts_autoguard_1.guards.Number
    });
    exports.Resource = ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Reference.of(() => exports.AudioResource), ts_autoguard_1.guards.Reference.of(() => exports.ImageResource), ts_autoguard_1.guards.Reference.of(() => exports.MetadataResource), ts_autoguard_1.guards.Reference.of(() => exports.SubtitleResource), ts_autoguard_1.guards.Reference.of(() => exports.VideoResource));
    exports.Probe = ts_autoguard_1.guards.Object.of({
        "metadata": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.Reference.of(() => exports.Metadata)),
        "resources": ts_autoguard_1.guards.Array.of(ts_autoguard_1.guards.Reference.of(() => exports.Resource))
    });
    exports.Autoguard = {
        "EpisodeMetadata": exports.EpisodeMetadata,
        "MovieMetadata": exports.MovieMetadata,
        "TrackMetadata": exports.TrackMetadata,
        "Metadata": exports.Metadata,
        "AudioResource": exports.AudioResource,
        "ImageResource": exports.ImageResource,
        "MetadataResource": exports.MetadataResource,
        "SubtitleResource": exports.SubtitleResource,
        "VideoResource": exports.VideoResource,
        "Resource": exports.Resource,
        "Probe": exports.Probe
    };
});
define("build/database/probes/json", ["require", "exports", "fs", "build/database/probes/schema"], function (require, exports, libfs, schema) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.probe = void 0;
    function probe(fd) {
        let result = {
            resources: [
                {
                    type: "metadata"
                }
            ]
        };
        let buffer = libfs.readFileSync(fd);
        let json = JSON.parse(buffer.toString());
        if (schema.Metadata.is(json)) {
            result.metadata = json;
        }
        return result;
    }
    exports.probe = probe;
    ;
});
define("build/database/probes/mp3", ["require", "exports", "build/is", "build/database/probes/readers"], function (require, exports, is, readers) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.probe = void 0;
    function decodeSyncSafeInteger(buffer) {
        let a = buffer.readUInt8(0);
        let b = buffer.readUInt8(1);
        let c = buffer.readUInt8(2);
        let d = buffer.readUInt8(3);
        return ((a & 0x7F) << 21) | ((b & 0x7F) << 14) | ((c & 0x7F) << 7) | ((d & 0x7F) << 0);
    }
    function parseID3v2Header(reader) {
        return reader.newContext((read, skip) => {
            let buffer = Buffer.alloc(10);
            read(buffer);
            if (buffer.slice(0, 5).toString("binary") !== "ID3\x04\x00") {
                throw `Expected an ID3v2 tag!`;
            }
            let length = decodeSyncSafeInteger(buffer.slice(6, 6 + 4));
            let body = Buffer.alloc(length);
            read(body);
            let tags = {};
            let offset = 0;
            while (offset < body.length) {
                let type = body.slice(offset, offset + 4).toString("binary");
                let length = decodeSyncSafeInteger(body.slice(offset + 4, offset + 4 + 4));
                let flags = body.slice(offset + 8, offset + 8 + 2);
                let data = body.slice(offset + 10, offset + 10 + length);
                offset += 10 + length;
                if (type === "\0\0\0\0") {
                    break;
                }
                else if (type === "TIT2") {
                    tags.title = data.slice(1, -1).toString();
                }
                else if (type === "TALB") {
                    tags.album = data.slice(1, -1).toString();
                }
                else if (type === "TDRC") {
                    let string = data.slice(1, -1).toString();
                    let parts = /^([0-9]+)$/.exec(string);
                    if (is.present(parts)) {
                        tags.year = parseInt(parts[1]);
                    }
                }
                else if (type === "TRCK") {
                    let string = data.slice(1, -1).toString();
                    let parts = /^([0-9]+)(?:\/([0-9]+))?$/.exec(string);
                    if (is.present(parts)) {
                        tags.track_number = parseInt(parts[1]);
                    }
                }
                else if (type === "TPOS") {
                    let string = data.slice(1, -1).toString();
                    let parts = /^([0-9]+)(?:\/([0-9]+))?$/.exec(string);
                    if (is.present(parts)) {
                        tags.disc_number = parseInt(parts[1]);
                    }
                }
                else if (type === "TPE1") {
                    tags.artist = data.slice(1, -1).toString();
                }
                else if (type === "TPE2") {
                    tags.album_artist = data.slice(1, -1).toString();
                }
                else if (type === "TXXX") {
                    let string = data.slice(1, -1).toString();
                    let parts = /^ALBUM ARTIST\0(.+)$/.exec(string);
                    if (is.present(parts)) {
                        tags.album_artist = parts[1];
                    }
                }
            }
            return tags;
        });
    }
    var Version;
    (function (Version) {
        Version[Version["V2_5"] = 0] = "V2_5";
        Version[Version["RESERVED"] = 1] = "RESERVED";
        Version[Version["V2"] = 2] = "V2";
        Version[Version["V1"] = 3] = "V1";
    })(Version || (Version = {}));
    ;
    var Layer;
    (function (Layer) {
        Layer[Layer["RESERVED"] = 0] = "RESERVED";
        Layer[Layer["LAYER_3"] = 1] = "LAYER_3";
        Layer[Layer["LAYER_2"] = 2] = "LAYER_2";
        Layer[Layer["LAYER_1"] = 3] = "LAYER_1";
    })(Layer || (Layer = {}));
    ;
    const KILOBITS_PER_SECOND = [
        0,
        32,
        40,
        48,
        56,
        64,
        80,
        96,
        112,
        128,
        160,
        192,
        224,
        256,
        320,
        0
    ];
    const SAMPLES_PER_SECOND = [
        44100,
        48000,
        32000,
        0
    ];
    function parseXingHeader(reader) {
        return reader.newContext((read, skip) => {
            let buffer = Buffer.alloc(4);
            read(buffer);
            let sync = ((buffer[0] & 0xFF) << 3) | ((buffer[1] & 0xE0) >> 5);
            let version = ((buffer[1] & 0x18) >> 3);
            let layer = ((buffer[1] & 0x06) >> 1);
            let skip_crc = ((buffer[1] & 0x01) >> 0);
            let bitrate = ((buffer[2] & 0xF0) >> 4);
            let sample_rate = ((buffer[2] & 0x0C) >> 2);
            let padded = ((buffer[2] & 0x02) >> 1);
            let application_private = ((buffer[2] & 0x01) >> 0);
            let channels = ((buffer[3] & 0xC0) >> 6);
            let mode_extension = ((buffer[3] & 0x30) >> 4);
            let copyrighted = ((buffer[3] & 0x08) >> 3);
            let original = ((buffer[3] & 0x04) >> 2);
            let emphasis = ((buffer[3] & 0x03) >> 0);
            if (sync === 0x07FF && version === Version.V1 && layer === Layer.LAYER_3) {
                let samples_per_frame = 1152;
                let slots = Math.floor(samples_per_frame * KILOBITS_PER_SECOND[bitrate] * 1000 / 8 / SAMPLES_PER_SECOND[sample_rate]);
                if (padded) {
                    slots += 1;
                }
                let bytes = slots * 1;
                let body = Buffer.alloc(bytes - 4);
                read(body);
                let zeroes = body.slice(0, 0 + 32);
                let xing = body.slice(32, 32 + 4);
                if (xing.toString("binary") === "Xing" || xing.toString() === "Info") {
                    let flags = body.slice(36, 36 + 4);
                    let has_quality = ((flags[3] & 0x08) >> 3);
                    let has_toc = ((flags[3] & 0x04) >> 2);
                    let has_bytes = ((flags[3] & 0x02) >> 1);
                    let has_frames = ((flags[3] & 0x01) >> 0);
                    let offset = 40;
                    if (has_frames) {
                        let num_frames = body.readUInt32BE(offset);
                        offset += 4;
                        let duration_ms = Math.ceil((num_frames * samples_per_frame / SAMPLES_PER_SECOND[sample_rate]) * 1000);
                        return duration_ms;
                    }
                    if (has_bytes) {
                        let num_bytes = body.readUInt32BE(offset);
                        offset += 4;
                    }
                    if (has_toc) {
                        offset += 100;
                    }
                    if (has_quality) {
                        let quality = body.readUInt32BE(offset);
                        offset += 4;
                    }
                }
            }
            throw `Expected a Xing header!`;
        });
    }
    function probe(fd) {
        let reader = new readers.Binary(fd);
        let tags = parseID3v2Header(reader);
        console.log(tags);
        let duration_ms = parseXingHeader(reader);
        let result = {
            resources: [
                {
                    type: "audio",
                    duration_ms: duration_ms
                }
            ]
        };
        if (is.present(tags.title) && is.present(tags.disc_number) && is.present(tags.track_number) && is.present(tags.album)) {
            let metadata = {
                type: "track",
                title: tags.title,
                disc: tags.disc_number,
                track: tags.track_number,
                album: {
                    title: tags.album,
                    year: tags.year,
                    artists: is.absent(tags.album_artist) ? [] : tags.album_artist.split(";").map((artist) => artist.trim()).map((artist) => ({
                        title: artist
                    }))
                },
                artists: is.absent(tags.artist) ? [] : tags.artist.split(";").map((artist) => artist.trim()).map((artist) => ({
                    title: artist
                }))
            };
            result.metadata = metadata;
        }
        return result;
    }
    exports.probe = probe;
    ;
});
define("build/database/probes/mp4", ["require", "exports", "fs", "build/is"], function (require, exports, libfs, is) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.probe = void 0;
    class Atom {
        constructor(fd, type, body) {
            this.fd = fd;
            this.type = type;
            this.body = body;
        }
        getAllChildren() {
            let scope = {
                ...this.body
            };
            let atoms = new Array();
            while (scope.length > 0) {
                let atom = Atom.parse(this.fd, scope);
                // The "udta" atom begins with a mandatory zero-terminated list.
                if (this.type === "udta") {
                    atom.body.offset += 4;
                    atom.body.length -= 4;
                }
                atoms.push(atom);
                scope.offset = atom.body.offset + atom.body.length;
                scope.length = this.body.offset + this.body.length - scope.offset;
            }
            return atoms;
        }
        getChild(type) {
            let children = this.getChildren(type);
            if (children.length !== 1) {
                throw `Expected exactly one child!`;
            }
            return children[0];
        }
        getChildren(type) {
            return this.getAllChildren().filter((atom) => {
                return atom.type === type;
            });
        }
        readBody() {
            let buffer = Buffer.alloc(this.body.length);
            if (libfs.readSync(this.fd, buffer, 0, buffer.length, this.body.offset) !== buffer.length) {
                throw `Expected to read exactly ${buffer.length} bytes!`;
            }
            return buffer;
        }
        static parse(fd, scope) {
            let offset = scope.offset;
            let buffer = Buffer.alloc(8);
            if (libfs.readSync(fd, buffer, 0, buffer.length, offset) !== buffer.length) {
                throw `Expected to read exactly ${buffer.length} bytes!`;
            }
            offset += buffer.length;
            let length = buffer.readUInt32BE(0);
            let type = buffer.slice(4, 4 + 4).toString("binary");
            if (length === 0) {
                length = scope.length - offset;
            }
            else if (length === 1) {
                if (libfs.readSync(fd, buffer, 0, buffer.length, offset) !== buffer.length) {
                    throw `Expected to read exactly ${buffer.length} bytes!`;
                }
                offset += buffer.length;
                length = Number(buffer.readBigUInt64BE(0));
            }
            if (length < 8) {
                throw `Expected a length of at least 8 bytes, got ${length}!`;
            }
            else if (length > scope.length) {
                throw `Expected a length of at most ${scope.length} bytes, got ${length}!`;
            }
            length -= 8;
            return new Atom(fd, type, {
                offset,
                length
            });
        }
    }
    ;
    function probe(fd) {
        let atom = new Atom(fd, "root", {
            offset: 0,
            length: libfs.fstatSync(fd).size
        });
        let moov = atom.getChild("moov");
        let mvhd = moov.getChild("mvhd");
        let buffer = mvhd.readBody();
        let ts = buffer.readUInt32BE(12);
        let result = {
            resources: moov.getChildren("trak").map((trak) => {
                let tkhd = trak.getChild("tkhd");
                let buffer = tkhd.readBody();
                let duration_ts = buffer.readUInt32BE(20);
                let width = buffer.readUInt16BE(76);
                let height = buffer.readUInt16BE(80);
                let duration_ms = Math.ceil(duration_ts / ts * 1000);
                if (duration_ms > 0 && width > 0 && height > 0) {
                    return {
                        type: "video",
                        duration_ms,
                        width,
                        height
                    };
                }
                else if (duration_ms > 0) {
                    return {
                        type: "audio",
                        duration_ms
                    };
                }
                else {
                    return {
                        type: "metadata"
                    };
                }
            })
        };
        try {
            let udta = moov.getChild("udta");
            let meta = udta.getChild("meta");
            let ilst = meta.getChild("ilst");
            let tags = {};
            try {
                let buffer = ilst.getChild("tvsh").getChild("data").readBody();
                tags.show = buffer.slice(8).toString();
            }
            catch (error) { }
            try {
                let buffer = ilst.getChild("tven").getChild("data").readBody();
                tags.episode = buffer.slice(8).toString();
            }
            catch (error) { }
            try {
                let buffer = ilst.getChild("tves").getChild("data").readBody();
                tags.episode_number = buffer.readUInt32BE(8);
            }
            catch (error) { }
            try {
                let buffer = ilst.getChild("tvsn").getChild("data").readBody();
                tags.season_number = buffer.readUInt32BE(8);
            }
            catch (error) { }
            try {
                let buffer = ilst.getChild("\u00A9nam").getChild("data").readBody();
                tags.title = buffer.slice(8).toString();
            }
            catch (error) { }
            try {
                let buffer = ilst.getChild("\u00A9day").getChild("data").readBody();
                tags.year = Number.parseInt(buffer.slice(8).toString());
            }
            catch (error) { }
            try {
                let buffer = ilst.getChild("\u00A9cmt").getChild("data").readBody();
                tags.comment = buffer.slice(8).toString();
            }
            catch (error) { }
            try {
                let buffer = ilst.getChild("\u00A9ART").getChild("data").readBody();
                tags.artist = buffer.slice(8).toString();
            }
            catch (error) { }
            try {
                let buffer = ilst.getChild("\u00A9alb").getChild("data").readBody();
                tags.album = buffer.slice(8).toString();
            }
            catch (error) { }
            try {
                let buffer = ilst.getChild("aART").getChild("data").readBody();
                tags.album_artist = buffer.slice(8).toString();
            }
            catch (error) { }
            try {
                let buffer = ilst.getChild("trkn").getChild("data").readBody();
                tags.track_number = buffer.readUInt32BE(8);
            }
            catch (error) { }
            try {
                let buffer = ilst.getChild("disk").getChild("data").readBody();
                tags.disc_number = buffer.readUInt32BE(8);
            }
            catch (error) { }
            if (result.resources.find((resource) => resource.type === "video")) {
                if (is.present(tags.episode) && is.present(tags.season_number) && is.present(tags.episode_number) && is.present(tags.show)) {
                    let metadata = {
                        type: "episode",
                        title: tags.episode,
                        season: tags.season_number,
                        episode: tags.episode_number,
                        year: tags.year,
                        summary: tags.comment,
                        show: {
                            title: tags.show,
                            summary: undefined,
                            genres: [],
                            actors: []
                        }
                    };
                    result.metadata = metadata;
                }
                else if (is.present(tags.title)) {
                    let metadata = {
                        type: "movie",
                        title: tags.title,
                        year: tags.year,
                        summary: tags.comment,
                        genres: [],
                        actors: []
                    };
                    result.metadata = metadata;
                }
            }
            else if (result.resources.find((resource) => resource.type === "audio")) {
                if (is.present(tags.title) && is.present(tags.disc_number) && is.present(tags.track_number) && is.present(tags.album)) {
                    let metadata = {
                        type: "track",
                        title: tags.title,
                        disc: tags.disc_number,
                        track: tags.track_number,
                        album: {
                            title: tags.album,
                            year: tags.year,
                            artists: is.absent(tags.album_artist) ? [] : tags.album_artist.split(";").map((artist) => artist.trim()).map((artist) => ({
                                title: artist
                            }))
                        },
                        artists: is.absent(tags.artist) ? [] : tags.artist.split(";").map((artist) => artist.trim()).map((artist) => ({
                            title: artist
                        }))
                    };
                    result.metadata = metadata;
                }
            }
        }
        catch (error) { }
        return result;
    }
    exports.probe = probe;
    ;
});
define("build/database/vtt/reader", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Reader = void 0;
    function isString(value) {
        return value != null && value.constructor === String;
    }
    class Reader {
        constructor(string) {
            this.string = string;
            this.offset = 0;
            this.length = string.length;
        }
        done() {
            return (this.offset === this.length);
        }
        line() {
            let string = "";
            while (!this.done()) {
                let one = this.string[this.offset];
                this.offset += 1;
                if (false) {
                }
                else if (one === "\r") {
                    if (!this.done()) {
                        let two = this.string[this.offset];
                        if (two === "\n") {
                            this.offset += 1;
                        }
                    }
                    break;
                }
                else if (one === "\n") {
                    if (!this.done()) {
                        let two = this.string[this.offset];
                        if (two === "\r") {
                            this.offset += 1;
                        }
                    }
                    break;
                }
                else {
                    string += one;
                }
            }
            return string;
        }
        keep(characters) {
            let string = "";
            while (!this.done()) {
                if (characters.indexOf(this.peek(1)) >= 0) {
                    break;
                }
                string += this.read(1);
            }
            return string;
        }
        peek(how) {
            let length = isString(how) ? how.length : how;
            let min = Math.min(this.offset, this.offset + length);
            let max = Math.max(this.offset, this.offset + length);
            if ((min < 0) || (min >= this.length) || (max < 0) || (max > this.length)) {
                throw "Unable to read between offsets " + min + " and " + max + " because length is " + this.length + "!";
            }
            let string = this.string.substring(min, max);
            if (isString(how)) {
                if (string !== how) {
                    throw "Expected \"" + how + "\" but read \"" + string + "\"!";
                }
            }
            return string;
        }
        read(how) {
            let string = this.peek(how);
            this.offset += string.length;
            return string;
        }
        seek(offset) {
            if ((offset < 0) || (offset >= this.length)) {
                throw "Unable to seek to offset " + offset + " because length is " + this.length + "!";
            }
            this.offset = offset;
        }
        skip(characters) {
            let string = "";
            while (!this.done()) {
                if (characters.indexOf(this.peek(1)) < 0) {
                    break;
                }
                string += this.read(1);
            }
            return string;
        }
        tell() {
            return this.offset;
        }
    }
    exports.Reader = Reader;
});
define("build/database/vtt/vtt", ["require", "exports", "build/database/vtt/reader"], function (require, exports, libreader) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encode = exports.decode = void 0;
    const DQ = "\"";
    function readString(reader, expected) {
        let string = reader.read(expected.length);
        if (string !== expected) {
            throw "Expected " + DQ + expected + DQ + " but read " + DQ + string + DQ + "!";
        }
    }
    function readBlank(reader) {
        let line = reader.line();
        if (line !== "") {
            throw "Expected a blank line but read " + DQ + line + DQ + "!";
        }
    }
    function readTimecode(reader) {
        let parts = null;
        if ((parts = /^([0-9][0-9])[:]([0-5][0-9])[:]([0-5][0-9])[.]([0-9][0-9][0-9])$/.exec(reader.peek(12))) != null) {
            reader.read(12);
            let hours = parseInt(parts[1], 10);
            let minutes = parseInt(parts[2], 10);
            let seconds = parseInt(parts[3], 10);
            let milliseconds = parseInt(parts[4], 10);
            return ((hours * 60 + minutes) * 60 + seconds) * 1000 + milliseconds;
        }
        if ((parts = /^([0-5][0-9])[:]([0-5][0-9])[.]([0-9][0-9][0-9])$/.exec(reader.peek(9))) != null) {
            reader.read(9);
            let hours = 0;
            let minutes = parseInt(parts[1], 10);
            let seconds = parseInt(parts[2], 10);
            let milliseconds = parseInt(parts[3], 10);
            return ((hours * 60 + minutes) * 60 + seconds) * 1000 + milliseconds;
        }
        console.log("Expected a valid timecode!");
        return 0;
    }
    function serializeTimecode(ms) {
        let s = Math.floor(ms / 1000);
        ms -= (s * 1000);
        let m = Math.floor(s / 60);
        s -= (m * 60);
        let h = Math.floor(m / 60);
        m -= (h * 60);
        let tch = `00${h}`.slice(-2);
        let tcm = `00${m}`.slice(-2);
        let tcs = `00${s}`.slice(-2);
        let tcms = `000${ms}`.slice(-3);
        return `${tch}:${tcm}:${tcs}.${tcms}`;
    }
    function readCue(reader) {
        let start_ms = readTimecode(reader);
        readString(reader, " --> ");
        let end_ms = readTimecode(reader);
        readBlank(reader);
        let duration_ms = end_ms - start_ms;
        if (duration_ms < 0) {
            console.log("Expected a positive duration but read " + start_ms + " and " + end_ms + "!");
        }
        let lines = new Array();
        while (true) {
            let line = reader.line();
            if (line === "") {
                break;
            }
            lines.push(line);
        }
        return {
            start_ms,
            duration_ms,
            lines
        };
    }
    function serializeCue(cue, options) {
        let lines = new Array();
        lines.push(serializeTimecode(cue.start_ms) + " --> " + serializeTimecode(cue.start_ms + cue.duration_ms));
        lines.push(...cue.lines);
        lines.push("");
        return lines.join(options.eol);
    }
    function readBody(reader) {
        let cues = new Array();
        while (!reader.done()) {
            let cue = readCue(reader);
            cues.push(cue);
        }
        cues = cues.sort((one, two) => one.start_ms - two.start_ms);
        return {
            cues
        };
    }
    function serializeBody(body, options) {
        let lines = new Array();
        for (let cue of body.cues) {
            lines.push(serializeCue(cue, options));
        }
        return lines.join(options.eol);
    }
    function readHead(reader) {
        readString(reader, "WEBVTT");
        let metadata = reader.line();
        readBlank(reader);
        return {
            metadata
        };
    }
    function serializeHead(head, options) {
        let lines = new Array();
        lines.push("WEBVTT " + head.metadata);
        lines.push("");
        return lines.join(options.eol);
    }
    function readTrack(reader) {
        let head = readHead(reader);
        let body = readBody(reader);
        return {
            head,
            body
        };
    }
    function serializeTrack(track, options) {
        let lines = new Array();
        lines.push(serializeHead(track.head, options));
        lines.push(serializeBody(track.body, options));
        return lines.join(options.eol);
    }
    function decode(string) {
        let reader = new libreader.Reader(string);
        return readTrack(reader);
    }
    exports.decode = decode;
    function encode(track) {
        return serializeTrack(track, {
            eol: "\r\n"
        });
    }
    exports.encode = encode;
});
define("build/database/probes/vtt", ["require", "exports", "node_modules/@joelek/ts-autoguard/build/autoguard-lib/index", "fs", "build/is", "build/database/vtt/vtt"], function (require, exports, autoguard, libfs, is, vtt) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.probe = void 0;
    function probe(fd) {
        let result = {
            resources: []
        };
        let buffer = libfs.readFileSync(fd);
        let track = vtt.decode(buffer.toString());
        let cues = track.body.cues;
        let cue = cues.length > 0 ? cues[cues.length - 1] : undefined;
        let duration_ms = is.present(cue) ? cue.start_ms + cue.duration_ms : 0;
        let language;
        try {
            let json = JSON.parse(track.head.metadata);
            language = autoguard.guards.String.as(json.language);
        }
        catch (error) { }
        result.resources.push({
            type: "subtitle",
            duration_ms,
            language,
            cues
        });
        return result;
    }
    exports.probe = probe;
    ;
});
define("build/database/probes/index", ["require", "exports", "build/database/probes/jpeg", "build/database/probes/json", "build/database/probes/mp3", "build/database/probes/mp4", "build/database/probes/schema", "build/database/probes/vtt"], function (require, exports, jpeg, json, mp3, mp4, schema, vtt) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.vtt = exports.schema = exports.mp4 = exports.mp3 = exports.json = exports.jpeg = void 0;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.vtt = exports.schema = exports.mp4 = exports.mp3 = exports.json = exports.jpeg = void 0;
    exports.jpeg = jpeg;
    exports.json = json;
    exports.mp3 = mp3;
    exports.mp4 = mp4;
    exports.schema = schema;
    exports.vtt = vtt;
});
define("build/config/index", ["require", "exports", "node_modules/@joelek/ts-autoguard/build/autoguard-lib/index", "fs"], function (require, exports, ts_autoguard_1, libfs) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    const ROOT = [
        ".",
        "private",
        "config"
    ];
    const PATH = [...ROOT, "config.json"].join("/");
    let config = {
        certificate_path: [".", "private", "certs", "full_chain.pem"],
        certificate_key_path: [".", "private", "certs", "certificate_key.pem"],
        http_port: 80,
        https_port: 443,
        media_path: [".", "private", "media"],
        use_cue_index: false,
        use_demo_mode: false
    };
    try {
        let string = libfs.readFileSync(PATH, "utf-8");
        let json = JSON.parse(string);
        if (ts_autoguard_1.guards.Record.of(ts_autoguard_1.guards.Any).is(json)) {
            if (ts_autoguard_1.guards.Array.of(ts_autoguard_1.guards.String).is(json.certificate_key_path)) {
                config.certificate_key_path = json.certificate_key_path;
            }
            if (ts_autoguard_1.guards.Array.of(ts_autoguard_1.guards.String).is(json.certificate_path)) {
                config.certificate_path = json.certificate_path;
            }
            if (ts_autoguard_1.guards.Number.is(json.http_port)) {
                config.http_port = json.http_port;
            }
            if (ts_autoguard_1.guards.Number.is(json.https_port)) {
                config.https_port = json.https_port;
            }
            if (ts_autoguard_1.guards.Array.of(ts_autoguard_1.guards.String).is(json.media_path)) {
                config.media_path = json.media_path;
            }
            if (ts_autoguard_1.guards.Boolean.is(json.use_cue_index)) {
                config.use_cue_index = json.use_cue_index;
            }
            if (ts_autoguard_1.guards.Boolean.is(json.use_demo_mode)) {
                config.use_demo_mode = json.use_demo_mode;
            }
        }
    }
    catch (error) { }
    if (!libfs.existsSync(ROOT.join("/"))) {
        libfs.mkdirSync(ROOT.join("/"));
    }
    libfs.writeFileSync(PATH, JSON.stringify(config, null, "\t"));
    exports.default = config;
});
define("build/jdb2/asserts/integer", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IntegerAssert = void 0;
    class IntegerAssert {
        constructor() { }
        static atLeast(min, value) {
            this.integer(min);
            this.integer(value);
            if (value < min) {
                throw `Expected ${value} to be at least ${min}!`;
            }
        }
        static atMost(max, value) {
            this.integer(value);
            this.integer(max);
            if (value > max) {
                throw `Expected ${value} to be at most ${max}!`;
            }
        }
        static between(min, value, max) {
            this.atLeast(min, value);
            this.atMost(max, value);
        }
        static exactly(value, expected) {
            this.integer(expected);
            this.integer(value);
            if (value !== expected) {
                throw `Expected ${value} to be exactly ${expected}!`;
            }
        }
        static integer(value) {
            if (!Number.isInteger(value)) {
                throw `Expected ${value} to be an integer!`;
            }
        }
    }
    exports.IntegerAssert = IntegerAssert;
    ;
});
define("build/jdb/index", ["require", "exports", "crypto", "fs", "node_modules/@joelek/ts-autoguard/build/autoguard-lib/index", "node_modules/@joelek/ts-stdlib/build/index", "build/is", "build/jsondb/index"], function (require, exports, libcrypto, libfs, autoguard, stdlib, is, jsondb_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Index = exports.IndexRecord = exports.IndexEntry = exports.IndexHeader = exports.Table = exports.RecordIndexEntry = exports.RecordIndexHeader = exports.StreamIterable = exports.computeHash = void 0;
    function computeHash(value) {
        return libcrypto.createHash("sha256")
            .update(String(value))
            .digest("hex")
            .slice(0, 16);
    }
    exports.computeHash = computeHash;
    function* filter(iterable, predicate) {
        let index = 0;
        for (let value of iterable) {
            if (predicate(value, index++)) {
                yield value;
            }
        }
    }
    function* include(iterable, predicate) {
        let index = 0;
        for (let value of iterable) {
            if (predicate(value, index++)) {
                yield value;
            }
        }
    }
    function* map(iterable, transform) {
        let index = 0;
        for (let value of iterable) {
            yield transform(value, index++);
        }
    }
    class StreamIterable {
        constructor(values) {
            this.values = values;
        }
        *[Symbol.iterator]() {
            //yield* this.values;
            for (let value of this.values) {
                yield value;
            }
        }
        collect() {
            return Array.from(this.values);
        }
        filter(predicate) {
            return new StreamIterable(filter(this.values, predicate));
        }
        find(predicate) {
            let index = 0;
            for (let value of this.values) {
                if (predicate(value, index++)) {
                    return value;
                }
            }
        }
        include(predicate) {
            return new StreamIterable(include(this.values, predicate));
        }
        includes(predicate) {
            let index = 0;
            for (let value of this.values) {
                if (predicate(value, index++)) {
                    return true;
                }
            }
            return false;
        }
        map(transform) {
            return new StreamIterable(map(this.values, transform));
        }
        shift() {
            for (let value of this.values) {
                return value;
            }
        }
        slice(start, end) {
            let array = this.collect().slice(start, end);
            return new StreamIterable(array);
        }
        sort(comparator) {
            let array = this.collect().sort(comparator);
            return new StreamIterable(array);
        }
        unique() {
            return new StreamIterable(new Set(this.values));
        }
        static of(values) {
            return new StreamIterable(values ?? new Array());
        }
    }
    exports.StreamIterable = StreamIterable;
    ;
    function readBuffer(fd, buffer, position) {
        let bytes = libfs.readSync(fd, buffer, 0, buffer.length, position ?? null);
        if (bytes !== buffer.length) {
            throw `Expected to read ${buffer.length} bytes but read ${bytes}!`;
        }
        return buffer;
    }
    function writeBuffer(fd, buffer, position) {
        let bytes = libfs.writeSync(fd, buffer, 0, buffer.length, position ?? null);
        if (bytes !== buffer.length) {
            throw `Expected to write ${buffer.length} bytes but wrote ${bytes}!`;
        }
        return buffer;
    }
    class RecordIndexHeader {
        constructor() {
            let buffer = Buffer.alloc(16);
            buffer.write("\x23\x52\xDB\x07\xEC\x77\x30\x61", 0, "binary");
            buffer.writeUInt32BE(63, 8);
            this.buffer = buffer;
        }
        get identifier() {
            return this.buffer.slice(0, 8).toString("binary");
        }
        get chunk_size_minus_one() {
            return this.buffer.readUInt32BE(8);
        }
        set chunk_size_minus_one(value) {
            this.buffer.writeUInt32BE(value, 8);
        }
        get chunk_size() {
            return this.chunk_size_minus_one + 1;
        }
        set chunk_size(value) {
            this.chunk_size_minus_one = value - 1;
        }
        read(fd, position) {
            readBuffer(fd, this.buffer, position);
            let identifier = this.buffer.slice(0, 8).toString("binary");
            if (identifier !== this.identifier) {
                throw `Unsupported file format!`;
            }
        }
        write(fd, position) {
            writeBuffer(fd, this.buffer, position);
        }
    }
    exports.RecordIndexHeader = RecordIndexHeader;
    ;
    class RecordIndexEntry {
        constructor() {
            let buffer = Buffer.alloc(16);
            this.buffer = buffer;
        }
        get key() {
            return this.buffer.slice(0, 8).toString("hex");
        }
        set key(value) {
            if (!/^[0-9a-f]{16}$/.test(value)) {
                throw `Invalid key, ${value}!`;
            }
            this.buffer.set(Buffer.from(value, "hex"), 0);
        }
        get chunk_offset() {
            return this.buffer.readUInt32BE(8);
        }
        set chunk_offset(value) {
            this.buffer.writeUInt32BE(value, 8);
        }
        get chunk_length_minus_one() {
            return this.buffer.readUInt32BE(12);
        }
        set chunk_length_minus_one(value) {
            this.buffer.writeUInt32BE(value, 12);
        }
        get chunk_length() {
            return this.chunk_length_minus_one + 1;
        }
        set chunk_length(value) {
            this.chunk_length_minus_one = value - 1;
        }
        read(fd, position) {
            readBuffer(fd, this.buffer, position);
        }
        write(fd, position) {
            writeBuffer(fd, this.buffer, position);
        }
    }
    exports.RecordIndexEntry = RecordIndexEntry;
    ;
    class Table {
        constructor(root, table_name, guard, key_provider) {
            let directory = [...root, table_name];
            if (!libfs.existsSync(directory.join("/"))) {
                libfs.mkdirSync(directory.join("/"), { recursive: true });
            }
            let toc_filename = [...directory, "toc"];
            let toc_exists = libfs.existsSync(toc_filename.join("/"));
            let toc = libfs.openSync(toc_filename.join("/"), toc_exists ? "r+" : "w+");
            let bin_filename = [...directory, "bin"];
            let bin_exists = libfs.existsSync(bin_filename.join("/"));
            let bin = libfs.openSync(bin_filename.join("/"), bin_exists ? "r+" : "w+");
            let indexFromKey = {};
            let header = new RecordIndexHeader();
            let free_entries = new Set();
            if (toc_exists) {
                header.read(toc, 0);
                let entry_count = libfs.fstatSync(toc).size / 16 - 1;
                if (!Number.isInteger(entry_count)) {
                    throw `Expected a non-fractional number of entries!`;
                }
                let entry = new RecordIndexEntry();
                for (let index = 0; index < entry_count; index++) {
                    entry.read(toc, 16 + index * 16);
                    if (entry.key !== "0000000000000000") {
                        indexFromKey[entry.key] = index;
                    }
                    else {
                        free_entries.add(index);
                    }
                }
            }
            else {
                header.write(toc, 0);
            }
            this.toc = toc;
            this.bin = bin;
            this.header = header;
            this.indexFromKey = indexFromKey;
            this.router = new stdlib.routing.MessageRouter();
            this.guard = guard;
            this.key_provider = key_provider;
            this.cache = new Map();
            this.free_entries = free_entries;
        }
        getNumberOfEntries() {
            let entry_count = libfs.fstatSync(this.toc).size / 16 - 1;
            if (!Number.isInteger(entry_count)) {
                throw `Expected a non-fractional number of entries!`;
            }
            return entry_count;
        }
        readEntry(index, entry) {
            entry.read(this.toc, 16 + index * 16);
            return entry;
        }
        getEntryFor(chunk_length, key) {
            let entry = new RecordIndexEntry();
            for (let entry_index of this.free_entries) {
                this.readEntry(entry_index, entry);
                if (entry.chunk_length >= chunk_length || entry_index === this.getNumberOfEntries() - 1) {
                    this.free_entries.delete(entry_index);
                    entry.key = key;
                    entry.chunk_length = Math.max(entry.chunk_length, chunk_length);
                    entry.write(this.toc, 16 + entry_index * 16);
                    return entry_index;
                }
            }
            let entry_index = this.getNumberOfEntries();
            entry.chunk_offset = Math.ceil(libfs.fstatSync(this.bin).size / this.header.chunk_size);
            entry.chunk_length = chunk_length;
            entry.key = key;
            entry.write(this.toc, 16 + entry_index * 16);
            return entry_index;
        }
        getRecord(index) {
            let record = this.cache.get(index);
            if (is.present(record)) {
                this.cache.delete(index);
                this.cache.set(index, record);
                return record;
            }
            let entry = new RecordIndexEntry();
            this.readEntry(index, entry);
            if (entry.key === "0000000000000000") {
                throw `Expected ${index} to match a record!`;
            }
            let position = entry.chunk_offset * this.header.chunk_size;
            let buffer = Buffer.alloc(entry.chunk_length * this.header.chunk_size);
            readBuffer(this.bin, buffer, position);
            let end = buffer.length;
            while (end > 0) {
                if (buffer[end - 1] !== 0) {
                    break;
                }
                end -= 1;
            }
            let string = buffer.toString("utf8", 0, end);
            let json = JSON.parse(string);
            record = this.guard.as(json);
            this.cache.set(index, record);
            if (this.cache.size > 10000) {
                for (let idx of this.cache.keys()) {
                    this.cache.delete(idx);
                    break;
                }
            }
            return record;
        }
        insertOrUpdate(next) {
            let key = this.key_provider(next);
            let string = JSON.stringify(next);
            let binary = new TextEncoder().encode(string);
            let chunks = Math.max(1, Math.ceil(binary.length / this.header.chunk_size));
            let index = this.indexFromKey[key];
            if (is.present(index)) {
                let last = this.getRecord(index);
                let entry = this.readEntry(index, new RecordIndexEntry());
                if (chunks <= entry.chunk_length) {
                    let buffer = Buffer.alloc(entry.chunk_length * this.header.chunk_size);
                    buffer.set(binary, 0);
                    writeBuffer(this.bin, buffer, entry.chunk_offset * this.header.chunk_size);
                }
                else {
                    let buffer = Buffer.alloc(entry.chunk_length * this.header.chunk_size);
                    writeBuffer(this.bin, buffer, entry.chunk_offset * this.header.chunk_size);
                    delete this.indexFromKey[key];
                    entry.key = "0000000000000000";
                    entry.write(this.toc, 16 + index * 16);
                    this.free_entries.add(index);
                    index = this.getEntryFor(chunks * 2, key);
                    entry = this.readEntry(index, new RecordIndexEntry());
                    let buffer2 = Buffer.alloc(entry.chunk_length * this.header.chunk_size);
                    buffer2.set(binary, 0);
                    writeBuffer(this.bin, buffer2, entry.chunk_offset * this.header.chunk_size);
                    this.indexFromKey[key] = index;
                }
                this.cache.delete(index);
                this.cache.set(index, next);
                this.router.route("update", {
                    last: last,
                    next: next
                });
                return;
            }
            index = this.getEntryFor(chunks, key);
            let entry = this.readEntry(index, new RecordIndexEntry());
            let buffer = Buffer.alloc(entry.chunk_length * this.header.chunk_size);
            buffer.set(binary, 0);
            writeBuffer(this.bin, buffer, entry.chunk_offset * this.header.chunk_size);
            this.indexFromKey[key] = index;
            this.cache.set(index, next);
            this.router.route("insert", {
                next: next
            });
        }
        destroy() {
            libfs.closeSync(this.toc);
            libfs.closeSync(this.bin);
        }
        *[Symbol.iterator]() {
            for (let index = 0; index < this.getNumberOfEntries(); index++) {
                try {
                    yield this.getRecord(index);
                }
                catch (error) { }
            }
        }
        insert(record) {
            this.insertOrUpdate(record);
        }
        keyof(record) {
            return this.key_provider(record);
        }
        length() {
            return this.getNumberOfEntries();
        }
        lookup(key) {
            let index = this.indexFromKey[key ?? "0000000000000000"];
            if (is.present(index)) {
                let record = this.getRecord(index);
                if (this.key_provider(record) === key) {
                    return record;
                }
            }
            throw `Expected ${key} to match a record!`;
        }
        on(type, listener) {
            this.router.addObserver(type, listener);
        }
        off(type, listener) {
            this.router.addObserver(type, listener);
        }
        remove(record) {
            let key = this.key_provider(record);
            let index = this.indexFromKey[key];
            if (is.present(index)) {
                let last = this.getRecord(index);
                if (this.key_provider(last) === key) {
                    let entry = this.readEntry(index, new RecordIndexEntry());
                    let buffer = Buffer.alloc(entry.chunk_length * this.header.chunk_size);
                    let position = entry.chunk_offset * this.header.chunk_size;
                    writeBuffer(this.bin, buffer, position);
                    this.cache.delete(index);
                    delete this.indexFromKey[key];
                    entry.key = Buffer.alloc(8).toString("hex");
                    entry.write(this.toc, 16 + index * 16);
                    this.free_entries.add(index);
                    this.router.route("remove", {
                        last: last
                    });
                }
            }
        }
        update(record) {
            this.insertOrUpdate(record);
        }
    }
    exports.Table = Table;
    ;
    class IndexHeader {
        constructor() {
            let buffer = Buffer.alloc(16);
            buffer.write("\x01\xfb\x2e\x28\x8a\xa7\x98\x76", 0, "binary");
            this.buffer = buffer;
        }
        get identifier() {
            return this.buffer.slice(0, 8).toString("binary");
        }
        read(fd, position) {
            readBuffer(fd, this.buffer, position);
            let identifier = this.buffer.slice(0, 8).toString("binary");
            if (identifier !== this.identifier) {
                throw `Unsupported file format!`;
            }
        }
        write(fd, position) {
            writeBuffer(fd, this.buffer, position);
        }
    }
    exports.IndexHeader = IndexHeader;
    ;
    class IndexEntry {
        constructor() {
            let buffer = Buffer.alloc(16);
            this.buffer = buffer;
        }
        get hash() {
            return this.buffer.slice(0, 8).toString("hex");
        }
        set hash(value) {
            if (!/^[0-9a-f]{16}$/.test(value)) {
                throw `Invalid group key, ${value}!`;
            }
            this.buffer.set(Buffer.from(value, "hex"), 0);
        }
        get key() {
            return this.buffer.slice(8, 8 + 8).toString("hex");
        }
        set key(value) {
            if (!/^[0-9a-f]{16}$/.test(value)) {
                throw `Invalid key, ${value}!`;
            }
            this.buffer.set(Buffer.from(value, "hex"), 8);
        }
        get is_free() {
            return /^[0]{16}$/.test(this.buffer.toString("hex"));
        }
        set is_free(value) {
            if (value) {
                this.buffer.fill(0);
            }
        }
        read(fd, position) {
            readBuffer(fd, this.buffer, position);
        }
        write(fd, position) {
            writeBuffer(fd, this.buffer, position);
        }
    }
    exports.IndexEntry = IndexEntry;
    ;
    exports.IndexRecord = autoguard.guards.Object.of({
        id: autoguard.guards.String,
        keys: autoguard.guards.Array.of(autoguard.guards.String)
    });
    function computePosition(key, keys, lower = 0, upper = keys.length - 1) {
        let length = upper - lower + 1;
        let index = lower + Math.floor(length / 2);
        if (length > 0) {
            let compareKey = keys[index];
            if (key < compareKey) {
                return computePosition(key, keys, lower, index - 1);
            }
            if (key > compareKey) {
                return computePosition(key, keys, index + 1, upper);
            }
        }
        return index;
    }
    function insert(key, keys) {
        let position = computePosition(key, keys);
        if (keys[position] !== key) {
            keys.splice(position, 0, key);
        }
    }
    function remove(key, keys) {
        let position = computePosition(key, keys);
        if (keys[position] === key) {
            keys.splice(position, 1);
        }
    }
    class Index {
        constructor(root, index_name, getRecordFromKey, getValues, getRecordKey, getQueryTokens, maxGroupSize) {
            this.table = new Table(root, index_name, exports.IndexRecord, (record) => record.id);
            this.getRecordFromKey = getRecordFromKey;
            this.getValues = getValues;
            this.getKey = getRecordKey;
            this.getTokensFromValue = getQueryTokens;
            this.maxGroupSize = maxGroupSize;
        }
        insert(record) {
            let key = this.getKey(record);
            for (let value of this.getValues(record)) {
                for (let token of this.getTokensFromValue(value)) {
                    let hash = computeHash(token);
                    let record;
                    try {
                        record = this.table.lookup(hash);
                    }
                    catch (error) { }
                    if (is.absent(record)) {
                        record = {
                            id: hash,
                            keys: []
                        };
                    }
                    let keys = record.keys;
                    if (is.present(this.maxGroupSize) && keys.length >= this.maxGroupSize) {
                        continue;
                    }
                    let position = computePosition(key, keys);
                    if (keys[position] !== key) {
                        keys.splice(position, 0, key);
                        this.table.update(record);
                    }
                }
            }
        }
        length() {
            return this.table.length();
        }
        lookup(value) {
            return this.search(value).map((result) => this.getRecordFromKey(result.id));
        }
        remove(record) {
            let key = this.getKey(record);
            for (let value of this.getValues(record)) {
                for (let token of this.getTokensFromValue(value)) {
                    let hash = computeHash(token);
                    let keys = new Array();
                    try {
                        let record = this.table.lookup(hash);
                        keys = record.keys;
                    }
                    catch (error) { }
                    let position = computePosition(key, keys);
                    if (keys[position] === key) {
                        keys.splice(position, 1);
                        if (keys.length > 0) {
                            this.table.update({
                                id: hash,
                                keys: keys
                            });
                        }
                        else {
                            this.table.remove({
                                id: hash,
                                keys: keys
                            });
                        }
                    }
                }
            }
        }
        search(value) {
            let tokens = this.getTokensFromValue(value);
            let records = tokens
                .map((token) => computeHash(token))
                .map((hash) => {
                try {
                    return this.table.lookup(hash);
                }
                catch (error) { }
            })
                .filter(is.present);
            let map = new Map();
            for (let record of records) {
                for (let key of record.keys) {
                    let rank = map.get(key) ?? (0 - tokens.length);
                    map.set(key, rank + 2);
                }
            }
            return StreamIterable.of(map.entries())
                .filter((entry) => entry[1] >= 0)
                .sort(jsondb_1.sorters.NumericSort.decreasing((entry) => entry[1]))
                .map((entry) => ({
                id: entry[0],
                rank: entry[1]
            }));
        }
        update(last, next) {
            this.remove(last);
            this.insert(next);
        }
    }
    exports.Index = Index;
    Index.NUMBER_TOKENIZER = (value) => {
        let normalized = String(value);
        normalized = normalized.toLowerCase();
        normalized = normalized.normalize("NFC");
        return Array.from(normalized.match(/(\p{N}+)/gu) ?? []);
    };
    Index.QUERY_TOKENIZER = (value) => {
        let normalized = String(value);
        normalized = normalized.toLowerCase();
        normalized = normalized.normalize("NFC");
        return Array.from(normalized.match(/(\p{L}+|\p{N}+)/gu) ?? []);
    };
    Index.VALUE_TOKENIZER = (value) => {
        return [value];
    };
    Index.WORD_TOKENIZER = (value) => {
        let normalized = String(value);
        normalized = normalized.toLowerCase();
        normalized = normalized.normalize("NFC");
        return Array.from(normalized.match(/(\p{L}+)/gu) ?? []);
    };
    ;
});
define("build/jdb2/schema", ["require", "exports", "node_modules/@joelek/ts-autoguard/build/autoguard-lib/index"], function (require, exports, ts_autoguard_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.IndexRecord = void 0;
    exports.IndexRecord = ts_autoguard_1.guards.Object.of({
        "token": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Boolean, ts_autoguard_1.guards.Null, ts_autoguard_1.guards.Number, ts_autoguard_1.guards.String, ts_autoguard_1.guards.Undefined),
        "index": ts_autoguard_1.guards.Number
    });
    exports.Autoguard = {
        "IndexRecord": exports.IndexRecord
    };
});
define("build/jdb2/index", ["require", "exports", "crypto", "fs", "node_modules/@joelek/ts-stdlib/build/index", "build/is", "build/jdb2/asserts/integer", "build/jdb/index", "build/jsondb/index", "build/jdb2/schema"], function (require, exports, libcrypto, libfs, stdlib, is, integer_1, jdb_1, jsondb_1, schema_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /*
    [v1]
        latency shows: 160 ms
        files table: 6191 kB + 431 kB
        indices: 9 MB
        tables: 15 MB
    
    [8bit branch, 32bit pointers]
        latency shows: 290 ms
        files table: 10272 kB + 747 kB
        indices: 178 MB
        tables: 35 MB
    
    [4bit branch, 32bit pointers]
        latency shows: 240 ms
        files table: 6482 kB + 807 kB
        indices: 23 MB
        tables: 20 MB
    
    [4bit branch, 32bit pointers + rhh]
        latency shows: 230 ms
        files table: 6482 kB + 807 kB
        indices: 14 MB
        tables: 20 MB
    
    [rhh + rhh]
        latency shows: 230 ms
        files table: 5823 kB + 431 kB
        indices: 11 MB
        tables: 16 MB
    */
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Index = exports.RobinHoodHash = exports.Table = exports.deserializeKey = exports.serializeKey = exports.bytesFromNibbles = exports.nibblesFromBytes = exports.computeCommonPrefixLength = exports.NodeTable = exports.Node = exports.BlockHandler = exports.Cache = exports.Entry = exports.Pointer = exports.Counter = exports.Chunk = exports.write = exports.size = exports.read = exports.open = void 0;
    const DEBUG = false;
    function open(path) {
        let filename = path.join("/");
        let exists = libfs.existsSync(filename);
        libfs.mkdirSync(path.slice(0, -1).join("/"), { recursive: true });
        let fd = libfs.openSync(filename, exists ? "r+" : "w+");
        return fd;
    }
    exports.open = open;
    ;
    function read(fd, buffer, offset) {
        let length = buffer.length;
        let bytes = libfs.readSync(fd, buffer, {
            position: offset
        });
        if (bytes !== length) {
            throw `Expected to read ${length} bytes but read ${bytes}!`;
        }
        return buffer;
    }
    exports.read = read;
    ;
    function size(fd) {
        return libfs.fstatSync(fd).size;
    }
    exports.size = size;
    ;
    function write(fd, buffer, offset) {
        let length = buffer.length;
        let bytes = libfs.writeSync(fd, buffer, 0, length, offset);
        if (bytes !== length) {
            throw `Expected to write ${length} bytes but wrote ${bytes}!`;
        }
        return buffer;
    }
    exports.write = write;
    ;
    class Chunk {
        constructor(buffer) {
            this.buffer = buffer;
        }
        load(fd, offset) {
            read(fd, this.buffer, offset);
        }
        save(fd, offset) {
            write(fd, this.buffer, offset);
        }
    }
    exports.Chunk = Chunk;
    ;
    class Counter extends Chunk {
        constructor(buffer) {
            buffer = buffer ?? Buffer.alloc(Counter.SIZE);
            if (DEBUG)
                integer_1.IntegerAssert.exactly(buffer.length, Counter.SIZE);
            super(buffer);
        }
        get count() {
            return this.buffer.readUInt32BE(0);
        }
        set count(value) {
            if (DEBUG)
                integer_1.IntegerAssert.between(0, value, 0xFFFFFFFF);
            this.buffer.writeUInt32BE(value, 0);
        }
    }
    exports.Counter = Counter;
    Counter.SIZE = 4;
    ;
    class Pointer extends Chunk {
        constructor(buffer) {
            buffer = buffer ?? Buffer.alloc(Pointer.SIZE);
            if (DEBUG)
                integer_1.IntegerAssert.exactly(buffer.length, Pointer.SIZE);
            super(buffer);
        }
        get index() {
            return this.buffer.readUInt32BE(0);
        }
        set index(value) {
            if (DEBUG)
                integer_1.IntegerAssert.between(0, value, 0xFFFFFFFF);
            this.buffer.writeUInt32BE(value, 0);
        }
    }
    exports.Pointer = Pointer;
    Pointer.SIZE = 4;
    ;
    class Entry extends Chunk {
        constructor(buffer) {
            buffer = buffer ?? Buffer.alloc(Entry.SIZE);
            if (DEBUG)
                integer_1.IntegerAssert.exactly(buffer.length, Entry.SIZE);
            super(buffer);
        }
        get offset() {
            return Number(this.buffer.readBigUInt64BE(0));
        }
        set offset(value) {
            if (DEBUG)
                integer_1.IntegerAssert.between(0, value, 0xFFFFFFFFFFFF);
            this.buffer.writeBigUInt64BE(BigInt(value), 0);
        }
        get deleted() {
            return this.buffer.readUInt8(8) === 0x80;
        }
        set deleted(value) {
            this.buffer.writeUInt8(value ? 0x80 : 0x00, 8);
        }
        get length() {
            return Number(this.buffer.readBigUInt64BE(8) & BigInt(0xFFFFFFFFFFFF)) + 1;
        }
        set length(value) {
            value = value - 1;
            if (DEBUG)
                integer_1.IntegerAssert.between(0, value, 0xFFFFFFFFFFFF);
            let deleted = this.deleted;
            this.buffer.writeBigUInt64BE(BigInt(value), 8);
            this.deleted = deleted;
        }
    }
    exports.Entry = Entry;
    Entry.SIZE = 16;
    ;
    class Cache {
        constructor(weightProvider, maxWeight) {
            this.map = new Map();
            this.weightProvider = weightProvider;
            this.maxWeight = maxWeight;
            this.weight = 0;
        }
        purge() {
            if (is.present(this.maxWeight)) {
                for (let [key, last] of this.map.entries()) {
                    if (this.weight <= this.maxWeight) {
                        break;
                    }
                    this.weight -= this.weightProvider(last);
                    this.map.delete(key);
                }
            }
        }
        insert(key, value) {
            this.remove(key);
            if (is.present(value)) {
                this.weight += this.weightProvider(value);
                this.map.set(key, value);
                this.purge();
            }
        }
        lookup(key) {
            return this.map.get(key);
        }
        remove(key) {
            let value = this.map.get(key);
            if (is.present(value)) {
                this.weight -= this.weightProvider(value);
                this.map.delete(key);
            }
            return value;
        }
    }
    exports.Cache = Cache;
    ;
    class BlockHandler {
        constructor(path) {
            this.bin = open([...path, "bin"]);
            this.toc = open([...path, "toc"]);
            this.blockCache = new Cache((value) => value.length, 512 * 1024 * 1024);
            this.entryCache = new Cache((value) => 1, 1 * 1000 * 1000);
            if (this.getCount() === 0) {
                for (let i = 0; i < BlockHandler.FIRST_APPLICATION_BLOCK; i++) {
                    this.createNewBlock(16);
                }
            }
        }
        computePool(minLength) {
            if (DEBUG)
                integer_1.IntegerAssert.atLeast(0, minLength);
            let lengthLog2 = Math.ceil(Math.log2(Math.max(1, minLength)));
            return lengthLog2;
        }
        createNewBlock(minLength) {
            let entry = new Entry();
            entry.offset = size(this.bin);
            entry.length = Math.pow(2, this.computePool(minLength));
            write(this.bin, Buffer.alloc(entry.length), entry.offset);
            write(this.toc, entry.buffer, size(this.toc));
            return this.getCount() - 1;
        }
        createOldBlock(minLength) {
            let pool = this.computePool(minLength);
            let counter = new Counter();
            this.readBlock(pool, counter.buffer, 0);
            if (counter.count === 0) {
                throw ``;
            }
            let pointer = new Pointer();
            this.readBlock(pool, pointer.buffer, Counter.SIZE + (counter.count - 1) * Pointer.SIZE);
            let index = pointer.index;
            pointer.index = 0;
            this.writeBlock(pool, pointer.buffer, Counter.SIZE + (counter.count - 1) * Pointer.SIZE);
            counter.count -= 1;
            this.writeBlock(pool, counter.buffer, 0);
            let entry = new Entry();
            this.readEntry(index, entry);
            entry.deleted = false;
            this.writeEntry(index, entry);
            return index;
        }
        readEntry(index, entry) {
            if (DEBUG)
                integer_1.IntegerAssert.between(0, index, this.getCount() - 1);
            let cached = this.entryCache.lookup(index);
            if (is.absent(cached)) {
                cached = new Entry();
                read(this.toc, cached.buffer, index * Entry.SIZE);
                this.entryCache.insert(index, cached);
            }
            cached.buffer.copy(entry.buffer, 0, 0);
            return entry;
        }
        writeEntry(index, entry) {
            if (DEBUG)
                integer_1.IntegerAssert.between(0, index, this.getCount() - 1);
            write(this.toc, entry.buffer, index * Entry.SIZE);
            let cached = new Entry();
            entry.buffer.copy(cached.buffer, 0, 0);
            this.entryCache.insert(index, cached);
            return entry;
        }
        clearBlock(index) {
            this.writeBlock(index, Buffer.alloc(0));
        }
        createBlock(minLength) {
            if (minLength === 0) {
                return 0xFFFFFFFF;
            }
            try {
                return this.createOldBlock(minLength);
            }
            catch (error) { }
            try {
                return this.createNewBlock(minLength);
            }
            catch (error) { }
            throw `Unable to create block with length ${minLength}!`;
        }
        deleteBlock(index) {
            if (index === 0xFFFFFFFF) {
                return;
            }
            let entry = new Entry();
            this.readEntry(index, entry);
            if (entry.deleted) {
                return;
            }
            let pool = this.computePool(entry.length);
            let counter = new Counter();
            this.readBlock(pool, counter.buffer, 0);
            let minLength = Counter.SIZE + (counter.count + 1) * Pointer.SIZE;
            let length = this.readEntry(pool, new Entry()).length;
            if (minLength > length) {
                this.resizeBlock(pool, minLength);
                this.readBlock(pool, counter.buffer, 0); // Resize can in theory consume one block.
            }
            let pointer = new Pointer();
            pointer.index = index;
            this.writeBlock(pool, pointer.buffer, Counter.SIZE + (counter.count * Pointer.SIZE));
            counter.count += 1;
            this.writeBlock(pool, counter.buffer, 0);
            let buffer = Buffer.alloc(entry.length);
            this.writeBlock(index, buffer, 0);
            entry.deleted = true;
            this.writeEntry(index, entry);
            this.blockCache.remove(index);
        }
        getBlockSize(index) {
            if (index === 0xFFFFFFFF) {
                return 0;
            }
            let entry = new Entry();
            this.readEntry(index, entry);
            return entry.length;
        }
        getCount() {
            let count = size(this.toc) / Entry.SIZE;
            if (DEBUG)
                integer_1.IntegerAssert.atLeast(0, count);
            return count;
        }
        readBlock(index, buffer, skipLength) {
            if (index === 0xFFFFFFFF) {
                return Buffer.alloc(0);
            }
            let entry = new Entry();
            this.readEntry(index, entry);
            buffer = buffer ?? Buffer.alloc(entry.length);
            let offset = skipLength ?? 0;
            let length = buffer.length;
            if (DEBUG)
                integer_1.IntegerAssert.between(0, offset, entry.length - 1);
            if (DEBUG)
                integer_1.IntegerAssert.between(0, length, entry.length - offset);
            let cached = this.blockCache.lookup(index);
            if (is.absent(cached)) {
                cached = Buffer.alloc(entry.length);
                read(this.bin, cached, entry.offset);
                this.blockCache.insert(index, cached);
            }
            cached.copy(buffer, 0, offset);
            return buffer;
        }
        resizeBlock(index, minLength) {
            if (index === 0xFFFFFFFF) {
                return;
            }
            let entry = new Entry();
            this.readEntry(index, entry);
            if (this.computePool(minLength) === this.computePool(entry.length)) {
                return;
            }
            let indexTwo = this.createBlock(minLength);
            let entryTwo = new Entry();
            this.readEntry(indexTwo, entryTwo);
            let length = Math.min(entry.length, entryTwo.length);
            let buffer = Buffer.alloc(length);
            this.readBlock(index, buffer);
            this.writeBlock(indexTwo, buffer, 0);
            this.swapBlocks(index, indexTwo);
            this.deleteBlock(indexTwo);
        }
        swapBlocks(indexOne, indexTwo) {
            let entryOne = new Entry();
            this.readEntry(indexOne, entryOne);
            let entryTwo = new Entry();
            this.readEntry(indexTwo, entryTwo);
            this.writeEntry(indexOne, entryTwo);
            this.writeEntry(indexTwo, entryOne);
            let blockOne = this.blockCache.remove(indexOne);
            let blockTwo = this.blockCache.remove(indexTwo);
            this.blockCache.insert(indexOne, blockTwo);
            this.blockCache.insert(indexTwo, blockOne);
        }
        writeBlock(index, buffer, skipLength) {
            if (index === 0xFFFFFFFF) {
                return Buffer.alloc(0);
            }
            let entry = new Entry();
            this.readEntry(index, entry);
            buffer = buffer ?? Buffer.alloc(entry.length);
            let offset = skipLength ?? 0;
            let length = buffer.length;
            if (DEBUG)
                integer_1.IntegerAssert.between(0, offset, entry.length - 1);
            if (DEBUG)
                integer_1.IntegerAssert.between(0, length, entry.length - offset);
            write(this.bin, buffer, entry.offset + offset);
            if (is.absent(skipLength)) {
                write(this.bin, Buffer.alloc(entry.length - buffer.length), entry.offset + buffer.length);
            }
            let cached = this.blockCache.lookup(index);
            if (is.present(cached)) {
                cached.set(buffer, offset);
                if (is.absent(skipLength)) {
                    cached.set(Buffer.alloc(entry.length - buffer.length), buffer.length);
                }
            }
            return buffer;
        }
    }
    exports.BlockHandler = BlockHandler;
    BlockHandler.FIRST_APPLICATION_BLOCK = 64;
    ;
    class Node extends Chunk {
        constructor(buffer) {
            buffer = buffer ?? Buffer.alloc(Node.SIZE);
            if (DEBUG)
                integer_1.IntegerAssert.exactly(buffer.length, Node.SIZE);
            super(buffer);
        }
        prefix(value) {
            if (is.present(value)) {
                let length = value.length;
                if (DEBUG)
                    integer_1.IntegerAssert.between(0, length, Node.MAX_NIBBLES);
                let bytes = bytesFromNibbles(Buffer.of(length, ...value));
                this.buffer.set(bytes, 0);
                this.buffer.fill(0, bytes.length, 8);
                return this.buffer;
            }
            else {
                let bytes = this.buffer.slice(0, 8);
                let nibbles = nibblesFromBytes(bytes);
                let length = nibbles[0];
                return nibbles.slice(1, 1 + length);
            }
        }
        resident(value) {
            let offset = 8;
            if (is.present(value)) {
                if (DEBUG)
                    integer_1.IntegerAssert.between(0, value, 0xFFFFFFFF);
                this.buffer.writeUInt32BE(value, offset);
                return value;
            }
            else {
                return this.buffer.readUInt32BE(offset);
            }
        }
    }
    exports.Node = Node;
    Node.MAX_NIBBLES = 15;
    Node.SIZE = 8 + 8;
    ;
    class NodeTable extends Chunk {
        constructor(buffer) {
            buffer = buffer ?? Buffer.alloc(NodeTable.SIZE);
            if (DEBUG)
                integer_1.IntegerAssert.exactly(buffer.length, NodeTable.SIZE);
            super(buffer);
        }
        subtree(index, value) {
            if (DEBUG)
                integer_1.IntegerAssert.between(0, index, NodeTable.LENGTH - 1);
            let offset = index * 4;
            if (is.present(value)) {
                if (DEBUG)
                    integer_1.IntegerAssert.between(0, value, 0xFFFFFFFF);
                this.buffer.writeUInt32BE(value, offset);
                return value;
            }
            else {
                return this.buffer.readUInt32BE(offset);
            }
        }
    }
    exports.NodeTable = NodeTable;
    NodeTable.LENGTH = 16;
    NodeTable.SIZE = NodeTable.LENGTH * 4;
    ;
    function computeCommonPrefixLength(prefixBytes, keyBytes, keyByteIndex) {
        let length = Math.min(prefixBytes.length, keyBytes.length - keyByteIndex);
        for (let i = 0; i < length; i++) {
            let prefixByte = prefixBytes[i];
            let keyByte = keyBytes[keyByteIndex + i];
            if (prefixByte !== keyByte) {
                return i;
            }
        }
        return length;
    }
    exports.computeCommonPrefixLength = computeCommonPrefixLength;
    ;
    function nibblesFromBytes(bytes) {
        let nibbles = new Array();
        for (let byte of bytes) {
            nibbles.push((byte >> 4) & 0x0F, (byte >> 0) & 0x0F);
        }
        return Buffer.from(nibbles);
    }
    exports.nibblesFromBytes = nibblesFromBytes;
    ;
    function bytesFromNibbles(nibbles) {
        let bytes = new Array();
        for (let i = 0; i < nibbles.length; i += 2) {
            bytes.push((nibbles[i + 0] << 4) | (nibbles[i + 1] << 0));
        }
        return Buffer.from(bytes);
    }
    exports.bytesFromNibbles = bytesFromNibbles;
    ;
    function serializeKey(key) {
        let bytes = (() => {
            if (typeof key === "boolean") {
                return Buffer.of(key ? 1 : 0);
            }
            if (typeof key === "number") {
                return Buffer.from(`${key}`);
            }
            if (typeof key === "string") {
                if (/^[0-9a-f]{8,}$/i.test(key)) {
                    return Buffer.from(key, "hex");
                }
                else {
                    return Buffer.from(key, "binary");
                }
            }
            return Buffer.alloc(0);
        })();
        return nibblesFromBytes(bytes);
    }
    exports.serializeKey = serializeKey;
    ;
    function deserializeKey(nibbles) {
        return bytesFromNibbles(nibbles).toString("binary");
    }
    exports.deserializeKey = deserializeKey;
    ;
    class Table extends stdlib.routing.MessageRouter {
        constructor(blockHandler, recordParser, keyProvider) {
            super();
            if (blockHandler.getCount() === BlockHandler.FIRST_APPLICATION_BLOCK) {
                blockHandler.createBlock(RobinHoodHash.INITIAL_SIZE);
            }
            this.recordCache = new Cache((record) => 1, 1 * 1000 * 1000);
            this.blockHandler = blockHandler;
            this.recordParser = recordParser;
            this.keyProvider = keyProvider;
            this.hashTable = new RobinHoodHash(blockHandler, BlockHandler.FIRST_APPLICATION_BLOCK, (index) => {
                let record = this.getRecord(index);
                return this.keyProvider(record);
            });
        }
        debug() {
            this.hashTable.debug();
        }
        *[Symbol.iterator]() {
            yield* jdb_1.StreamIterable.of(this.hashTable)
                .map((value) => this.getRecord(value));
        }
        getRecord(index) {
            let record = this.recordCache.lookup(index);
            if (is.present(record)) {
                return record;
            }
            let block = this.blockHandler.readBlock(index);
            let string = block.toString().replace(/[\0]*$/, "");
            let json = JSON.parse(string);
            record = this.recordParser(json);
            this.recordCache.insert(index, record);
            return record;
        }
        entries() {
            return jdb_1.StreamIterable.of(this.hashTable)
                .map((index) => {
                let record = this.getRecord(index);
                let key = this.keyProvider(record);
                return [key, index, record];
            })
                .slice();
        }
        insert(next) {
            let bytes = Buffer.from(JSON.stringify(next));
            let key = this.keyProvider(next);
            let index = this.hashTable.lookup(key);
            if (is.absent(index)) {
                index = this.blockHandler.createBlock(bytes.length);
                this.blockHandler.writeBlock(index, bytes);
                this.hashTable.insert(key, index);
                this.recordCache.insert(index, next);
                this.route("insert", {
                    key: key,
                    index: index,
                    record: next
                });
            }
            else {
                let last = this.getRecord(index);
                this.blockHandler.resizeBlock(index, bytes.length);
                this.blockHandler.writeBlock(index, bytes);
                this.recordCache.insert(index, next);
                this.route("update", {
                    key: key,
                    index: index,
                    last: last,
                    next: next
                });
            }
        }
        lookup(key) {
            let index = this.hashTable.lookup(key);
            if (is.absent(index)) {
                throw `Expected a record for ${key}!`;
            }
            let record = this.getRecord(index);
            return record;
        }
        remove(next) {
            let key = this.keyProvider(next);
            let index = this.hashTable.lookup(key);
            if (is.absent(index)) {
                return;
            }
            this.blockHandler.deleteBlock(index);
            this.recordCache.remove(index);
            this.route("remove", {
                key: key,
                index: index,
                record: next
            });
        }
        update(next) {
            this.insert(next);
        }
    }
    exports.Table = Table;
    ;
    class RobinHoodHash {
        constructor(blockHandler, blockIndex, keyFromIndexProvider) {
            this.blockHandler = blockHandler;
            this.blockIndex = blockIndex;
            this.keyFromIndexProvider = keyFromIndexProvider;
        }
        readHeader() {
            let buffer = Buffer.alloc(16);
            this.blockHandler.readBlock(this.blockIndex, buffer, 0);
            let occupiedSlots = Number(buffer.readBigUInt64BE(0));
            return {
                occupiedSlots
            };
        }
        writeHeader(header) {
            let buffer = Buffer.alloc(16);
            buffer.writeBigUInt64BE(BigInt(header.occupiedSlots), 0);
            this.blockHandler.writeBlock(this.blockIndex, buffer, 0);
        }
        getSlotCount() {
            let blockSize = this.blockHandler.getBlockSize(this.blockIndex);
            return (blockSize - 16) / 8;
        }
        computeOptimalSlot(serializedKey) {
            let hash = libcrypto.createHash("sha256")
                .update(serializedKey)
                .digest();
            let slotCount = this.getSlotCount();
            let optimalSlot = Number(hash.readBigUInt64BE(0) % BigInt(slotCount));
            return optimalSlot;
        }
        loadSlot(slotIndex) {
            let buffer = Buffer.alloc(8);
            this.blockHandler.readBlock(this.blockIndex, buffer, 16 + slotIndex * 8);
            let probeDistance = buffer.readUInt8(0);
            let isOccupied = buffer.readUInt8(1) === 0x01;
            let index = Number(buffer.readBigUInt64BE(0) & 0x0000ffffffffffffn);
            return {
                probeDistance,
                isOccupied,
                index
            };
        }
        saveSlot(slotIndex, slot) {
            let buffer = Buffer.alloc(8);
            buffer.writeBigUInt64BE(BigInt(slot.index), 0);
            buffer.writeUInt8(slot.probeDistance, 0);
            buffer.writeUInt8(slot.isOccupied ? 0x01 : 0x00, 1);
            this.blockHandler.writeBlock(this.blockIndex, buffer, 16 + slotIndex * 8);
        }
        resizeIfNeccessary() {
            let slotCount = this.getSlotCount();
            let occupiedSlots = this.readHeader().occupiedSlots;
            let currentLoadFactor = occupiedSlots / slotCount;
            let desiredSlotCount = slotCount;
            if (currentLoadFactor <= 0.25) {
                desiredSlotCount = Math.max(Math.ceil(slotCount / 2), 2);
            }
            if (currentLoadFactor >= 0.75) {
                desiredSlotCount = slotCount * 2;
            }
            if (desiredSlotCount === slotCount) {
                return;
            }
            let values = jdb_1.StreamIterable.of(this).collect();
            let minLength = 16 + desiredSlotCount * 8;
            this.blockHandler.resizeBlock(this.blockIndex, minLength);
            let newSlotCount = this.getSlotCount();
            if (newSlotCount === slotCount) {
                return;
            }
            this.blockHandler.clearBlock(this.blockIndex);
            for (let value of values) {
                let key = this.keyFromIndexProvider(value);
                this.insertWithoutResize(key, value);
            }
        }
        insertWithoutResize(key, index) {
            let serializedKey = serializeKey(key);
            let optimalSlot = this.computeOptimalSlot(serializedKey);
            let slotCount = this.getSlotCount();
            let slotIndex = optimalSlot;
            let probeDistance = 0;
            /* 		if (key === "6ceb78a4cc7210af") {
                        console.log("insert", {optimalSlot, slotCount})
                    } */
            for (let i = 0; i < slotCount; i++) {
                let slot = this.loadSlot(slotIndex);
                if (!slot.isOccupied) {
                    this.saveSlot(slotIndex, {
                        index: index,
                        probeDistance: probeDistance,
                        isOccupied: true
                    });
                    let header = this.readHeader();
                    header.occupiedSlots += 1;
                    this.writeHeader(header);
                    /* 		if (key === "6ceb78a4cc7210af") {
                                console.log("insert new", {slotIndex, probeDistance})
                            } */
                    return;
                }
                if (slot.index === index) {
                    /* 		if (key === "6ceb78a4cc7210af") {
                                console.log("insert update", {slotIndex, probeDistance})
                            } */
                    return;
                }
                if (probeDistance > slot.probeDistance) {
                    this.saveSlot(slotIndex, {
                        index: index,
                        probeDistance: probeDistance,
                        isOccupied: true
                    });
                    index = slot.index;
                    probeDistance = slot.probeDistance;
                }
                slotIndex = (slotIndex + 1) % slotCount;
                probeDistance += 1;
            }
            throw `Expected code to be unreachable!`;
        }
        propagateBackwards(slotIndex) {
            let slotCount = this.getSlotCount();
            for (let i = 0; i < slotCount; i++) {
                let slot = this.loadSlot((slotIndex + 1) % slotCount);
                if (slot.probeDistance === 0) {
                    this.saveSlot(slotIndex, {
                        index: 0,
                        probeDistance: 0,
                        isOccupied: false
                    });
                    break;
                }
                this.saveSlot(slotIndex, {
                    index: slot.index,
                    probeDistance: slot.probeDistance - 1,
                    isOccupied: true
                });
                slotIndex = (slotIndex + 1) % slotCount;
            }
        }
        removeWithoutResize(key, index) {
            let serializedKey = serializeKey(key);
            let optimalSlot = this.computeOptimalSlot(serializedKey);
            let slotCount = this.getSlotCount();
            let slotIndex = optimalSlot;
            let probeDistance = 0;
            for (let i = 0; i < slotCount; i++) {
                let slot = this.loadSlot(slotIndex);
                if (!slot.isOccupied || probeDistance > slot.probeDistance) {
                    // not inserted
                    return;
                }
                if (slot.index === index) {
                    let header = this.readHeader();
                    header.occupiedSlots -= 1;
                    this.writeHeader(header);
                    this.propagateBackwards(slotIndex);
                    // removed
                    return;
                }
                slotIndex = (slotIndex + 1) % slotCount;
                probeDistance += 1;
            }
            throw `Expected code to be unreachable!`;
        }
        *[Symbol.iterator]() {
            let slotCount = this.getSlotCount();
            for (let slotIndex = 0; slotIndex < slotCount; slotIndex++) {
                let slot = this.loadSlot(slotIndex);
                if (slot.isOccupied) {
                    yield slot.index;
                }
            }
        }
        entries() {
            return jdb_1.StreamIterable.of(this)
                .map((index) => {
                let key = this.keyFromIndexProvider(index);
                return {
                    key,
                    index
                };
            })
                .slice();
        }
        insert(key, index) {
            this.insertWithoutResize(key, index);
            this.resizeIfNeccessary();
        }
        lookup(key) {
            let serializedKey = serializeKey(key);
            let optimalSlot = this.computeOptimalSlot(serializedKey);
            let slotCount = this.getSlotCount();
            let slotIndex = optimalSlot;
            let probeDistance = 0;
            for (let i = 0; i < slotCount; i++) {
                let slot = this.loadSlot(slotIndex);
                /* 		if (key === "6ceb78a4cc7210af") {
                
                            console.log({serializedKey, optimalSlot, slotIndex, slot, key, probeDistance });
                        } */
                if (!slot.isOccupied || probeDistance > slot.probeDistance) {
                    /* 		if (key === "6ceb78a4cc7210af") {
                                this.debug();
                            } */
                    return;
                }
                if (this.keyFromIndexProvider(slot.index) === key) {
                    return slot.index;
                }
                slotIndex = (slotIndex + 1) % slotCount;
                probeDistance += 1;
            }
            throw `Expected code to be unreachable!`;
        }
        remove(key, index) {
            this.removeWithoutResize(key, index);
            this.resizeIfNeccessary();
        }
        debug() {
            let header = this.readHeader();
            console.log(header);
            let slotCount = this.getSlotCount();
            for (let slotIndex = 0; slotIndex < slotCount; slotIndex++) {
                let slot = this.loadSlot(slotIndex);
                let key = slot.isOccupied ? this.keyFromIndexProvider(slot.index) : undefined;
                console.log({
                    ...slot,
                    key
                });
            }
        }
    }
    exports.RobinHoodHash = RobinHoodHash;
    RobinHoodHash.INITIAL_SIZE = 16 + 2 * 8;
    ;
    class Index {
        constructor(blockHandler, parentTable, childTable, getIndexedValues, getTokens = Index.VALUE_TOKENIZER) {
            let tokenTable = new Table(blockHandler, schema_1.IndexRecord.as, (record) => record.token);
            function insert(key, index, record) {
                let values = is.present(record) ? getIndexedValues(record) : [];
                for (let value of values) {
                    let tokens = getTokens(value);
                    for (let token of tokens) {
                        let indexRecord;
                        try {
                            indexRecord = tokenTable.lookup(token);
                        }
                        catch (error) { }
                        if (is.absent(indexRecord)) {
                            let index = blockHandler.createBlock(RobinHoodHash.INITIAL_SIZE);
                            indexRecord = {
                                token,
                                index
                            };
                            tokenTable.insert(indexRecord);
                        }
                        let rhh = new RobinHoodHash(blockHandler, indexRecord.index, (index) => index);
                        rhh.insert(index, index);
                    }
                }
            }
            function remove(key, index, record) {
                let values = is.present(record) ? getIndexedValues(record) : [];
                for (let value of values) {
                    let tokens = getTokens(value);
                    for (let token of tokens) {
                        let indexRecord;
                        try {
                            indexRecord = tokenTable.lookup(token);
                        }
                        catch (error) { }
                        if (is.absent(indexRecord)) {
                            continue;
                        }
                        let rhh = new RobinHoodHash(blockHandler, indexRecord.index, (index) => index);
                        rhh.remove(index, index);
                    }
                }
            }
            childTable.addObserver("insert", (event) => {
                insert(event.key, event.index, event.record);
            });
            childTable.addObserver("remove", (event) => {
                remove(event.key, event.index, event.record);
            });
            childTable.addObserver("update", (event) => {
                remove(event.key, event.index, event.last);
                insert(event.key, event.index, event.next);
            });
            parentTable.addObserver("remove", (event) => {
                let token = event.key;
                try {
                    let indexRecord = tokenTable.lookup(token);
                    let rhh = new RobinHoodHash(this.blockHandler, indexRecord.index, (index) => index);
                    for (let entry of rhh.entries()) {
                        let record = childTable.lookup(entry.key);
                        childTable.remove(record);
                    }
                }
                catch (error) { }
            });
            if (blockHandler.getCount() === BlockHandler.FIRST_APPLICATION_BLOCK + 1) {
                for (let [key, index, record] of childTable.entries()) {
                    insert(key, index, record);
                }
            }
            this.blockHandler = blockHandler;
            this.tokenTable = tokenTable;
            this.parentTable = parentTable;
            this.childTable = childTable;
            this.getIndexedValues = getIndexedValues;
            this.getTokens = getTokens;
        }
        debug() {
            this.tokenTable.debug();
        }
        lookup(query) {
            return this.search(query)
                .map((result) => result.lookup())
                .slice();
        }
        search(query) {
            let tokens = this.getTokens(query);
            let map = new Map();
            for (let token of tokens) {
                try {
                    let indexRecord = this.tokenTable.lookup(token);
                    let rhh = new RobinHoodHash(this.blockHandler, indexRecord.index, (index) => index);
                    for (let index of rhh) {
                        let key = index;
                        let rank = map.get(key) ?? (0 - tokens.length);
                        map.set(key, rank + 2);
                    }
                }
                catch (error) { }
            }
            return jdb_1.StreamIterable.of(map.entries())
                .filter((result) => result[1] >= 0)
                .sort(jsondb_1.sorters.NumericSort.decreasing((result) => result[1]))
                .map((entry) => ({
                index: entry[0],
                rank: entry[1],
                lookup: () => this.childTable.getRecord(entry[0])
            }));
        }
    }
    exports.Index = Index;
    Index.NUMBER_TOKENIZER = (value) => {
        let normalized = String(value);
        normalized = normalized.toLowerCase();
        normalized = normalized.normalize("NFC");
        normalized = normalized.replace(/['"`´]+/g, "");
        return Array.from(normalized.match(/(\p{N}+)/gu) ?? []);
    };
    Index.QUERY_TOKENIZER = (value) => {
        let normalized = String(value);
        normalized = normalized.toLowerCase();
        normalized = normalized.normalize("NFC");
        normalized = normalized.replace(/['"`´]+/g, "");
        return Array.from(normalized.match(/(\p{L}+|\p{N}+)/gu) ?? []);
    };
    Index.VALUE_TOKENIZER = (value) => {
        return [value];
    };
    Index.WORD_TOKENIZER = (value) => {
        let normalized = String(value);
        normalized = normalized.toLowerCase();
        normalized = normalized.normalize("NFC");
        normalized = normalized.replace(/['"`´]+/g, "");
        return Array.from(normalized.match(/(\p{L}+)/gu) ?? []);
    };
    ;
});
define("build/database/indexer", ["require", "exports", "crypto", "fs", "build/database/schema", "build/jsondb/index", "build/is", "build/database/probes/index", "build/config/index", "build/jdb2/index"], function (require, exports, libcrypto, libfs, schema, indices, is, probes, config_1, jdb2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getFilesFromMovie = exports.getMoviesFromFile = exports.movie_files = exports.movies = exports.getFilesFromEpisode = exports.getEpisodesFromFile = exports.episode_files = exports.getEpisodesFromSeason = exports.episodes = exports.getSeasonsFromShow = exports.seasons = exports.getFilesFromShow = exports.getShowsFromFile = exports.show_files = exports.shows = exports.getTracksFromArtist = exports.getArtistsFromTrack = exports.track_artists = exports.getAlbumsFromArtist = exports.getArtistsFromAlbum = exports.album_artists = exports.getFilesFromTrack = exports.getTracksFromFile = exports.track_files = exports.getTracksFromDisc = exports.tracks = exports.getDiscsFromAlbum = exports.discs = exports.getFilesFromAlbum = exports.getAlbumsFromFile = exports.album_files = exports.albums = exports.artists = exports.getVideoFilesFromSubtitleFile = exports.getSubtitleFilesFromVideoFile = exports.video_subtitles = exports.getVideoFilesFromFile = exports.video_files = exports.getSubtitleFilesFromFile = exports.subtitle_files = exports.getMetadataFilesFromFile = exports.metadata_files = exports.getImageFilesFromFile = exports.image_files = exports.getAudioFiles = exports.audio_files = exports.getFilesFromDirectory = exports.files = exports.getDirectoriesFromDirectory = exports.directories = void 0;
    exports.runIndexer = exports.getPath = exports.year_search = exports.user_search = exports.track_search = exports.shows_search = exports.playlist_search = exports.actor_search = exports.movie_search = exports.genre_search = exports.episode_search = exports.cue_search = exports.artist_search = exports.album_search = exports.getAlbumsFromYear = exports.getMoviesFromYear = exports.years = exports.getPlaylistItemsFromTrack = exports.getPlaylistsItemsFromPlaylist = exports.playlist_items = exports.getPlaylistsFromUser = exports.playlists = exports.getStreamsFromFile = exports.getStreamsFromUser = exports.streams = exports.getTokensFromUser = exports.tokens = exports.getKeysFromUser = exports.keys = exports.getUsersFromUsername = exports.users = exports.getCuesFromSubtitle = exports.cues = exports.subtitles = exports.getGenresFromShow = exports.getShowsFromGenre = exports.show_genres = exports.getGenresFromMovie = exports.getMoviesFromGenre = exports.movie_genres = exports.genres = exports.getActorsFromShow = exports.getShowsFromActor = exports.show_actors = exports.getActorsFromMovie = exports.getMoviesFromActor = exports.movie_actors = exports.actors = void 0;
    function wordify(string) {
        return String(string)
            .toLowerCase()
            .normalize("NFKD")
            .replace(/[\|\/\\\_\-]/g, " ")
            .replace(/[^a-z0-9 ]/g, "")
            .trim()
            .split(/[ ]+/g);
    }
    function makeId(...components) {
        components = components
            .map((component) => wordify(component ?? ""))
            .map((words) => {
            return words.join(" ");
        });
        return libcrypto.createHash("sha256")
            .update(components.join("\0"))
            .digest("hex")
            .slice(0, 16);
    }
    if (!libfs.existsSync(config_1.default.media_path.join("/"))) {
        libfs.mkdirSync(config_1.default.media_path.join("/"));
    }
    const TABLES_ROOT = [
        ".",
        "private",
        "tables"
    ];
    if (!libfs.existsSync(TABLES_ROOT.join("/"))) {
        libfs.mkdirSync(TABLES_ROOT.join("/"));
    }
    const INDICES_ROOT = [
        ".",
        "private",
        "indices"
    ];
    if (!libfs.existsSync(INDICES_ROOT.join("/"))) {
        libfs.mkdirSync(INDICES_ROOT.join("/"));
    }
    function loadTable(name, guard, getKey) {
        let blockHandler = new jdb2.BlockHandler([".", "private", "tables2", name]);
        let table = new jdb2.Table(blockHandler, (json) => guard.as(json), getKey);
        return table;
    }
    function loadIndex(name, parent, child, getGroupKey, tokenizer = jdb2.Index.VALUE_TOKENIZER) {
        let blockHandler = new jdb2.BlockHandler([".", "private", "indices2", name]);
        let index = new jdb2.Index(blockHandler, parent, child, getGroupKey, tokenizer);
        return index;
    }
    exports.directories = loadTable("directories", schema.Directory, (record) => record.directory_id);
    exports.getDirectoriesFromDirectory = loadIndex("directory_directories", exports.directories, exports.directories, (record) => [record.parent_directory_id]);
    exports.files = loadTable("files", schema.File, (record) => record.file_id);
    exports.getFilesFromDirectory = loadIndex("directory_files", exports.directories, exports.files, (record) => [record.parent_directory_id]);
    exports.audio_files = loadTable("audio_files", schema.AudioFile, (record) => record.file_id);
    exports.getAudioFiles = loadIndex("file_audio_files", exports.files, exports.audio_files, (record) => [record.file_id]);
    exports.image_files = loadTable("image_files", schema.ImageFile, (record) => record.file_id);
    exports.getImageFilesFromFile = loadIndex("file_image_files", exports.files, exports.image_files, (record) => [record.file_id]);
    exports.metadata_files = loadTable("metadata_files", schema.MetadataFile, (record) => record.file_id);
    exports.getMetadataFilesFromFile = loadIndex("file_metadata_files", exports.files, exports.metadata_files, (record) => [record.file_id]);
    exports.subtitle_files = loadTable("subtitle_files", schema.SubtitleFile, (record) => record.file_id);
    exports.getSubtitleFilesFromFile = loadIndex("file_subtitle_files", exports.files, exports.subtitle_files, (record) => [record.file_id]);
    exports.video_files = loadTable("video_files", schema.VideoFile, (record) => record.file_id);
    exports.getVideoFilesFromFile = loadIndex("file_video_files", exports.files, exports.video_files, (record) => [record.file_id]);
    exports.video_subtitles = loadTable("video_subtitles", schema.VideoSubtitle, (record) => makeId(record.video_file_id, record.subtitle_file_id));
    exports.getSubtitleFilesFromVideoFile = loadIndex("video_file_video_subtitles", exports.video_files, exports.video_subtitles, (record) => [record.video_file_id]);
    exports.getVideoFilesFromSubtitleFile = loadIndex("subtitle_file_video_subtitles", exports.subtitle_files, exports.video_subtitles, (record) => [record.subtitle_file_id]);
    exports.artists = loadTable("artists", schema.Artist, (record) => record.artist_id);
    exports.albums = loadTable("albums", schema.Album, (record) => record.album_id);
    exports.album_files = loadTable("album_files", schema.AlbumFile, (record) => makeId(record.album_id, record.file_id));
    exports.getAlbumsFromFile = loadIndex("file_album_files", exports.files, exports.album_files, (record) => [record.file_id]);
    exports.getFilesFromAlbum = loadIndex("album_album_files", exports.albums, exports.album_files, (record) => [record.album_id]);
    exports.discs = loadTable("discs", schema.Disc, (record) => record.disc_id);
    exports.getDiscsFromAlbum = loadIndex("album_discs", exports.albums, exports.discs, (record) => [record.album_id]);
    exports.tracks = loadTable("tracks", schema.Track, (record) => record.track_id);
    exports.getTracksFromDisc = loadIndex("disc_tracks", exports.discs, exports.tracks, (record) => [record.disc_id]);
    exports.track_files = loadTable("track_files", schema.TrackFile, (record) => makeId(record.track_id, record.file_id));
    exports.getTracksFromFile = loadIndex("file_track_files", exports.files, exports.track_files, (record) => [record.file_id]);
    exports.getFilesFromTrack = loadIndex("track_track_files", exports.tracks, exports.track_files, (record) => [record.track_id]);
    exports.album_artists = loadTable("album_artists", schema.AlbumArtist, (record) => makeId(record.album_id, record.artist_id));
    exports.getArtistsFromAlbum = loadIndex("album_album_artists", exports.albums, exports.album_artists, (record) => [record.album_id]);
    exports.getAlbumsFromArtist = loadIndex("artist_album_artists", exports.artists, exports.album_artists, (record) => [record.artist_id]);
    exports.track_artists = loadTable("track_artists", schema.TrackArtist, (record) => makeId(record.track_id, record.artist_id));
    exports.getArtistsFromTrack = loadIndex("track_track_artists", exports.tracks, exports.track_artists, (record) => [record.track_id]);
    exports.getTracksFromArtist = loadIndex("artist_track_artists", exports.artists, exports.track_artists, (record) => [record.artist_id]);
    exports.shows = loadTable("shows", schema.Show, (record) => record.show_id);
    exports.show_files = loadTable("show_files", schema.ShowFile, (record) => makeId(record.show_id, record.file_id));
    exports.getShowsFromFile = loadIndex("file_show_files", exports.files, exports.show_files, (record) => [record.file_id]);
    exports.getFilesFromShow = loadIndex("show_show_files", exports.shows, exports.show_files, (record) => [record.show_id]);
    exports.seasons = loadTable("seasons", schema.Season, (record) => record.season_id);
    exports.getSeasonsFromShow = loadIndex("show_seasons", exports.shows, exports.seasons, (record) => [record.show_id]);
    exports.episodes = loadTable("episodes", schema.Episode, (record) => record.episode_id);
    exports.getEpisodesFromSeason = loadIndex("season_episodes", exports.seasons, exports.episodes, (record) => [record.season_id]);
    exports.episode_files = loadTable("episode_files", schema.EpisodeFile, (record) => makeId(record.episode_id, record.file_id));
    exports.getEpisodesFromFile = loadIndex("file_episode_files", exports.files, exports.episode_files, (record) => [record.file_id]);
    exports.getFilesFromEpisode = loadIndex("episode_episode_files", exports.episodes, exports.episode_files, (record) => [record.episode_id]);
    exports.movies = loadTable("movies", schema.Movie, (record) => record.movie_id);
    exports.movie_files = loadTable("movie_files", schema.MovieFile, (record) => makeId(record.movie_id, record.file_id));
    exports.getMoviesFromFile = loadIndex("file_movie_files", exports.files, exports.movie_files, (record) => [record.file_id]);
    exports.getFilesFromMovie = loadIndex("movie_movie_files", exports.movies, exports.movie_files, (record) => [record.movie_id]);
    exports.actors = loadTable("actors", schema.Actor, (record) => record.actor_id);
    exports.movie_actors = loadTable("movie_actors", schema.MovieActor, (record) => makeId(record.movie_id, record.actor_id));
    exports.getMoviesFromActor = loadIndex("actor_movie_actors", exports.actors, exports.movie_actors, (record) => [record.actor_id]);
    exports.getActorsFromMovie = loadIndex("movie_movie_actors", exports.movies, exports.movie_actors, (record) => [record.movie_id]);
    exports.show_actors = loadTable("show_actors", schema.ShowActor, (record) => makeId(record.show_id, record.actor_id));
    exports.getShowsFromActor = loadIndex("actor_show_actors", exports.actors, exports.show_actors, (record) => [record.actor_id]);
    exports.getActorsFromShow = loadIndex("show_show_actors", exports.shows, exports.show_actors, (record) => [record.show_id]);
    exports.genres = loadTable("genres", schema.Genre, (record) => record.genre_id);
    exports.movie_genres = loadTable("movie_genres", schema.MovieGenre, (record) => makeId(record.movie_id, record.genre_id));
    exports.getMoviesFromGenre = loadIndex("genre_movie_genres", exports.genres, exports.movie_genres, (record) => [record.genre_id]);
    exports.getGenresFromMovie = loadIndex("movie_movie_genres", exports.movies, exports.movie_genres, (record) => [record.movie_id]);
    exports.show_genres = loadTable("show_genres", schema.ShowGenre, (record) => makeId(record.show_id, record.genre_id));
    exports.getShowsFromGenre = loadIndex("genre_show_genres", exports.genres, exports.show_genres, (record) => [record.genre_id]);
    exports.getGenresFromShow = loadIndex("show_show_genres", exports.shows, exports.show_genres, (record) => [record.show_id]);
    exports.subtitles = loadTable("subtitles", schema.Subtitle, (record) => record.subtitle_id);
    exports.cues = loadTable("cues", schema.Cue, (record) => record.cue_id);
    exports.getCuesFromSubtitle = loadIndex("subtitle_cues", exports.subtitles, exports.cues, (record) => [record.subtitle_id]);
    exports.users = loadTable("users", schema.User, (record) => record.user_id);
    exports.getUsersFromUsername = loadIndex("user_users", exports.users, exports.users, (record) => [record.username]);
    exports.keys = loadTable("keys", schema.Key, (record) => record.key_id);
    exports.getKeysFromUser = loadIndex("user_keys", exports.users, exports.keys, (record) => [record.user_id]);
    exports.tokens = loadTable("tokens", schema.Token, (record) => record.token_id);
    exports.getTokensFromUser = loadIndex("user_tokens", exports.users, exports.tokens, (record) => [record.user_id]);
    exports.streams = loadTable("streams", schema.Stream, (record) => record.stream_id);
    exports.getStreamsFromUser = loadIndex("user_streams", exports.users, exports.streams, (record) => [record.user_id]);
    exports.getStreamsFromFile = loadIndex("file_streams", exports.files, exports.streams, (record) => [record.file_id]);
    exports.playlists = loadTable("playlists", schema.Playlist, (record) => record.playlist_id);
    exports.getPlaylistsFromUser = loadIndex("user_playlists", exports.users, exports.playlists, (record) => [record.user_id]);
    exports.playlist_items = loadTable("playlist_items", schema.PlaylistItem, (record) => record.playlist_item_id);
    exports.getPlaylistsItemsFromPlaylist = loadIndex("playlist_playlist_items", exports.playlists, exports.playlist_items, (record) => [record.playlist_id]);
    exports.getPlaylistItemsFromTrack = loadIndex("track_playlist_items", exports.tracks, exports.playlist_items, (record) => [record.track_id]);
    exports.years = loadTable("years", schema.Year, (record) => record.year_id);
    exports.getMoviesFromYear = loadIndex("year_movies", exports.years, exports.movies, (record) => [record.year]);
    exports.getAlbumsFromYear = loadIndex("year_albums", exports.years, exports.albums, (record) => [record.year]);
    if (exports.getKeysFromUser.lookup(undefined).collect().length === 0) {
        exports.keys.insert({
            key_id: makeId("key", libcrypto.randomBytes(8).toString("hex"))
        });
    }
    exports.album_search = loadIndex("search_albums", exports.albums, exports.albums, (entry) => [entry.title, entry.year].filter(is.present), jdb2.Index.QUERY_TOKENIZER);
    exports.artist_search = loadIndex("search_artists", exports.artists, exports.artists, (entry) => [entry.name], jdb2.Index.QUERY_TOKENIZER);
    exports.cue_search = !config_1.default.use_cue_index ? undefined : loadIndex("search_cues", exports.cues, exports.cues, (entry) => [entry.lines], jdb2.Index.QUERY_TOKENIZER);
    exports.episode_search = loadIndex("search_episodes", exports.episodes, exports.episodes, (entry) => [entry.title, entry.year].filter(is.present), jdb2.Index.QUERY_TOKENIZER);
    exports.genre_search = loadIndex("search_genres", exports.genres, exports.genres, (entry) => [entry.name], jdb2.Index.QUERY_TOKENIZER);
    exports.movie_search = loadIndex("search_movies", exports.movies, exports.movies, (entry) => [entry.title, entry.year].filter(is.present), jdb2.Index.QUERY_TOKENIZER);
    exports.actor_search = loadIndex("search_actors", exports.actors, exports.actors, (entry) => [entry.name], jdb2.Index.QUERY_TOKENIZER);
    exports.playlist_search = loadIndex("search_playlists", exports.playlists, exports.playlists, (entry) => [entry.title], jdb2.Index.QUERY_TOKENIZER);
    exports.shows_search = loadIndex("search_shows", exports.shows, exports.shows, (entry) => [entry.name], jdb2.Index.QUERY_TOKENIZER);
    exports.track_search = loadIndex("search_tracks", exports.tracks, exports.tracks, (entry) => [entry.title], jdb2.Index.QUERY_TOKENIZER);
    exports.user_search = loadIndex("search_users", exports.users, exports.users, (entry) => [entry.name, entry.username], jdb2.Index.QUERY_TOKENIZER);
    exports.year_search = loadIndex("search_years", exports.years, exports.years, (entry) => [entry.year], jdb2.Index.QUERY_TOKENIZER);
    function getPath(entry) {
        let path = new Array();
        while (true) {
            path.unshift(entry.name);
            let parent_directory_id = entry.parent_directory_id;
            if (is.absent(parent_directory_id)) {
                break;
            }
            entry = exports.directories.lookup(parent_directory_id);
        }
        return [...config_1.default.media_path, ...path];
    }
    exports.getPath = getPath;
    ;
    function getDirectoryPath(directory) {
        return getPath(directory);
    }
    function getFilePath(file) {
        return getPath(file);
    }
    function checkFile(root) {
        let path = getFilePath(root).join("/");
        if (libfs.existsSync(path)) {
            let stats = libfs.statSync(path);
            if (stats.isFile()) {
                if (stats.mtime.valueOf() === root.index_timestamp) {
                    return;
                }
            }
        }
        exports.files.remove(root);
    }
    function checkDirectory(root) {
        let path = getDirectoryPath(root).join("/");
        if (libfs.existsSync(path)) {
            let stats = libfs.statSync(path);
            if (stats.isDirectory()) {
                for (let directory of exports.getDirectoriesFromDirectory.lookup(root.directory_id)) {
                    checkDirectory(directory);
                }
                for (let file of exports.getFilesFromDirectory.lookup(root.directory_id)) {
                    checkFile(file);
                }
                return;
            }
        }
        exports.directories.remove(root);
    }
    function visitDirectory(path, parent_directory_id) {
        let dirents = libfs.readdirSync(path.join("/"), { withFileTypes: true });
        for (let dirent of dirents) {
            let name = dirent.name;
            if (dirent.isDirectory()) {
                let directory_id = makeId("directory", parent_directory_id, name);
                try {
                    exports.directories.lookup(directory_id);
                }
                catch (error) {
                    exports.directories.insert({
                        directory_id,
                        name,
                        parent_directory_id
                    });
                }
                visitDirectory([...path, dirent.name], directory_id);
            }
            else if (dirent.isFile()) {
                let file_id = makeId("file", parent_directory_id, name);
                try {
                    exports.files.lookup(file_id);
                }
                catch (error) {
                    exports.files.insert({
                        file_id,
                        name,
                        parent_directory_id
                    });
                }
            }
        }
    }
    function indexMetadata(probe, ...file_ids) {
        let metadata = probe.metadata;
        if (probes.schema.EpisodeMetadata.is(metadata)) {
            let show_id = makeId("show", metadata.show.title);
            exports.shows.insert({
                show_id: show_id,
                name: metadata.show.title,
                summary: metadata.show.summary
            });
            let season_id = makeId("season", show_id, `${metadata.season}`);
            exports.seasons.insert({
                season_id: season_id,
                show_id: show_id,
                number: metadata.season
            });
            let episode_id = makeId("episode", season_id, `${metadata.episode}`);
            exports.episodes.insert({
                episode_id: episode_id,
                season_id: season_id,
                title: metadata.title,
                number: metadata.episode,
                year: metadata.year,
                summary: metadata.summary
            });
            for (let file_id of file_ids) {
                exports.episode_files.insert({
                    episode_id: episode_id,
                    file_id: file_id
                });
            }
            for (let [index, actor] of metadata.show.actors.entries()) {
                let actor_id = makeId("actor", actor);
                exports.actors.insert({
                    actor_id: actor_id,
                    name: actor
                });
                exports.show_actors.insert({
                    actor_id: actor_id,
                    show_id: show_id,
                    order: index
                });
            }
            for (let [index, genre] of metadata.show.genres.entries()) {
                let genre_id = makeId("genre", genre);
                exports.genres.insert({
                    genre_id: genre_id,
                    name: genre
                });
                exports.show_genres.insert({
                    genre_id: genre_id,
                    show_id: show_id,
                    order: index
                });
            }
        }
        else if (probes.schema.MovieMetadata.is(metadata)) {
            let movie_id = makeId("movie", metadata.title, metadata.year);
            exports.movies.insert({
                movie_id: movie_id,
                title: metadata.title,
                year: metadata.year,
                summary: metadata.summary
            });
            if (is.present(metadata.year)) {
                let year_id = makeId("year", metadata.year);
                exports.years.insert({
                    year_id: year_id,
                    year: metadata.year
                });
            }
            for (let file_id of file_ids) {
                exports.movie_files.insert({
                    movie_id: movie_id,
                    file_id: file_id
                });
            }
            for (let [index, actor] of metadata.actors.entries()) {
                let actor_id = makeId("actor", actor);
                exports.actors.insert({
                    actor_id: actor_id,
                    name: actor
                });
                exports.movie_actors.insert({
                    actor_id: actor_id,
                    movie_id: movie_id,
                    order: index
                });
            }
            for (let [index, genre] of metadata.genres.entries()) {
                let genre_id = makeId("genre", genre);
                exports.genres.insert({
                    genre_id: genre_id,
                    name: genre
                });
                exports.movie_genres.insert({
                    genre_id: genre_id,
                    movie_id: movie_id,
                    order: index
                });
            }
        }
        else if (probes.schema.TrackMetadata.is(metadata)) {
            let album_id = makeId("album", metadata.album.title, metadata.album.year);
            exports.albums.insert({
                album_id: album_id,
                title: metadata.album.title,
                year: metadata.album.year
            });
            if (is.present(metadata.album.year)) {
                let year_id = makeId("year", metadata.album.year);
                exports.years.insert({
                    year_id: year_id,
                    year: metadata.album.year
                });
            }
            for (let [index, artist] of metadata.album.artists.entries()) {
                let artist_id = makeId("artist", artist.title);
                exports.artists.insert({
                    artist_id: artist_id,
                    name: artist.title
                });
                exports.album_artists.insert({
                    album_id: album_id,
                    artist_id: artist_id,
                    order: index
                });
            }
            let disc_id = makeId("disc", album_id, `${metadata.disc}`);
            exports.discs.insert({
                disc_id: disc_id,
                album_id: album_id,
                number: metadata.disc
            });
            let track_id = makeId("track", disc_id, `${metadata.track}`);
            exports.tracks.insert({
                track_id: track_id,
                disc_id: disc_id,
                title: metadata.title,
                number: metadata.track
            });
            for (let file_id of file_ids) {
                exports.track_files.insert({
                    track_id: track_id,
                    file_id: file_id
                });
            }
            for (let [index, artist] of metadata.artists.entries()) {
                let artist_id = makeId("artist", artist.title);
                exports.artists.insert({
                    artist_id: artist_id,
                    name: artist.title
                });
                exports.track_artists.insert({
                    track_id: track_id,
                    artist_id: artist_id,
                    order: index
                });
            }
        }
    }
    function indexFile(file) {
        let file_id = file.file_id;
        let path = getFilePath(file);
        let fd = libfs.openSync(path.join("/"), "r");
        try {
            let probe = {
                resources: []
            };
            if (file.name.endsWith(".vtt")) {
                probe = probes.vtt.probe(fd);
                let subtitle_resources = probe.resources.filter((resource) => resource.type === "subtitle");
                let subtitle_resource = subtitle_resources.shift();
                if (is.present(subtitle_resource)) {
                    exports.subtitle_files.insert({
                        file_id: file_id,
                        mime: "text/vtt",
                        duration_ms: subtitle_resource.duration_ms,
                        language: subtitle_resource.language
                    });
                    let subtitle_id = makeId("subtitle", file.file_id);
                    exports.subtitles.insert({
                        subtitle_id: subtitle_id,
                        file_id: file.file_id
                    });
                    for (let cue of subtitle_resource.cues) {
                        let cue_id = makeId("cue", subtitle_id, `${cue.start_ms}`);
                        exports.cues.insert({
                            cue_id: cue_id,
                            subtitle_id: subtitle_id,
                            start_ms: cue.start_ms,
                            duration_ms: cue.duration_ms,
                            lines: cue.lines.join("\n")
                        });
                    }
                }
            }
            else if (file.name.endsWith(".json")) {
                probe = probes.json.probe(fd);
                let metadata_resources = probe.resources.filter((resource) => resource.type === "metadata");
                let metadata_resource = metadata_resources.shift();
                if (is.present(metadata_resource)) {
                    exports.metadata_files.insert({
                        file_id: file_id,
                        mime: "application/json"
                    });
                }
            }
            else if (file.name.endsWith(".mp3")) {
                probe = probes.mp3.probe(fd);
                let audio_resources = probe.resources.filter((resource) => resource.type === "audio");
                let audio_resource = audio_resources.shift();
                if (is.present(audio_resource)) {
                    exports.audio_files.insert({
                        file_id: file_id,
                        mime: "audio/mp3",
                        duration_ms: audio_resource.duration_ms
                    });
                }
            }
            else if (file.name.endsWith(".mp4")) {
                probe = probes.mp4.probe(fd);
                let audio_resources = probe.resources.filter((resource) => resource.type === "audio");
                let video_resources = probe.resources.filter((resource) => resource.type === "video");
                let audio_resource = audio_resources.shift();
                let video_resource = video_resources.shift();
                if (is.present(video_resource)) {
                    exports.video_files.insert({
                        file_id: file_id,
                        mime: "video/mp4",
                        duration_ms: video_resource.duration_ms,
                        width: video_resource.width,
                        height: video_resource.height
                    });
                }
                else if (is.present(audio_resource)) {
                    exports.audio_files.insert({
                        file_id: file_id,
                        mime: "audio/mp4",
                        duration_ms: audio_resource.duration_ms
                    });
                }
            }
            else if (file.name.endsWith(".jpg") || file.name.endsWith(".jpeg")) {
                probe = probes.jpeg.probe(fd);
                let image_resources = probe.resources.filter((resource) => resource.type === "image");
                let image_resource = image_resources.shift();
                if (is.present(image_resource)) {
                    exports.image_files.insert({
                        file_id: file_id,
                        mime: "image/jpeg",
                        width: image_resource.width,
                        height: image_resource.height
                    });
                }
            }
            indexMetadata(probe, file_id);
        }
        catch (error) {
            console.log(`Indexing failed for "${path.join("/")}"!`);
        }
        libfs.closeSync(fd);
        let stats = libfs.statSync(path.join("/"));
        file.index_timestamp = stats.mtime.valueOf();
        exports.files.update(file);
    }
    function indexFiles() {
        for (let file of exports.files) {
            if (is.absent(file.index_timestamp)) {
                console.log(`Indexing ${file.name}...`);
                indexFile(file);
            }
        }
    }
    function getSiblingFiles(subject) {
        let candidates_in_directory = exports.getFilesFromDirectory.lookup(subject.parent_directory_id)
            .sort(indices.LexicalSort.increasing((file) => file.name))
            .map((file) => {
            try {
                exports.audio_files.lookup(file.file_id);
                return file;
            }
            catch (error) { }
            try {
                exports.video_files.lookup(file.file_id);
                return file;
            }
            catch (error) { }
        })
            .include(is.present)
            .collect();
        let basename = subject.name.split(".")[0];
        let candidates_sharing_basename = candidates_in_directory
            .filter((file) => file.name.split(".")[0] === basename);
        if (candidates_sharing_basename.length > 0) {
            return candidates_sharing_basename;
        }
        else {
            return candidates_in_directory;
        }
    }
    function associateMetadata() {
        for (let metadata_file of exports.metadata_files) {
            let file = exports.files.lookup(metadata_file.file_id);
            let path = getFilePath(file);
            let fd = libfs.openSync(path.join("/"), "r");
            let probe = probes.json.probe(fd);
            libfs.closeSync(fd);
            let siblings = getSiblingFiles(file);
            indexMetadata(probe, ...siblings.map((file) => file.file_id));
        }
    }
    function associateImages() {
        for (let image_file of exports.image_files) {
            let file = exports.files.lookup(image_file.file_id);
            let siblings = getSiblingFiles(file);
            for (let sibling of siblings) {
                let track_files = exports.getTracksFromFile.lookup(sibling.file_id)
                    .filter((track_file) => track_file.file_id !== image_file.file_id);
                for (let track_file of track_files) {
                    try {
                        let track = exports.tracks.lookup(track_file.track_id);
                        let disc = exports.discs.lookup(track.disc_id);
                        let album = exports.albums.lookup(disc.album_id);
                        exports.album_files.insert({
                            album_id: album.album_id,
                            file_id: image_file.file_id
                        });
                    }
                    catch (error) { }
                }
                let movies = exports.getMoviesFromFile.lookup(sibling.file_id)
                    .filter((movie_file) => movie_file.file_id !== image_file.file_id);
                for (let movie of movies) {
                    exports.movie_files.insert({
                        movie_id: movie.movie_id,
                        file_id: image_file.file_id
                    });
                }
                let episode_files = exports.getEpisodesFromFile.lookup(sibling.file_id)
                    .filter((episode_file) => episode_file.file_id !== image_file.file_id);
                for (let episode_file of episode_files) {
                    try {
                        let episode = exports.episodes.lookup(episode_file.episode_id);
                        let season = exports.seasons.lookup(episode.season_id);
                        let show = exports.shows.lookup(season.show_id);
                        exports.show_files.insert({
                            show_id: show.show_id,
                            file_id: image_file.file_id
                        });
                    }
                    catch (error) { }
                }
            }
        }
    }
    function associateSubtitles() {
        for (let subtitle_file of exports.subtitle_files) {
            let file = exports.files.lookup(subtitle_file.file_id);
            let basename = file.name.split(".")[0];
            let siblings = getSiblingFiles(file)
                .filter((file) => file.name.split(".")[0] === basename);
            for (let sibling of siblings) {
                exports.video_subtitles.insert({
                    video_file_id: sibling.file_id,
                    subtitle_file_id: file.file_id
                });
            }
        }
    }
    function runIndexer() {
        console.log(`Running indexer...`);
        for (let directory of exports.getDirectoriesFromDirectory.lookup(undefined)) {
            checkDirectory(directory);
        }
        for (let file of exports.getFilesFromDirectory.lookup(undefined)) {
            checkFile(file);
        }
        visitDirectory(config_1.default.media_path);
        indexFiles();
        associateMetadata();
        associateImages();
        associateSubtitles();
        for (let token of exports.tokens) {
            if (token.expires_ms <= Date.now()) {
                exports.tokens.remove(token);
            }
        }
        console.log(`Indexing finished.`);
        if (global.gc) {
            global.gc();
            let mbs = process.memoryUsage().heapUsed / 1024 / 1024;
            console.log(`Memory usage: ${mbs.toFixed()} MB`);
        }
    }
    exports.runIndexer = runIndexer;
    ;
    runIndexer();
});
define("build/server/passwords", ["require", "exports", "crypto"], function (require, exports, libcrypto) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.verify = exports.generate = void 0;
    function generate(password) {
        let cost = 14;
        let blockSize = 8;
        let paralellization = 1;
        let salt = libcrypto.randomBytes(16);
        let password_hash = libcrypto.scryptSync(password, salt, 32, {
            N: (1 << cost),
            r: blockSize,
            p: paralellization,
            maxmem: (256 << cost) * blockSize
        });
        let params = Buffer.alloc(4);
        params[0] = (cost >> 8);
        params[1] = (cost >> 0);
        params[2] = (blockSize >> 0);
        params[3] = (paralellization >> 0);
        return `$s0$${params.toString("hex")}$${salt.toString("base64")}$${password_hash.toString("base64")}`;
    }
    exports.generate = generate;
    function verify(password, chunk) {
        let parts = /^\$s0\$([0-9a-fA-F]{8})\$([A-Za-z0-9+/]{22}==)\$([A-Za-z0-9+/]{43}=)$/.exec(chunk);
        if (parts == null) {
            throw `Expected a valid scrypt chunk!`;
        }
        let parameters = Buffer.from(parts[1], "hex");
        let salt = Buffer.from(parts[2], "base64");
        let hash = Buffer.from(parts[3], "base64");
        let cost = (parameters[0] << 8) | (parameters[1] << 0);
        let blockSize = (parameters[2] << 0);
        let paralellization = (parameters[3] << 0);
        let password_hash = libcrypto.scryptSync(password, salt, 32, {
            N: (1 << cost),
            r: blockSize,
            p: paralellization,
            maxmem: (256 << cost) * blockSize
        });
        return libcrypto.timingSafeEqual(hash, password_hash);
    }
    exports.verify = verify;
});
define("build/server/auth", ["require", "exports", "crypto", "build/database/indexer", "build/server/passwords"], function (require, exports, libcrypto, indexer, passwords) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getUserId = exports.createToken = void 0;
    function generate_token(user_id) {
        let selector = libcrypto.randomBytes(8);
        let validator = libcrypto.randomBytes(8);
        let hash = libcrypto.createHash('sha256');
        hash.update(validator);
        let validator_hash = hash.digest('hex');
        indexer.tokens.insert({
            token_id: selector.toString('hex'),
            user_id: user_id,
            hash: validator_hash,
            expires_ms: Date.now() + (7 * 24 * 60 * 60 * 1000)
        });
        return `${selector.toString('hex')}${validator.toString('hex')}`;
    }
    function createToken(username, password) {
        let users = indexer.getUsersFromUsername.lookup(username).collect();
        let user = users.shift();
        if (!user) {
            throw ``;
        }
        if (!passwords.verify(password, user.password)) {
            throw `Expected a valid password!`;
        }
        return generate_token(user.user_id);
    }
    exports.createToken = createToken;
    function getUserId(chunk) {
        let parts = /^([0-9a-f]{16})([0-9a-f]{16})$/.exec(chunk);
        if (!parts) {
            throw new Error();
        }
        let selector = parts[1];
        let validator = parts[2];
        let token = indexer.tokens.lookup(selector);
        if (token.expires_ms < Date.now()) {
            throw `Token has expired!`;
        }
        let hash = libcrypto.createHash('sha256');
        hash.update(Buffer.from(validator, 'hex'));
        let validator_hash = hash.digest();
        if (!libcrypto.timingSafeEqual(Buffer.from(token.hash, 'hex'), validator_hash)) {
            throw new Error();
        }
        let expires_ms = Date.now() + (7 * 24 * 60 * 60 * 1000);
        indexer.tokens.update({
            ...token,
            expires_ms
        });
        return token.user_id;
    }
    exports.getUserId = getUserId;
});
define("build/api/handler", ["require", "exports", "crypto", "build/server/auth", "build/server/passwords", "build/database/indexer", "build/jsondb/index", "build/is", "build/config/index"], function (require, exports, libcrypto, auth, passwords, database, jsondb, is, config_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getArtistAppearances = exports.searchForEntities = exports.searchForYears = exports.searchForUsers = exports.searchForTracks = exports.searchForShows = exports.searchForSeasons = exports.searchForPlaylists = exports.searchForActors = exports.searchForMovies = exports.searchForGenres = exports.searchForEpisodes = exports.searchForDiscs = exports.searchForCues = exports.searchForArtists = exports.searchForAlbums = exports.lookupYear = exports.lookupYearBase = exports.lookupUser = exports.lookupUserBase = exports.lookupTrack = exports.lookupTrackBase = exports.lookupSubtitle = exports.lookupSubtitleBase = exports.lookupShow = exports.lookupShowBase = exports.lookupSeason = exports.lookupSeasonBase = exports.lookupPlaylistItem = exports.lookupPlaylistItemBase = exports.lookupPlaylist = exports.lookupPlaylistBase = exports.lookupActor = exports.lookupActorBase = exports.lookupMovie = exports.lookupMovieBase = exports.lookupGenre = exports.lookupGenreBase = exports.lookupEpisode = exports.lookupEpisodeBase = exports.lookupDisc = exports.lookupDiscBase = exports.lookupCue = exports.lookupCueBase = exports.lookupArtist = exports.lookupArtistBase = exports.lookupAlbum = exports.lookupAlbumBase = exports.createUser = exports.getStreamWeight = void 0;
    exports.getAlbumsFromYear = exports.getMoviesFromYear = exports.getUserShows = exports.getUserAlbums = exports.getUserPlaylists = exports.getShowsFromActor = exports.getShowsFromGenre = exports.getMoviesFromActor = exports.getMoviesFromGenre = exports.getMovieSuggestions = exports.getPlaylistAppearances = exports.getArtistTracks = void 0;
    function getStreamWeight(timestamp_ms) {
        let ms = Date.now() - timestamp_ms;
        let weeks = ms / (1000 * 60 * 60 * 24 * 7);
        return Math.pow(0.5, weeks);
    }
    exports.getStreamWeight = getStreamWeight;
    ;
    function createUser(request) {
        let { username, password, name, key_id } = { ...request };
        let errors = new Array();
        if (database.getUsersFromUsername.lookup(username).collect().length > 0) {
            errors.push(`The requested username is not available.`);
        }
        try {
            let key = database.keys.lookup(key_id);
            if (is.present(key.user_id)) {
                errors.push(`The registration key has already been used.`);
            }
        }
        catch (error) {
            errors.push(`The registration key is not valid.`);
        }
        if (Buffer.from(username).length >= 256) {
            errors.push(`The username is too long!`);
        }
        if (Buffer.from(name).length >= 256) {
            errors.push(`The name is too long!`);
        }
        if (errors.length > 0) {
            return {
                errors
            };
        }
        let user_id = libcrypto.randomBytes(8).toString("hex");
        database.users.insert({
            user_id,
            username,
            name,
            password: passwords.generate(password)
        });
        let key = database.keys.lookup(key_id);
        database.keys.update({
            ...key,
            user_id
        });
        let token = auth.createToken(username, password);
        return {
            token
        };
    }
    exports.createUser = createUser;
    ;
    function lookupAlbumBase(album_id, user_id) {
        let album = database.albums.lookup(album_id);
        return {
            album_id: album.album_id,
            title: config_1.default.use_demo_mode ? "Album title" : album.title,
            artwork: database.getFilesFromAlbum.lookup(album_id)
                .map((record) => {
                try {
                    return database.image_files.lookup(record.file_id);
                }
                catch (error) { }
            })
                .include(is.present)
                .collect()
        };
    }
    exports.lookupAlbumBase = lookupAlbumBase;
    ;
    function lookupAlbum(album_id, user_id) {
        let record = database.albums.lookup(album_id);
        let album = lookupAlbumBase(album_id, user_id);
        return {
            ...album,
            artists: database.getArtistsFromAlbum.lookup(album_id)
                .sort(jsondb.NumericSort.increasing((record) => record.order))
                .map((record) => lookupArtistBase(record.artist_id, user_id))
                .collect(),
            year: record.year,
            discs: database.getDiscsFromAlbum.lookup(album_id)
                .sort(jsondb.NumericSort.increasing((record) => record.number))
                .map((record) => lookupDisc(record.disc_id, user_id, album))
                .collect()
        };
    }
    exports.lookupAlbum = lookupAlbum;
    ;
    function lookupArtistBase(artist_id, user_id) {
        let artist = database.artists.lookup(artist_id);
        return {
            artist_id: artist.artist_id,
            title: config_1.default.use_demo_mode ? "Artist name" : artist.name
        };
    }
    exports.lookupArtistBase = lookupArtistBase;
    ;
    function lookupArtist(artist_id, user_id) {
        let artist = lookupArtistBase(artist_id, user_id);
        return {
            ...artist,
            albums: database.getAlbumsFromArtist.lookup(artist_id)
                .map((record) => database.albums.lookup(record.album_id))
                .sort(jsondb.NumericSort.decreasing((record) => record.year))
                .map((record) => lookupAlbum(record.album_id, user_id))
                .collect()
        };
    }
    exports.lookupArtist = lookupArtist;
    ;
    function lookupCueBase(cue_id, user_id, subtitle) {
        let cue = database.cues.lookup(cue_id);
        return {
            cue_id: cue.cue_id,
            subtitle: is.present(subtitle) ? subtitle : lookupSubtitleBase(cue.subtitle_id, user_id),
            start_ms: cue.start_ms,
            duration_ms: cue.duration_ms,
            lines: cue.lines.split("\n")
        };
    }
    exports.lookupCueBase = lookupCueBase;
    ;
    function lookupCue(cue_id, user_id, subtitle) {
        let cue = lookupCueBase(cue_id, user_id, subtitle);
        let medias = database.getVideoFilesFromSubtitleFile.lookup(cue.subtitle.subtitle.file_id)
            .map((video_subtitle) => {
            try {
                let episode_files = database.getEpisodesFromFile.lookup(video_subtitle.video_file_id);
                for (let episode_file of episode_files) {
                    return lookupEpisode(episode_file.episode_id, user_id);
                }
            }
            catch (error) { }
            try {
                let movie_files = database.getMoviesFromFile.lookup(video_subtitle.video_file_id);
                for (let movie_file of movie_files) {
                    return lookupMovie(movie_file.movie_id, user_id);
                }
            }
            catch (error) { }
        })
            .include(is.present)
            .collect();
        let media = medias.shift();
        if (is.absent(media)) {
            throw `Expected a media entity!`;
        }
        return {
            ...cue,
            media
        };
    }
    exports.lookupCue = lookupCue;
    ;
    function lookupDiscBase(disc_id, user_id, album) {
        let disc = database.discs.lookup(disc_id);
        return {
            disc_id: disc.disc_id,
            album: is.present(album) ? album : lookupAlbumBase(disc.album_id, user_id),
            number: disc.number
        };
    }
    exports.lookupDiscBase = lookupDiscBase;
    ;
    function lookupDisc(disc_id, user_id, album) {
        let disc = lookupDiscBase(disc_id, user_id, album);
        return {
            ...disc,
            tracks: database.getTracksFromDisc.lookup(disc_id)
                .sort(jsondb.NumericSort.increasing((record) => record.number))
                .map((record) => lookupTrack(record.track_id, user_id, disc))
                .collect()
        };
    }
    exports.lookupDisc = lookupDisc;
    ;
    function lookupEpisodeBase(episode_id, user_id, season) {
        let episode = database.episodes.lookup(episode_id);
        return {
            episode_id: episode.episode_id,
            title: config_1.default.use_demo_mode ? "Episode title" : episode.title,
            number: episode.number,
            season: is.present(season) ? season : lookupSeasonBase(episode.season_id, user_id)
        };
    }
    exports.lookupEpisodeBase = lookupEpisodeBase;
    ;
    function lookupEpisode(episode_id, user_id, season) {
        let episode = lookupEpisodeBase(episode_id, user_id, season);
        let record = database.episodes.lookup(episode_id);
        let files = database.getFilesFromEpisode.lookup(episode_id)
            .map((record) => {
            try {
                return database.video_files.lookup(record.file_id);
            }
            catch (error) { }
        })
            .include(is.present)
            .sort(jsondb.NumericSort.decreasing((record) => record.height))
            .collect();
        let media = files.shift();
        if (is.absent(media)) {
            throw `Expected a valid video file!`;
        }
        let subtitles = database.getSubtitleFilesFromVideoFile.lookup(media.file_id)
            .map((record) => database.subtitle_files.lookup(record.subtitle_file_id))
            .collect();
        let streams = database.getStreamsFromFile.lookup(media.file_id)
            .filter((stream) => stream.user_id === user_id)
            .sort((jsondb.NumericSort.increasing((stream) => stream.timestamp_ms)))
            .collect();
        return {
            ...episode,
            year: record.year,
            summary: config_1.default.use_demo_mode ? "Episode summary." : record.summary,
            last_stream_date: streams.pop()?.timestamp_ms,
            media: media,
            subtitles: subtitles
        };
    }
    exports.lookupEpisode = lookupEpisode;
    ;
    function lookupGenreBase(genre_id, user_id) {
        let genre = database.genres.lookup(genre_id);
        return {
            genre_id: genre.genre_id,
            title: genre.name
        };
    }
    exports.lookupGenreBase = lookupGenreBase;
    ;
    function lookupGenre(genre_id, user_id) {
        let genre = lookupGenreBase(genre_id, user_id);
        return {
            ...genre
        };
    }
    exports.lookupGenre = lookupGenre;
    ;
    function lookupMovieBase(movie_id, user_id) {
        let movie = database.movies.lookup(movie_id);
        return {
            movie_id: movie.movie_id,
            title: config_1.default.use_demo_mode ? "Movie title" : movie.title,
            artwork: database.getFilesFromMovie.lookup(movie_id)
                .map((record) => {
                try {
                    return database.image_files.lookup(record.file_id);
                }
                catch (error) { }
            })
                .include(is.present)
                .collect()
        };
    }
    exports.lookupMovieBase = lookupMovieBase;
    ;
    function lookupMovie(movie_id, user_id) {
        let movie = lookupMovieBase(movie_id, user_id);
        let record = database.movies.lookup(movie_id);
        let files = database.getFilesFromMovie.lookup(movie_id)
            .map((record) => {
            try {
                return database.video_files.lookup(record.file_id);
            }
            catch (error) { }
        })
            .include(is.present)
            .sort(jsondb.NumericSort.decreasing((record) => record.height))
            .collect();
        let media = files.shift();
        if (is.absent(media)) {
            throw `Expected a valid video file!`;
        }
        let subtitles = database.getSubtitleFilesFromVideoFile.lookup(media.file_id)
            .map((record) => database.subtitle_files.lookup(record.subtitle_file_id))
            .collect();
        let streams = database.getStreamsFromFile.lookup(media.file_id)
            .filter((stream) => stream.user_id === user_id)
            .sort((jsondb.NumericSort.increasing((stream) => stream.timestamp_ms)))
            .collect();
        return {
            ...movie,
            year: record.year,
            summary: config_1.default.use_demo_mode ? "Movie summary." : record.summary,
            genres: database.getGenresFromMovie.lookup(movie_id)
                .sort(jsondb.NumericSort.increasing((record) => record.order))
                .map((record) => lookupGenreBase(record.genre_id, user_id))
                .collect(),
            actors: database.getActorsFromMovie.lookup(movie_id)
                .sort(jsondb.NumericSort.increasing((record) => record.order))
                .map((record) => lookupActor(record.actor_id, user_id))
                .collect(),
            last_stream_date: streams.pop()?.timestamp_ms,
            media: media,
            subtitles: subtitles
        };
    }
    exports.lookupMovie = lookupMovie;
    ;
    function lookupActorBase(actor_id, user_id) {
        let actor = database.actors.lookup(actor_id);
        return {
            actor_id: actor.actor_id,
            name: config_1.default.use_demo_mode ? "Actor name" : actor.name
        };
    }
    exports.lookupActorBase = lookupActorBase;
    ;
    function lookupActor(actor_id, user_id) {
        let actor = lookupActorBase(actor_id, user_id);
        return {
            ...actor
        };
    }
    exports.lookupActor = lookupActor;
    ;
    function lookupPlaylistBase(playlist_id, user_id, user) {
        let playlist = database.playlists.lookup(playlist_id);
        return {
            playlist_id: playlist.playlist_id,
            title: playlist.title,
            description: playlist.description,
            user: is.present(user) ? user : lookupUserBase(playlist.user_id)
        };
    }
    exports.lookupPlaylistBase = lookupPlaylistBase;
    ;
    function lookupPlaylist(playlist_id, user_id, user) {
        let playlist = lookupPlaylistBase(playlist_id, user_id, user);
        return {
            ...playlist,
            items: database.getPlaylistsItemsFromPlaylist.lookup(playlist_id)
                .sort(jsondb.NumericSort.increasing((record) => record.number))
                .map((record) => lookupPlaylistItem(record.playlist_item_id, user_id, playlist))
                .collect()
        };
    }
    exports.lookupPlaylist = lookupPlaylist;
    ;
    function lookupPlaylistItemBase(playlist_item_id, user_id, playlist) {
        let playlist_item = database.playlist_items.lookup(playlist_item_id);
        return {
            playlist_item_id: playlist_item.playlist_item_id,
            number: playlist_item.number,
            playlist: is.present(playlist) ? playlist : lookupPlaylistBase(playlist_item.playlist_id, user_id),
            track: lookupTrack(playlist_item.track_id, user_id)
        };
    }
    exports.lookupPlaylistItemBase = lookupPlaylistItemBase;
    ;
    function lookupPlaylistItem(playlist_item_id, user_id, playlist) {
        let playlist_item = lookupPlaylistItemBase(playlist_item_id, user_id, playlist);
        return {
            ...playlist_item
        };
    }
    exports.lookupPlaylistItem = lookupPlaylistItem;
    ;
    function lookupSeasonBase(season_id, user_id, show) {
        let season = database.seasons.lookup(season_id);
        return {
            season_id: season.season_id,
            number: season.number,
            show: is.present(show) ? show : lookupShowBase(season.show_id, user_id)
        };
    }
    exports.lookupSeasonBase = lookupSeasonBase;
    ;
    function lookupSeason(season_id, user_id, show) {
        let season = lookupSeasonBase(season_id, user_id, show);
        return {
            ...season,
            episodes: database.getEpisodesFromSeason.lookup(season_id)
                .sort(jsondb.NumericSort.increasing((record) => record.number))
                .map((record) => lookupEpisode(record.episode_id, user_id, season))
                .collect()
        };
    }
    exports.lookupSeason = lookupSeason;
    ;
    function lookupShowBase(show_id, user_id) {
        let show = database.shows.lookup(show_id);
        return {
            show_id: show.show_id,
            title: config_1.default.use_demo_mode ? "Show title" : show.name,
            artwork: database.getFilesFromShow.lookup(show_id)
                .map((record) => {
                try {
                    return database.image_files.lookup(record.file_id);
                }
                catch (error) { }
            })
                .include(is.present)
                .slice(0, 1)
                .collect()
        };
    }
    exports.lookupShowBase = lookupShowBase;
    ;
    function lookupShow(show_id, user_id) {
        let show = lookupShowBase(show_id, user_id);
        let record = database.shows.lookup(show_id);
        return {
            ...show,
            summary: config_1.default.use_demo_mode ? "Show summary." : record.summary,
            genres: database.getGenresFromShow.lookup(show_id)
                .sort(jsondb.NumericSort.increasing((record) => record.order))
                .map((record) => lookupGenreBase(record.genre_id, user_id))
                .collect(),
            actors: database.getActorsFromShow.lookup(show_id)
                .sort(jsondb.NumericSort.increasing((record) => record.order))
                .map((record) => lookupActorBase(record.actor_id, user_id))
                .collect(),
            seasons: database.getSeasonsFromShow.lookup(show_id)
                .sort(jsondb.NumericSort.increasing((record) => record.number))
                .map((record) => lookupSeason(record.season_id, user_id, show))
                .collect()
        };
    }
    exports.lookupShow = lookupShow;
    ;
    function lookupSubtitleBase(subtitle_id, user_id) {
        let subtitle = database.subtitles.lookup(subtitle_id);
        return {
            subtitle_id: subtitle.subtitle_id,
            subtitle: database.subtitle_files.lookup(subtitle.file_id)
        };
    }
    exports.lookupSubtitleBase = lookupSubtitleBase;
    ;
    function lookupSubtitle(subtitle_id, user_id) {
        let subtitle = lookupSubtitleBase(subtitle_id, user_id);
        return {
            ...subtitle,
            cues: database.getCuesFromSubtitle.lookup(subtitle_id)
                .map((record) => lookupCue(record.cue_id, user_id))
                .sort(jsondb.NumericSort.increasing((record) => record.start_ms))
                .collect()
        };
    }
    exports.lookupSubtitle = lookupSubtitle;
    ;
    function lookupTrackBase(track_id, user_id, disc) {
        let track = database.tracks.lookup(track_id);
        return {
            track_id: track.track_id,
            title: config_1.default.use_demo_mode ? "Track title" : track.title,
            disc: is.present(disc) ? disc : lookupDiscBase(track.disc_id, user_id),
            number: track.number
        };
    }
    exports.lookupTrackBase = lookupTrackBase;
    ;
    function lookupTrack(track_id, user_id, disc) {
        let track = lookupTrackBase(track_id, user_id, disc);
        let files = database.getFilesFromTrack.lookup(track_id)
            .map((record) => {
            try {
                return database.audio_files.lookup(record.file_id);
            }
            catch (error) { }
        })
            .include(is.present)
            .collect();
        let media = files.shift();
        if (is.absent(media)) {
            throw `Expected a valid audio file!`;
        }
        let streams = database.getStreamsFromFile.lookup(media.file_id)
            .filter((stream) => stream.user_id === user_id)
            .sort((jsondb.NumericSort.increasing((stream) => stream.timestamp_ms)))
            .collect();
        return {
            ...track,
            artists: database.getArtistsFromTrack.lookup(track_id)
                .sort(jsondb.NumericSort.increasing((record) => record.order))
                .map((record) => lookupArtistBase(record.artist_id, user_id))
                .collect(),
            last_stream_date: streams.pop()?.timestamp_ms,
            media: media
        };
    }
    exports.lookupTrack = lookupTrack;
    ;
    function lookupUserBase(user_id) {
        let user = database.users.lookup(user_id);
        return {
            user_id: user.user_id,
            name: user.name,
            username: user.username
        };
    }
    exports.lookupUserBase = lookupUserBase;
    ;
    function lookupUser(user_id) {
        let user = lookupUserBase(user_id);
        return {
            ...user
        };
    }
    exports.lookupUser = lookupUser;
    ;
    function lookupYearBase(year_id, user_id) {
        let year = database.years.lookup(year_id);
        return {
            year_id: year.year_id,
            year: year.year
        };
    }
    exports.lookupYearBase = lookupYearBase;
    ;
    function lookupYear(year_id, user_id) {
        let year = lookupYearBase(year_id, user_id);
        return {
            ...year
        };
    }
    exports.lookupYear = lookupYear;
    ;
    function searchForAlbums(query, offset, length, user_id) {
        if (query === "") {
            return Array.from(database.albums)
                .sort(jsondb.LexicalSort.increasing((record) => record.title))
                .slice(offset, offset + length)
                .map((record) => lookupAlbum(record.album_id, user_id));
        }
        else {
            return database.album_search.search(query)
                .slice(offset, offset + length)
                .map((record) => record.lookup().album_id)
                .map((id) => lookupAlbum(id, user_id))
                .collect();
        }
    }
    exports.searchForAlbums = searchForAlbums;
    ;
    function searchForArtists(query, offset, length, user_id) {
        if (query === "") {
            return Array.from(database.artists)
                .map((artist) => ({
                artist,
                albums: database.getAlbumsFromArtist.lookup(artist.artist_id).collect()
            }))
                .sort(jsondb.CombinedSort.of(jsondb.CustomSort.increasing((entry) => entry.albums.length === 0), jsondb.LexicalSort.increasing((entry) => entry.artist.name)))
                .map((entry) => entry.artist)
                .slice(offset, offset + length)
                .map((record) => lookupArtist(record.artist_id, user_id));
        }
        else {
            return database.artist_search.search(query)
                .slice(offset, offset + length)
                .map((record) => record.lookup().artist_id)
                .map((id) => lookupArtist(id, user_id))
                .collect();
        }
    }
    exports.searchForArtists = searchForArtists;
    ;
    function searchForCues(query, offset, limit, user_id) {
        return is.absent(database.cue_search) ? [] : database.cue_search.search(query)
            .slice(offset, offset + limit)
            .map((record) => lookupCue(record.lookup().cue_id, user_id))
            .map((cue) => {
            let video_files = database.getVideoFilesFromSubtitleFile.lookup(cue.subtitle.subtitle.file_id);
            for (let video_file of video_files) {
                try {
                    let episode_files = database.getEpisodesFromFile.lookup(video_file.video_file_id);
                    for (let episode_file of episode_files) {
                        return {
                            ...cue,
                            media: lookupEpisode(episode_file.episode_id, user_id)
                        };
                    }
                }
                catch (error) { }
                try {
                    let movie_files = database.getMoviesFromFile.lookup(video_file.video_file_id);
                    for (let movie_file of movie_files) {
                        return {
                            ...cue,
                            media: lookupMovie(movie_file.movie_id, user_id)
                        };
                    }
                }
                catch (error) { }
            }
        })
            .include(is.present)
            .collect();
    }
    exports.searchForCues = searchForCues;
    ;
    function searchForDiscs(query, offset, length, user_id) {
        return Array.from(database.discs)
            .sort(jsondb.LexicalSort.increasing((record) => record.disc_id))
            .slice(offset, offset + length)
            .map((record) => lookupDisc(record.disc_id, user_id));
    }
    exports.searchForDiscs = searchForDiscs;
    ;
    function searchForEpisodes(query, offset, length, user_id) {
        if (query === "") {
            return Array.from(database.episodes)
                .sort(jsondb.LexicalSort.increasing((record) => record.title))
                .slice(offset, offset + length)
                .map((record) => lookupEpisode(record.episode_id, user_id));
        }
        else {
            return database.episode_search.search(query)
                .slice(offset, offset + length)
                .map((record) => record.lookup().episode_id)
                .map((id) => lookupEpisode(id, user_id))
                .collect();
        }
    }
    exports.searchForEpisodes = searchForEpisodes;
    ;
    function searchForGenres(query, offset, length, user_id) {
        if (query === "") {
            return Array.from(database.genres)
                .sort(jsondb.LexicalSort.increasing((record) => record.name))
                .map((record) => lookupGenre(record.genre_id, user_id));
        }
        else {
            return database.genre_search.search(query)
                .slice(offset, offset + length)
                .map((record) => record.lookup().genre_id)
                .map((id) => lookupGenre(id, user_id))
                .collect();
        }
    }
    exports.searchForGenres = searchForGenres;
    ;
    function searchForMovies(query, offset, length, user_id) {
        if (query === "") {
            return Array.from(database.movies)
                .sort(jsondb.LexicalSort.increasing((record) => record.title))
                .slice(offset, offset + length)
                .map((record) => lookupMovie(record.movie_id, user_id));
        }
        else {
            return database.movie_search.search(query)
                .slice(offset, offset + length)
                .map((record) => record.lookup().movie_id)
                .map((id) => lookupMovie(id, user_id))
                .collect();
        }
    }
    exports.searchForMovies = searchForMovies;
    ;
    function searchForActors(query, offset, length, user_id) {
        if (query === "") {
            return Array.from(database.actors)
                .sort(jsondb.LexicalSort.increasing((record) => record.name))
                .slice(offset, offset + length)
                .map((record) => lookupActor(record.actor_id, user_id));
        }
        else {
            return database.actor_search.search(query)
                .slice(offset, offset + length)
                .map((record) => record.lookup().actor_id)
                .map((id) => lookupActor(id, user_id))
                .collect();
        }
    }
    exports.searchForActors = searchForActors;
    ;
    function searchForPlaylists(query, offset, length, user_id) {
        if (query === "") {
            return Array.from(database.playlists)
                .sort(jsondb.LexicalSort.increasing((record) => record.title))
                .slice(offset, offset + length)
                .map((record) => lookupPlaylist(record.playlist_id, user_id));
        }
        else {
            return database.playlist_search.search(query)
                .slice(offset, offset + length)
                .map((record) => record.lookup().playlist_id)
                .map((id) => lookupPlaylist(id, user_id))
                .collect();
        }
    }
    exports.searchForPlaylists = searchForPlaylists;
    ;
    function searchForSeasons(query, offset, length, user_id) {
        return Array.from(database.seasons)
            .sort(jsondb.LexicalSort.increasing((record) => record.season_id))
            .slice(offset, offset + length)
            .map((record) => lookupSeason(record.season_id, user_id));
    }
    exports.searchForSeasons = searchForSeasons;
    ;
    function searchForShows(query, offset, length, user_id) {
        if (query === "") {
            return Array.from(database.shows)
                .sort(jsondb.LexicalSort.increasing((record) => record.name))
                .slice(offset, offset + length)
                .map((record) => lookupShow(record.show_id, user_id));
        }
        else {
            return database.shows_search.search(query)
                .slice(offset, offset + length)
                .map((record) => record.lookup().show_id)
                .map((id) => lookupShow(id, user_id))
                .collect();
        }
    }
    exports.searchForShows = searchForShows;
    ;
    function searchForTracks(query, offset, length, user_id) {
        if (query === "") {
            return Array.from(database.tracks)
                .sort(jsondb.LexicalSort.increasing((record) => record.title))
                .slice(offset, offset + length)
                .map((record) => lookupTrack(record.track_id, user_id));
        }
        else {
            return database.track_search.search(query)
                .slice(offset, offset + length)
                .map((record) => record.lookup().track_id)
                .map((id) => lookupTrack(id, user_id))
                .collect();
        }
    }
    exports.searchForTracks = searchForTracks;
    ;
    function searchForUsers(query, offset, length, user_id) {
        if (query === "") {
            return Array.from(database.users)
                .sort(jsondb.LexicalSort.increasing((record) => record.name))
                .slice(offset, offset + length)
                .map((record) => lookupUser(record.user_id));
        }
        else {
            return database.user_search.search(query)
                .slice(offset, offset + length)
                .map((record) => record.lookup().user_id)
                .map((id) => lookupUser(id))
                .collect();
        }
    }
    exports.searchForUsers = searchForUsers;
    ;
    function searchForYears(query, offset, length, user_id) {
        if (query === "") {
            return Array.from(database.years)
                .sort(jsondb.NumericSort.decreasing((record) => record.year))
                .slice(offset, offset + length)
                .map((record) => lookupYear(record.year_id, user_id));
        }
        else {
            return database.year_search.search(query)
                .slice(offset, offset + length)
                .map((record) => record.lookup().year_id)
                .map((id) => lookupYear(id, user_id))
                .collect();
        }
    }
    exports.searchForYears = searchForYears;
    ;
    function searchForEntities(query, user_id, offset, limit, options) {
        let results = [
            ...database.actor_search.search(query).map((result) => ({ ...result, type: "ACTOR", type_rank: 1 })),
            ...database.album_search.search(query).map((result) => ({ ...result, type: "ALBUM", type_rank: 9 })),
            ...database.artist_search.search(query).map((result) => ({ ...result, type: "ARTIST", type_rank: 6 })),
            ...database.episode_search.search(query).map((result) => ({ ...result, type: "EPISODE", type_rank: 4 })),
            ...database.genre_search.search(query).map((result) => ({ ...result, type: "GENRE", type_rank: 2 })),
            ...database.movie_search.search(query).map((result) => ({ ...result, type: "MOVIE", type_rank: 8 })),
            ...database.playlist_search.search(query).map((result) => ({ ...result, type: "PLAYLIST", type_rank: 3 })),
            ...database.shows_search.search(query).map((result) => ({ ...result, type: "SHOW", type_rank: 7 })),
            ...database.track_search.search(query).map((result) => ({ ...result, type: "TRACK", type_rank: 5 })),
            ...database.user_search.search(query).map((result) => ({ ...result, type: "USER", type_rank: 0 })),
            ...database.year_search.search(query).map((result) => ({ ...result, type: "YEAR", type_rank: 10 })),
            ...new Array()
        ].sort(jsondb.CombinedSort.of(jsondb.NumericSort.decreasing((value) => value.rank), jsondb.NumericSort.decreasing((value) => value.type_rank)));
        if (options?.cues) {
            let cue = is.absent(database.cue_search) ? undefined : database.cue_search.search(query).shift();
            if (is.present(cue)) {
                let result = results[0];
                if (is.absent(result) || cue.rank > result.rank) {
                    results.unshift({ ...cue, type: "CUE", type_rank: 11 });
                }
            }
        }
        let entities = results.slice(offset, offset + limit)
            .map((result) => {
            let type = result.type;
            if (false) {
            }
            else if (type === "ACTOR") {
                return lookupActor(result.lookup().actor_id, user_id);
            }
            else if (type === "ALBUM") {
                return lookupAlbum(result.lookup().album_id, user_id);
            }
            else if (type === "ARTIST") {
                return lookupArtist(result.lookup().artist_id, user_id);
            }
            else if (type === "CUE") {
                return lookupCue(result.lookup().cue_id, user_id);
            }
            else if (type === "EPISODE") {
                return lookupEpisode(result.lookup().episode_id, user_id);
            }
            else if (type === "GENRE") {
                return lookupGenre(result.lookup().genre_id, user_id);
            }
            else if (type === "MOVIE") {
                return lookupMovie(result.lookup().movie_id, user_id);
            }
            else if (type === "PLAYLIST") {
                return lookupPlaylist(result.lookup().playlist_id, user_id);
            }
            else if (type === "SHOW") {
                return lookupShow(result.lookup().show_id, user_id);
            }
            else if (type === "TRACK") {
                return lookupTrack(result.lookup().track_id, user_id);
            }
            else if (type === "USER") {
                return lookupUser(result.lookup().user_id);
            }
            else if (type === "YEAR") {
                return lookupYear(result.lookup().year_id, user_id);
            }
            throw `Expected code to be unreachable!`;
        });
        return entities;
    }
    exports.searchForEntities = searchForEntities;
    ;
    function getArtistAppearances(artist_id, user_id) {
        let track_artists = database.getTracksFromArtist.lookup(artist_id);
        let tracks = track_artists.map((track_artist) => {
            return database.tracks.lookup(track_artist.track_id);
        });
        let disc_ids = tracks.map((track) => {
            return track.disc_id;
        })
            .collect();
        disc_ids = Array.from(new Set(disc_ids));
        let discs = disc_ids.map((disc_id) => {
            return database.discs.lookup(disc_id);
        });
        let album_ids = discs.map((disc) => {
            return disc.album_id;
        });
        album_ids = Array.from(new Set(album_ids));
        let result = new Array();
        for (let album_id of album_ids) {
            let album_artists = database.getArtistsFromAlbum.lookup(album_id);
            if (album_artists.find((album_artist) => album_artist.artist_id === artist_id) == null) {
                result.push(album_id);
            }
        }
        return result
            .map((entry) => database.albums.lookup(entry))
            .sort(jsondb.LexicalSort.increasing((entry) => entry.title))
            .map((entry) => {
            return lookupAlbum(entry.album_id, user_id);
        });
    }
    exports.getArtistAppearances = getArtistAppearances;
    ;
    function getArtistTracks(artist_id, offset, length, user_id) {
        let track_weights = new Map();
        for (let track_artist of database.getTracksFromArtist.lookup(artist_id)) {
            let track_id = track_artist.track_id;
            for (let file of database.getFilesFromTrack.lookup(track_id)) {
                let streams = database.getStreamsFromFile.lookup(file.file_id);
                for (let stream of streams) {
                    let weight = track_weights.get(track_id) ?? 0;
                    weight += getStreamWeight(stream.timestamp_ms);
                    track_weights.set(track_id, weight);
                }
            }
        }
        return Array.from(track_weights.entries())
            .sort(jsondb.NumericSort.decreasing((entry) => entry[1]))
            .slice(offset, offset + length)
            .map((entry) => entry[0])
            .map((track_id) => lookupTrack(track_id, user_id));
    }
    exports.getArtistTracks = getArtistTracks;
    function getPlaylistAppearances(track_id, offset, length, user_id) {
        let playlist_ids = new Set();
        for (let playlist_item of database.getPlaylistItemsFromTrack.lookup(track_id)) {
            playlist_ids.add(playlist_item.playlist_id);
        }
        return Array.from(playlist_ids)
            .map((playlist_id) => database.playlists.lookup(playlist_id))
            .sort(jsondb.LexicalSort.increasing((playlist) => playlist.title))
            .slice(offset, offset + length)
            .map((playlist) => lookupPlaylist(playlist.playlist_id, user_id));
    }
    exports.getPlaylistAppearances = getPlaylistAppearances;
    ;
    function getMovieSuggestions(movie_id, offset, length, user_id) {
        let genres = database.getGenresFromMovie.lookup(movie_id);
        let map = new Map();
        for (let genre of genres) {
            let movie_genres = database.getMoviesFromGenre.lookup(genre.genre_id);
            for (let movie_genre of movie_genres) {
                let value = map.get(movie_genre.movie_id) ?? 0;
                map.set(movie_genre.movie_id, value + 2);
            }
        }
        for (let entry of map) {
            let video_genres = database.getGenresFromMovie.lookup(entry[0]).collect();
            map.set(entry[0], entry[1] - video_genres.length);
        }
        map.delete(movie_id);
        return Array.from(map.entries())
            .sort(jsondb.NumericSort.decreasing((entry) => entry[1]))
            .slice(offset, offset + length)
            .map((entry) => entry[0])
            .map((movie_id) => lookupMovie(movie_id, user_id));
    }
    exports.getMovieSuggestions = getMovieSuggestions;
    ;
    function getMoviesFromGenre(video_genre_id, user_id, offset, length) {
        return database.getMoviesFromGenre.lookup(video_genre_id)
            .map((entry) => database.movies.lookup(entry.movie_id))
            .sort(jsondb.LexicalSort.increasing((entry) => entry.title))
            .slice(offset, offset + length)
            .map((entry) => lookupMovie(entry.movie_id, user_id))
            .collect();
    }
    exports.getMoviesFromGenre = getMoviesFromGenre;
    ;
    function getMoviesFromActor(actor_id, user_id, offset, length) {
        return database.getMoviesFromActor.lookup(actor_id)
            .map((entry) => database.movies.lookup(entry.movie_id))
            .sort(jsondb.LexicalSort.increasing((movie) => movie.title))
            .slice(offset, offset + length)
            .map((entry) => lookupMovie(entry.movie_id, user_id))
            .collect();
    }
    exports.getMoviesFromActor = getMoviesFromActor;
    ;
    function getShowsFromGenre(video_genre_id, user_id, offset, length) {
        return database.getShowsFromGenre.lookup(video_genre_id)
            .map((entry) => database.shows.lookup(entry.show_id))
            .sort(jsondb.LexicalSort.increasing((entry) => entry.name))
            .slice(offset, offset + length)
            .map((entry) => lookupShow(entry.show_id, user_id))
            .collect();
    }
    exports.getShowsFromGenre = getShowsFromGenre;
    ;
    function getShowsFromActor(actor_id, user_id, offset, length) {
        return database.getShowsFromActor.lookup(actor_id)
            .map((entry) => database.shows.lookup(entry.show_id))
            .sort(jsondb.LexicalSort.increasing((entry) => entry.name))
            .slice(offset, offset + length)
            .map((entry) => lookupShow(entry.show_id, user_id))
            .collect();
    }
    exports.getShowsFromActor = getShowsFromActor;
    ;
    function getUserPlaylists(subject_user_id, user_id) {
        return database.getPlaylistsFromUser.lookup(subject_user_id)
            .sort(jsondb.LexicalSort.increasing((entry) => entry.title))
            .map((entry) => lookupPlaylist(entry.playlist_id, user_id))
            .collect();
    }
    exports.getUserPlaylists = getUserPlaylists;
    ;
    function getUserAlbums(subject_user_id, offset, length, user_id) {
        let album_weights = new Map();
        let streams = database.getStreamsFromUser.lookup(subject_user_id);
        for (let stream of streams) {
            let track_files = database.getTracksFromFile.lookup(stream.file_id);
            for (let track_file of track_files) {
                let track = database.tracks.lookup(track_file.track_id);
                let disc = database.discs.lookup(track.disc_id);
                let album = database.albums.lookup(disc.album_id);
                let album_id = album.album_id;
                let weight = album_weights.get(album_id) ?? 0;
                weight += getStreamWeight(stream.timestamp_ms);
                album_weights.set(album_id, weight);
            }
        }
        return Array.from(album_weights.entries())
            .sort(jsondb.NumericSort.decreasing((entry) => entry[1]))
            .slice(offset, offset + length)
            .map((entry) => entry[0])
            .map((album_id) => lookupAlbum(album_id, user_id));
    }
    exports.getUserAlbums = getUserAlbums;
    ;
    function getUserShows(subject_user_id, offset, length, user_id) {
        let show_weights = new Map();
        let streams = database.getStreamsFromUser.lookup(subject_user_id);
        for (let stream of streams) {
            let episode_files = database.getEpisodesFromFile.lookup(stream.file_id);
            for (let episode_file of episode_files) {
                let episode = database.episodes.lookup(episode_file.episode_id);
                let season = database.seasons.lookup(episode.season_id);
                let show = database.shows.lookup(season.show_id);
                let show_id = show.show_id;
                let weight = show_weights.get(show_id) ?? 0;
                weight += getStreamWeight(stream.timestamp_ms);
                show_weights.set(show_id, weight);
            }
        }
        return Array.from(show_weights.entries())
            .sort(jsondb.NumericSort.decreasing((entry) => entry[1]))
            .slice(offset, offset + length)
            .map((entry) => entry[0])
            .map((artist_id) => lookupShow(artist_id, user_id));
    }
    exports.getUserShows = getUserShows;
    ;
    function getMoviesFromYear(year_id, user_id, offset, length) {
        return database.getMoviesFromYear.lookup(lookupYearBase(year_id, user_id).year)
            .map((entry) => database.movies.lookup(entry.movie_id))
            .sort(jsondb.LexicalSort.increasing((entry) => entry.title))
            .slice(offset, offset + length)
            .map((entry) => lookupMovie(entry.movie_id, user_id))
            .collect();
    }
    exports.getMoviesFromYear = getMoviesFromYear;
    ;
    function getAlbumsFromYear(year_id, user_id, offset, length) {
        return database.getAlbumsFromYear.lookup(lookupYearBase(year_id, user_id).year)
            .map((entry) => database.albums.lookup(entry.album_id))
            .sort(jsondb.LexicalSort.increasing((entry) => entry.title))
            .slice(offset, offset + length)
            .map((entry) => lookupAlbum(entry.album_id, user_id))
            .collect();
    }
    exports.getAlbumsFromYear = getAlbumsFromYear;
    ;
});
define("build/api/schema/messages", ["require", "exports", "node_modules/@joelek/ts-autoguard/build/autoguard-lib/index"], function (require, exports, ts_autoguard_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.RegisterResponse = exports.RegisterRequest = exports.ErrorMessage = void 0;
    exports.ErrorMessage = ts_autoguard_1.guards.Object.of({
        "errors": ts_autoguard_1.guards.Array.of(ts_autoguard_1.guards.String)
    });
    exports.RegisterRequest = ts_autoguard_1.guards.Object.of({
        "username": ts_autoguard_1.guards.String,
        "password": ts_autoguard_1.guards.String,
        "name": ts_autoguard_1.guards.String,
        "key_id": ts_autoguard_1.guards.String
    });
    exports.RegisterResponse = ts_autoguard_1.guards.Object.of({
        "token": ts_autoguard_1.guards.String
    });
    exports.Autoguard = {
        "ErrorMessage": exports.ErrorMessage,
        "RegisterRequest": exports.RegisterRequest,
        "RegisterResponse": exports.RegisterResponse
    };
});
define("build/api/schema/objects", ["require", "exports", "build/database/schema", "build/database/schema", "build/database/schema", "build/database/schema", "node_modules/@joelek/ts-autoguard/build/autoguard-lib/index"], function (require, exports, schema_1, schema_2, schema_3, schema_4, ts_autoguard_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.Entity = exports.EntityBase = exports.Year = exports.YearBase = exports.Cue = exports.CueBase = exports.Subtitle = exports.SubtitleBase = exports.Episode = exports.EpisodeBase = exports.Season = exports.SeasonBase = exports.Show = exports.ShowBase = exports.Movie = exports.MovieBase = exports.Genre = exports.GenreBase = exports.PlaylistItem = exports.PlaylistItemBase = exports.Playlist = exports.PlaylistBase = exports.User = exports.UserBase = exports.Track = exports.TrackBase = exports.Disc = exports.DiscBase = exports.Album = exports.AlbumBase = exports.Artist = exports.ArtistBase = exports.Actor = exports.ActorBase = void 0;
    exports.ActorBase = ts_autoguard_1.guards.Object.of({
        "actor_id": ts_autoguard_1.guards.String,
        "name": ts_autoguard_1.guards.String
    });
    exports.Actor = ts_autoguard_1.guards.Intersection.of(ts_autoguard_1.guards.Reference.of(() => exports.ActorBase), ts_autoguard_1.guards.Object.of({}));
    exports.ArtistBase = ts_autoguard_1.guards.Object.of({
        "artist_id": ts_autoguard_1.guards.String,
        "title": ts_autoguard_1.guards.String
    });
    exports.Artist = ts_autoguard_1.guards.Intersection.of(ts_autoguard_1.guards.Reference.of(() => exports.ArtistBase), ts_autoguard_1.guards.Object.of({
        "albums": ts_autoguard_1.guards.Array.of(ts_autoguard_1.guards.Reference.of(() => exports.Album))
    }));
    exports.AlbumBase = ts_autoguard_1.guards.Object.of({
        "album_id": ts_autoguard_1.guards.String,
        "title": ts_autoguard_1.guards.String,
        "artwork": ts_autoguard_1.guards.Array.of(ts_autoguard_1.guards.Reference.of(() => schema_2.ImageFile))
    });
    exports.Album = ts_autoguard_1.guards.Intersection.of(ts_autoguard_1.guards.Reference.of(() => exports.AlbumBase), ts_autoguard_1.guards.Object.of({
        "artists": ts_autoguard_1.guards.Array.of(ts_autoguard_1.guards.Reference.of(() => exports.ArtistBase)),
        "discs": ts_autoguard_1.guards.Array.of(ts_autoguard_1.guards.Reference.of(() => exports.Disc)),
        "year": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.Number)
    }));
    exports.DiscBase = ts_autoguard_1.guards.Object.of({
        "disc_id": ts_autoguard_1.guards.String,
        "album": ts_autoguard_1.guards.Reference.of(() => exports.AlbumBase),
        "number": ts_autoguard_1.guards.Number
    });
    exports.Disc = ts_autoguard_1.guards.Intersection.of(ts_autoguard_1.guards.Reference.of(() => exports.DiscBase), ts_autoguard_1.guards.Object.of({
        "tracks": ts_autoguard_1.guards.Array.of(ts_autoguard_1.guards.Reference.of(() => exports.Track))
    }));
    exports.TrackBase = ts_autoguard_1.guards.Object.of({
        "track_id": ts_autoguard_1.guards.String,
        "title": ts_autoguard_1.guards.String,
        "disc": ts_autoguard_1.guards.Reference.of(() => exports.DiscBase),
        "number": ts_autoguard_1.guards.Number
    });
    exports.Track = ts_autoguard_1.guards.Intersection.of(ts_autoguard_1.guards.Reference.of(() => exports.TrackBase), ts_autoguard_1.guards.Object.of({
        "artists": ts_autoguard_1.guards.Array.of(ts_autoguard_1.guards.Reference.of(() => exports.ArtistBase)),
        "last_stream_date": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.Number),
        "media": ts_autoguard_1.guards.Reference.of(() => schema_1.AudioFile)
    }));
    exports.UserBase = ts_autoguard_1.guards.Object.of({
        "user_id": ts_autoguard_1.guards.String,
        "name": ts_autoguard_1.guards.String,
        "username": ts_autoguard_1.guards.String
    });
    exports.User = ts_autoguard_1.guards.Intersection.of(ts_autoguard_1.guards.Reference.of(() => exports.UserBase), ts_autoguard_1.guards.Object.of({}));
    exports.PlaylistBase = ts_autoguard_1.guards.Object.of({
        "playlist_id": ts_autoguard_1.guards.String,
        "title": ts_autoguard_1.guards.String,
        "description": ts_autoguard_1.guards.String,
        "user": ts_autoguard_1.guards.Reference.of(() => exports.UserBase)
    });
    exports.Playlist = ts_autoguard_1.guards.Intersection.of(ts_autoguard_1.guards.Reference.of(() => exports.PlaylistBase), ts_autoguard_1.guards.Object.of({
        "items": ts_autoguard_1.guards.Array.of(ts_autoguard_1.guards.Reference.of(() => exports.PlaylistItem))
    }));
    exports.PlaylistItemBase = ts_autoguard_1.guards.Object.of({
        "playlist_item_id": ts_autoguard_1.guards.String,
        "number": ts_autoguard_1.guards.Number,
        "playlist": ts_autoguard_1.guards.Reference.of(() => exports.PlaylistBase),
        "track": ts_autoguard_1.guards.Reference.of(() => exports.Track)
    });
    exports.PlaylistItem = ts_autoguard_1.guards.Intersection.of(ts_autoguard_1.guards.Reference.of(() => exports.PlaylistItemBase), ts_autoguard_1.guards.Object.of({}));
    exports.GenreBase = ts_autoguard_1.guards.Object.of({
        "genre_id": ts_autoguard_1.guards.String,
        "title": ts_autoguard_1.guards.String
    });
    exports.Genre = ts_autoguard_1.guards.Intersection.of(ts_autoguard_1.guards.Reference.of(() => exports.GenreBase), ts_autoguard_1.guards.Object.of({}));
    exports.MovieBase = ts_autoguard_1.guards.Object.of({
        "movie_id": ts_autoguard_1.guards.String,
        "title": ts_autoguard_1.guards.String,
        "artwork": ts_autoguard_1.guards.Array.of(ts_autoguard_1.guards.Reference.of(() => schema_2.ImageFile))
    });
    exports.Movie = ts_autoguard_1.guards.Intersection.of(ts_autoguard_1.guards.Reference.of(() => exports.MovieBase), ts_autoguard_1.guards.Object.of({
        "year": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.Number),
        "summary": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.String),
        "genres": ts_autoguard_1.guards.Array.of(ts_autoguard_1.guards.Reference.of(() => exports.Genre)),
        "actors": ts_autoguard_1.guards.Array.of(ts_autoguard_1.guards.Reference.of(() => exports.Actor)),
        "last_stream_date": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.Number),
        "media": ts_autoguard_1.guards.Reference.of(() => schema_4.VideoFile),
        "subtitles": ts_autoguard_1.guards.Array.of(ts_autoguard_1.guards.Reference.of(() => schema_3.SubtitleFile))
    }));
    exports.ShowBase = ts_autoguard_1.guards.Object.of({
        "show_id": ts_autoguard_1.guards.String,
        "title": ts_autoguard_1.guards.String,
        "artwork": ts_autoguard_1.guards.Array.of(ts_autoguard_1.guards.Reference.of(() => schema_2.ImageFile))
    });
    exports.Show = ts_autoguard_1.guards.Intersection.of(ts_autoguard_1.guards.Reference.of(() => exports.ShowBase), ts_autoguard_1.guards.Object.of({
        "summary": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.String),
        "genres": ts_autoguard_1.guards.Array.of(ts_autoguard_1.guards.Reference.of(() => exports.Genre)),
        "actors": ts_autoguard_1.guards.Array.of(ts_autoguard_1.guards.Reference.of(() => exports.Actor)),
        "seasons": ts_autoguard_1.guards.Array.of(ts_autoguard_1.guards.Reference.of(() => exports.Season))
    }));
    exports.SeasonBase = ts_autoguard_1.guards.Object.of({
        "season_id": ts_autoguard_1.guards.String,
        "number": ts_autoguard_1.guards.Number,
        "show": ts_autoguard_1.guards.Reference.of(() => exports.ShowBase)
    });
    exports.Season = ts_autoguard_1.guards.Intersection.of(ts_autoguard_1.guards.Reference.of(() => exports.SeasonBase), ts_autoguard_1.guards.Object.of({
        "episodes": ts_autoguard_1.guards.Array.of(ts_autoguard_1.guards.Reference.of(() => exports.Episode))
    }));
    exports.EpisodeBase = ts_autoguard_1.guards.Object.of({
        "episode_id": ts_autoguard_1.guards.String,
        "title": ts_autoguard_1.guards.String,
        "number": ts_autoguard_1.guards.Number,
        "season": ts_autoguard_1.guards.Reference.of(() => exports.SeasonBase)
    });
    exports.Episode = ts_autoguard_1.guards.Intersection.of(ts_autoguard_1.guards.Reference.of(() => exports.EpisodeBase), ts_autoguard_1.guards.Object.of({
        "year": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.Number),
        "summary": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.String),
        "last_stream_date": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.Number),
        "media": ts_autoguard_1.guards.Reference.of(() => schema_4.VideoFile),
        "subtitles": ts_autoguard_1.guards.Array.of(ts_autoguard_1.guards.Reference.of(() => schema_3.SubtitleFile))
    }));
    exports.SubtitleBase = ts_autoguard_1.guards.Object.of({
        "subtitle_id": ts_autoguard_1.guards.String,
        "subtitle": ts_autoguard_1.guards.Reference.of(() => schema_3.SubtitleFile)
    });
    exports.Subtitle = ts_autoguard_1.guards.Intersection.of(ts_autoguard_1.guards.Reference.of(() => exports.SubtitleBase), ts_autoguard_1.guards.Object.of({
        "cues": ts_autoguard_1.guards.Array.of(ts_autoguard_1.guards.Reference.of(() => exports.Cue))
    }));
    exports.CueBase = ts_autoguard_1.guards.Object.of({
        "cue_id": ts_autoguard_1.guards.String,
        "subtitle": ts_autoguard_1.guards.Reference.of(() => exports.SubtitleBase),
        "start_ms": ts_autoguard_1.guards.Number,
        "duration_ms": ts_autoguard_1.guards.Number,
        "lines": ts_autoguard_1.guards.Array.of(ts_autoguard_1.guards.String)
    });
    exports.Cue = ts_autoguard_1.guards.Intersection.of(ts_autoguard_1.guards.Reference.of(() => exports.CueBase), ts_autoguard_1.guards.Object.of({
        "media": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Reference.of(() => exports.Episode), ts_autoguard_1.guards.Reference.of(() => exports.Movie))
    }));
    exports.YearBase = ts_autoguard_1.guards.Object.of({
        "year_id": ts_autoguard_1.guards.String,
        "year": ts_autoguard_1.guards.Number
    });
    exports.Year = ts_autoguard_1.guards.Intersection.of(ts_autoguard_1.guards.Reference.of(() => exports.YearBase), ts_autoguard_1.guards.Object.of({}));
    exports.EntityBase = ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Reference.of(() => exports.ActorBase), ts_autoguard_1.guards.Reference.of(() => exports.AlbumBase), ts_autoguard_1.guards.Reference.of(() => exports.ArtistBase), ts_autoguard_1.guards.Reference.of(() => exports.CueBase), ts_autoguard_1.guards.Reference.of(() => exports.DiscBase), ts_autoguard_1.guards.Reference.of(() => exports.EpisodeBase), ts_autoguard_1.guards.Reference.of(() => exports.GenreBase), ts_autoguard_1.guards.Reference.of(() => exports.MovieBase), ts_autoguard_1.guards.Reference.of(() => exports.PlaylistBase), ts_autoguard_1.guards.Reference.of(() => exports.SeasonBase), ts_autoguard_1.guards.Reference.of(() => exports.ShowBase), ts_autoguard_1.guards.Reference.of(() => exports.TrackBase), ts_autoguard_1.guards.Reference.of(() => exports.UserBase), ts_autoguard_1.guards.Reference.of(() => exports.YearBase));
    exports.Entity = ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Reference.of(() => exports.Actor), ts_autoguard_1.guards.Reference.of(() => exports.Album), ts_autoguard_1.guards.Reference.of(() => exports.Artist), ts_autoguard_1.guards.Reference.of(() => exports.Cue), ts_autoguard_1.guards.Reference.of(() => exports.Disc), ts_autoguard_1.guards.Reference.of(() => exports.Episode), ts_autoguard_1.guards.Reference.of(() => exports.Genre), ts_autoguard_1.guards.Reference.of(() => exports.Movie), ts_autoguard_1.guards.Reference.of(() => exports.Playlist), ts_autoguard_1.guards.Reference.of(() => exports.Season), ts_autoguard_1.guards.Reference.of(() => exports.Show), ts_autoguard_1.guards.Reference.of(() => exports.Track), ts_autoguard_1.guards.Reference.of(() => exports.User), ts_autoguard_1.guards.Reference.of(() => exports.Year));
    exports.Autoguard = {
        "ActorBase": exports.ActorBase,
        "Actor": exports.Actor,
        "ArtistBase": exports.ArtistBase,
        "Artist": exports.Artist,
        "AlbumBase": exports.AlbumBase,
        "Album": exports.Album,
        "DiscBase": exports.DiscBase,
        "Disc": exports.Disc,
        "TrackBase": exports.TrackBase,
        "Track": exports.Track,
        "UserBase": exports.UserBase,
        "User": exports.User,
        "PlaylistBase": exports.PlaylistBase,
        "Playlist": exports.Playlist,
        "PlaylistItemBase": exports.PlaylistItemBase,
        "PlaylistItem": exports.PlaylistItem,
        "GenreBase": exports.GenreBase,
        "Genre": exports.Genre,
        "MovieBase": exports.MovieBase,
        "Movie": exports.Movie,
        "ShowBase": exports.ShowBase,
        "Show": exports.Show,
        "SeasonBase": exports.SeasonBase,
        "Season": exports.Season,
        "EpisodeBase": exports.EpisodeBase,
        "Episode": exports.Episode,
        "SubtitleBase": exports.SubtitleBase,
        "Subtitle": exports.Subtitle,
        "CueBase": exports.CueBase,
        "Cue": exports.Cue,
        "YearBase": exports.YearBase,
        "Year": exports.Year,
        "EntityBase": exports.EntityBase,
        "Entity": exports.Entity
    };
});
define("build/api/schema/index", ["require", "exports", "build/api/schema/messages", "build/api/schema/objects"], function (require, exports, messages, objects) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.objects = exports.messages = void 0;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.objects = exports.messages = void 0;
    exports.messages = messages;
    exports.objects = objects;
});
define("build/api/api", ["require", "exports", "url", "build/server/auth", "build/server/auth", "build/api/handler", "build/api/schema/index", "build/is"], function (require, exports, liburl, libauth, auth, handler, schema, is) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.handleRequest = void 0;
    function readBody(request) {
        return new Promise((resolve, reject) => {
            let chunks = new Array();
            request.on("data", (chunk) => {
                chunks.push(chunk);
            });
            request.on("end", () => {
                let buffer = Buffer.concat(chunks);
                resolve(buffer);
            });
            request.on("error", (error) => {
                reject(error);
            });
        });
    }
    function getParameter(url, key) {
        let values = url.query[key] ?? [];
        if (Array.isArray(values)) {
            return values;
        }
        return [values];
    }
    function getRequiredString(url, key) {
        let values = getParameter(url, key);
        let value = values.pop();
        if (is.absent(value)) {
            throw `Expected parameter ${key}!`;
        }
        return value;
    }
    function getOptionalString(url, key) {
        try {
            return getRequiredString(url, key);
        }
        catch (error) { }
    }
    function getRequiredInteger(url, key) {
        let value = Number.parseInt(getRequiredString(url, key), 10);
        if (!Number.isInteger(value)) {
            throw `Expected integer ${key}!`;
        }
        return value;
    }
    function getOptionalInteger(url, key) {
        try {
            return getRequiredInteger(url, key);
        }
        catch (error) { }
    }
    function getRequiredBoolean(url, key) {
        let value = getRequiredString(url, key);
        if (value === "false") {
            return false;
        }
        if (value === "true") {
            return true;
        }
        throw `Expected a boolean!`;
    }
    function getOptionalBoolean(url, key) {
        try {
            return getRequiredBoolean(url, key);
        }
        catch (error) { }
    }
    function getUserId(request) {
        var url = liburl.parse(request.url || "/", true);
        return auth.getUserId(url.query.token);
    }
    class Router {
        constructor() {
            this.routes = new Array();
        }
        registerRoute(route) {
            this.routes.push(route);
            return this;
        }
        route(request, response) {
            for (let route of this.routes) {
                if (route.handlesRequest(request)) {
                    return route.handleRequest(request, response);
                }
            }
            response.writeHead(400);
            response.end('{}');
        }
    }
    class ArtistRoute {
        handleRequest(request, response) {
            let user_id = getUserId(request);
            let parts = /^[/]api[/]audio[/]artists[/]([0-9a-f]{16})[/]/.exec(request.url ?? "/");
            let artist_id = parts[1];
            let artist = handler.lookupArtist(artist_id, user_id);
            let tracks = handler.getArtistTracks(artist_id, 0, 3, user_id);
            let appearances = handler.getArtistAppearances(artist_id, user_id);
            let payload = {
                artist,
                tracks,
                appearances
            };
            response.writeHead(200);
            response.end(JSON.stringify(payload));
        }
        handlesRequest(request) {
            return /^[/]api[/]audio[/]artists[/]([0-9a-f]{16})[/]/.test(request.url ?? "/");
        }
    }
    class ArtistsRoute {
        handleRequest(request, response) {
            let user_id = getUserId(request);
            let parts = /^[/]api[/]audio[/]artists[/]([^/?]*)/.exec(request.url ?? "/");
            let query = decodeURIComponent(parts[1]);
            let url = liburl.parse(request.url ?? "/", true);
            let offset = getOptionalInteger(url, "offset") ?? 0;
            let length = getOptionalInteger(url, "length") ?? 24;
            let artists = handler.searchForArtists(query, offset, length, user_id);
            let payload = {
                artists
            };
            response.writeHead(200);
            response.end(JSON.stringify(payload));
        }
        handlesRequest(request) {
            return /^[/]api[/]audio[/]artists[/]([^/?]*)/.test(request.url ?? "/");
        }
    }
    class AlbumRoute {
        handleRequest(request, response) {
            let user_id = getUserId(request);
            let parts = /^[/]api[/]audio[/]albums[/]([0-9a-f]{16})[/]/.exec(request.url ?? "/");
            let album_id = parts[1];
            let album = handler.lookupAlbum(album_id, user_id);
            let payload = {
                album
            };
            response.writeHead(200);
            response.end(JSON.stringify(payload));
        }
        handlesRequest(request) {
            return /^[/]api[/]audio[/]albums[/]([0-9a-f]{16})[/]/.test(request.url ?? "/");
        }
    }
    class AlbumsRoute {
        handleRequest(request, response) {
            let user_id = getUserId(request);
            let parts = /^[/]api[/]audio[/]albums[/]([^/?]*)/.exec(request.url ?? "/");
            let query = parts[1];
            let url = liburl.parse(request.url ?? "/", true);
            let offset = getOptionalInteger(url, "offset") ?? 0;
            let length = getOptionalInteger(url, "length") ?? 24;
            let albums = handler.searchForAlbums(query, offset, length, user_id);
            let payload = {
                albums
            };
            response.writeHead(200);
            response.end(JSON.stringify(payload));
        }
        handlesRequest(request) {
            return /^[/]api[/]audio[/]albums[/]([^/?]*)/.test(request.url ?? "/");
        }
    }
    class EpisodeRoute {
        handleRequest(request, response) {
            let user_id = getUserId(request);
            let parts = /^[/]api[/]video[/]episodes[/]([0-9a-f]{16})[/]/.exec(request.url ?? "/");
            let episode_id = parts[1];
            let episode = handler.lookupEpisode(episode_id, user_id);
            let episodes = handler.lookupSeason(episode.season.season_id, user_id).episodes;
            let index = episodes.findIndex((other_episode) => other_episode.episode_id === episode.episode_id);
            let last = episodes[index - 1];
            let next = episodes[index + 1];
            let payload = {
                episode,
                last,
                next
            };
            response.writeHead(200);
            response.end(JSON.stringify(payload));
        }
        handlesRequest(request) {
            return /^[/]api[/]video[/]episodes[/]([0-9a-f]{16})[/]/.test(request.url ?? "/");
        }
    }
    class EpisodesRoute {
        handleRequest(request, response) {
            let user_id = getUserId(request);
            let parts = /^[/]api[/]video[/]episodes[/]([^/?]*)/.exec(request.url ?? "/");
            let query = decodeURIComponent(parts[1]);
            let url = liburl.parse(request.url ?? "/", true);
            let offset = getOptionalInteger(url, "offset") ?? 0;
            let length = getOptionalInteger(url, "length") ?? 24;
            let episodes = handler.searchForEpisodes(query, offset, length, user_id);
            let payload = {
                episodes
            };
            response.writeHead(200);
            response.end(JSON.stringify(payload));
        }
        handlesRequest(request) {
            return /^[/]api[/]video[/]episodes[/]([^/?]*)/.test(request.url ?? "/");
        }
    }
    class ShowRoute {
        handleRequest(request, response) {
            let user_id = getUserId(request);
            let parts = /^[/]api[/]video[/]shows[/]([0-9a-f]{16})[/]/.exec(request.url ?? "/");
            let show_id = parts[1];
            let show = handler.lookupShow(show_id, user_id);
            let payload = {
                show
            };
            response.writeHead(200);
            response.end(JSON.stringify(payload));
        }
        handlesRequest(request) {
            return /^[/]api[/]video[/]shows[/]([0-9a-f]{16})[/]/.test(request.url ?? "/");
        }
    }
    class ShowsRoute {
        handleRequest(request, response) {
            let user_id = getUserId(request);
            let parts = /^[/]api[/]video[/]shows[/]([^/?]*)/.exec(request.url ?? "/");
            let query = decodeURIComponent(parts[1]);
            let url = liburl.parse(request.url ?? "/", true);
            let offset = getOptionalInteger(url, "offset") ?? 0;
            let length = getOptionalInteger(url, "length") ?? 24;
            let shows = handler.searchForShows(query, offset, length, user_id);
            let payload = {
                shows
            };
            response.writeHead(200);
            response.end(JSON.stringify(payload));
        }
        handlesRequest(request) {
            return /^[/]api[/]video[/]shows[/]([^/?]*)/.test(request.url ?? "/");
        }
    }
    class AuthWithTokenRoute {
        constructor() {
        }
        handleRequest(request, response) {
            if (request.url === undefined) {
                throw new Error();
            }
            let parts = /^[/]api[/]auth[/][?]token[=]([0-9a-f]{32})/.exec(request.url);
            if (parts === null) {
                throw new Error();
            }
            let chunk = parts[1];
            let payload = {};
            try {
                libauth.getUserId(chunk);
                response.writeHead(200);
                payload.token = chunk;
                return response.end(JSON.stringify(payload));
            }
            catch (error) { }
            response.writeHead(401);
            return response.end(JSON.stringify({}));
        }
        handlesRequest(request) {
            return request.method === 'POST' && request.url !== undefined && /^[/]api[/]auth[/][?]token[=]([0-9a-f]{32})/.test(request.url);
        }
    }
    class AuthRoute {
        constructor() {
        }
        handleRequest(request, response) {
            if (request.url === undefined) {
                throw new Error();
            }
            let data = '';
            request.on('data', (chunk) => {
                data += chunk;
            }).on('end', () => {
                try {
                    let json = JSON.parse(data);
                    if (json == null || json.constructor !== Object) {
                        throw new Error();
                    }
                    if (json.username == null || json.username.constructor !== String) {
                        throw new Error();
                    }
                    if (json.password == null || json.password.constructor !== String) {
                        throw new Error();
                    }
                    let body = json;
                    let username = body.username;
                    let password = body.password;
                    let token = libauth.createToken(username, password);
                    let payload = {
                        token
                    };
                    response.writeHead(200);
                    response.end(JSON.stringify(payload));
                }
                catch (error) {
                    console.log(error);
                    response.writeHead(400);
                    response.end(JSON.stringify({ error: error.message }));
                }
            });
        }
        handlesRequest(request) {
            return request.method === 'POST' && request.url !== undefined && /^[/]api[/]auth[/]/.test(request.url);
        }
    }
    class RegisterRoute {
        handleRequest(request, response) {
            readBody(request).then((buffer) => {
                let body = schema.messages.RegisterRequest.as(JSON.parse(buffer.toString()));
                this.handleAsyncRequest(body).then((body) => {
                    response.writeHead(200);
                    response.end(JSON.stringify(body));
                });
            });
        }
        async handleAsyncRequest(body) {
            return handler.createUser(body);
        }
        handlesRequest(request) {
            return /^[/]api[/]register[/]/.test(request.url ?? "/");
        }
    }
    class MovieMovieSuggestionsRoute {
        handleRequest(request, response) {
            let user_id = getUserId(request);
            let parts = /^[/]api[/]video[/]movies[/]([0-9a-f]{16})[/]suggestions[/]movies[/]/.exec(request.url ?? "/");
            let url = liburl.parse(request.url ?? "/", true);
            let offset = getOptionalInteger(url, "offset") ?? 0;
            let length = getOptionalInteger(url, "length") ?? 24;
            let movie_id = parts[1];
            let movies = handler.getMovieSuggestions(movie_id, offset, length, user_id);
            let payload = {
                movies
            };
            response.writeHead(200);
            response.end(JSON.stringify(payload));
        }
        handlesRequest(request) {
            return /^[/]api[/]video[/]movies[/]([0-9a-f]{16})[/]suggestions[/]movies[/]/.test(request.url ?? "/");
        }
    }
    class MovieRoute {
        handleRequest(request, response) {
            let user_id = getUserId(request);
            let parts = /^[/]api[/]video[/]movies[/]([0-9a-f]{16})[/]/.exec(request.url ?? "/");
            let movie_id = parts[1];
            let movie = handler.lookupMovie(movie_id, user_id);
            let payload = {
                movie
            };
            response.writeHead(200);
            response.end(JSON.stringify(payload));
        }
        handlesRequest(request) {
            return /^[/]api[/]video[/]movies[/]([0-9a-f]{16})[/]/.test(request.url ?? "/");
        }
    }
    class MoviesRoute {
        handleRequest(request, response) {
            let user_id = getUserId(request);
            let parts = /^[/]api[/]video[/]movies[/]([^/?]*)/.exec(request.url ?? "/");
            let query = decodeURIComponent(parts[1]);
            let url = liburl.parse(request.url ?? "/", true);
            let offset = getOptionalInteger(url, "offset") ?? 0;
            let length = getOptionalInteger(url, "length") ?? 24;
            let movies = handler.searchForMovies(query, offset, length, user_id);
            let payload = {
                movies
            };
            response.writeHead(200);
            response.end(JSON.stringify(payload));
        }
        handlesRequest(request) {
            return /^[/]api[/]video[/]movies[/]([^/?]*)/.test(request.url ?? "/");
        }
    }
    class PlaylistRoute {
        handleRequest(request, response) {
            let user_id = getUserId(request);
            let parts = /^[/]api[/]audio[/]playlists[/]([0-9a-f]{16})[/]/.exec(request.url ?? "/");
            let playlist_id = parts[1];
            let playlist = handler.lookupPlaylist(playlist_id, user_id);
            let payload = {
                playlist
            };
            response.writeHead(200);
            response.end(JSON.stringify(payload));
        }
        handlesRequest(request) {
            return /^[/]api[/]audio[/]playlists[/]([0-9a-f]{16})[/]/.test(request.url ?? "/");
        }
    }
    class PlaylistsRoute {
        handleRequest(request, response) {
            let user_id = getUserId(request);
            let parts = /^[/]api[/]audio[/]playlists[/]([^/?]*)/.exec(request.url ?? "/");
            let query = decodeURIComponent(parts[1]);
            let url = liburl.parse(request.url ?? "/", true);
            let offset = getOptionalInteger(url, "offset") ?? 0;
            let length = getOptionalInteger(url, "length") ?? 24;
            let playlists = handler.searchForPlaylists(query, offset, length, user_id);
            let payload = {
                playlists
            };
            response.writeHead(200);
            response.end(JSON.stringify(payload));
        }
        handlesRequest(request) {
            return /^[/]api[/]audio[/]playlists[/]([^/?]*)/.test(request.url ?? "/");
        }
    }
    class CuesRoute {
        handleRequest(request, response) {
            let user_id = getUserId(request);
            let parts = /^[/]api[/]video[/]cues[/]([^/?]*)/.exec(request.url ?? "/");
            let query = decodeURIComponent(parts[1]);
            let url = liburl.parse(request.url ?? "/", true);
            let offset = getOptionalInteger(url, "offset") ?? 0;
            let length = getOptionalInteger(url, "length") ?? 24;
            let cues = handler.searchForCues(query, offset, length, user_id);
            let payload = {
                cues
            };
            response.writeHead(200);
            response.end(JSON.stringify(payload));
        }
        handlesRequest(request) {
            return /^[/]api[/]video[/]cues[/]([^/?]*)/.test(request.url ?? "/");
        }
    }
    class GenresRoute {
        handleRequest(request, response) {
            let user_id = getUserId(request);
            let parts = /^[/]api[/]video[/]genres[/]([^/?]*)/.exec(request.url ?? "/");
            let query = decodeURIComponent(parts[1]);
            let url = liburl.parse(request.url ?? "/", true);
            let offset = getOptionalInteger(url, "offset") ?? 0;
            let length = getOptionalInteger(url, "length") ?? 24;
            let genres = handler.searchForGenres(query, offset, length, user_id);
            let payload = {
                genres
            };
            response.writeHead(200);
            response.end(JSON.stringify(payload));
        }
        handlesRequest(request) {
            return /^[/]api[/]video[/]genres[/]([^/?]*)/.test(request.url ?? "/");
        }
    }
    class GenreShowsRoute {
        handleRequest(request, response) {
            let user_id = getUserId(request);
            let parts = /^[/]api[/]video[/]genres[/]([0-9a-f]{16})[/]shows[/]/.exec(request.url ?? "/");
            let url = liburl.parse(request.url ?? "/", true);
            let offset = getOptionalInteger(url, "offset") ?? 0;
            let length = getOptionalInteger(url, "length") ?? 24;
            let genre_id = parts[1];
            let shows = handler.getShowsFromGenre(genre_id, user_id, offset, length);
            let payload = {
                shows
            };
            response.writeHead(200);
            response.end(JSON.stringify(payload));
        }
        handlesRequest(request) {
            return /^[/]api[/]video[/]genres[/]([0-9a-f]{16})[/]shows[/]/.test(request.url ?? "/");
        }
    }
    class GenreMoviesRoute {
        handleRequest(request, response) {
            let user_id = getUserId(request);
            let parts = /^[/]api[/]video[/]genres[/]([0-9a-f]{16})[/]movies[/]/.exec(request.url ?? "/");
            let url = liburl.parse(request.url ?? "/", true);
            let offset = getOptionalInteger(url, "offset") ?? 0;
            let length = getOptionalInteger(url, "length") ?? 24;
            let genre_id = parts[1];
            let movies = handler.getMoviesFromGenre(genre_id, user_id, offset, length);
            let payload = {
                movies
            };
            response.writeHead(200);
            response.end(JSON.stringify(payload));
        }
        handlesRequest(request) {
            return /^[/]api[/]video[/]genres[/]([0-9a-f]{16})[/]movies[/]/.test(request.url ?? "/");
        }
    }
    class GenreRoute {
        handleRequest(request, response) {
            let user_id = getUserId(request);
            let parts = /^[/]api[/]video[/]genres[/]([0-9a-f]{16})[/]/.exec(request.url ?? "/");
            let genre_id = parts[1];
            let genre = handler.lookupGenre(genre_id, user_id);
            let payload = {
                genre
            };
            response.writeHead(200);
            response.end(JSON.stringify(payload));
        }
        handlesRequest(request) {
            return /^[/]api[/]video[/]genres[/]([0-9a-f]{16})[/]/.test(request.url ?? "/");
        }
    }
    class SearchRoute {
        handleRequest(request, response) {
            let user_id = getUserId(request);
            let parts = /^[/]api[/]search[/]([^/?]*)/.exec(request.url ?? "/");
            let query = decodeURIComponent(parts[1]);
            let url = liburl.parse(request.url ?? "/", true);
            let cues = getOptionalBoolean(url, "cues") ?? false;
            let offset = getOptionalInteger(url, "offset") ?? 0;
            let length = getOptionalInteger(url, "length") ?? 24;
            let entities = handler.searchForEntities(query, user_id, offset, length, { cues });
            let payload = {
                entities
            };
            response.writeHead(200);
            response.end(JSON.stringify(payload));
        }
        handlesRequest(request) {
            return /^[/]api[/]search[/]([^/?]*)/.test(request.url ?? "/");
        }
    }
    class TrackPlaylistsRoute {
        handleRequest(request, response) {
            let user_id = getUserId(request);
            let parts = /^[/]api[/]audio[/]tracks[/]([0-9a-f]{16})[/]playlists[/]/.exec(request.url ?? "/");
            let track_id = decodeURIComponent(parts[1]);
            let url = liburl.parse(request.url ?? "/", true);
            let offset = getOptionalInteger(url, "offset") ?? 0;
            let length = getOptionalInteger(url, "length") ?? 24;
            let playlists = handler.getPlaylistAppearances(track_id, offset, length, user_id);
            let payload = {
                playlists: playlists
            };
            response.writeHead(200);
            response.end(JSON.stringify(payload));
        }
        handlesRequest(request) {
            return /^[/]api[/]audio[/]tracks[/]([0-9a-f]{16})[/]playlists[/]/.test(request.url ?? "/");
        }
    }
    class TrackRoute {
        handleRequest(request, response) {
            let user_id = getUserId(request);
            let parts = /^[/]api[/]audio[/]tracks[/]([0-9a-f]{16})[/]/.exec(request.url ?? "/");
            let track_id = parts[1];
            let track = handler.lookupTrack(track_id, user_id);
            let tracks = handler.lookupDisc(track.disc.disc_id, user_id).tracks;
            let index = tracks.findIndex((other_track) => other_track.track_id === track.track_id);
            let last = tracks[index - 1];
            let next = tracks[index + 1];
            let payload = {
                track,
                last,
                next
            };
            response.writeHead(200);
            response.end(JSON.stringify(payload));
        }
        handlesRequest(request) {
            return /^[/]api[/]audio[/]tracks[/]([0-9a-f]{16})[/]/.test(request.url ?? "/");
        }
    }
    class TracksRoute {
        handleRequest(request, response) {
            let user_id = getUserId(request);
            let parts = /^[/]api[/]audio[/]tracks[/]([^/?]*)/.exec(request.url ?? "/");
            let query = decodeURIComponent(parts[1]);
            let url = liburl.parse(request.url ?? "/", true);
            let offset = getOptionalInteger(url, "offset") ?? 0;
            let length = getOptionalInteger(url, "length") ?? 24;
            let tracks = handler.searchForTracks(query, offset, length, user_id);
            let payload = {
                tracks
            };
            response.writeHead(200);
            response.end(JSON.stringify(payload));
        }
        handlesRequest(request) {
            return /^[/]api[/]audio[/]tracks[/]([^/?]*)/.test(request.url ?? "/");
        }
    }
    class SeasonRoute {
        handleRequest(request, response) {
            let user_id = getUserId(request);
            let parts = /^[/]api[/]video[/]seasons[/]([0-9a-f]{16})[/]/.exec(request.url ?? "/");
            let season_id = parts[1];
            let season = handler.lookupSeason(season_id, user_id);
            let seasons = handler.lookupShow(season.show.show_id, user_id).seasons;
            let index = seasons.findIndex((other_season) => other_season.season_id === season.season_id);
            let last = seasons[index - 1];
            let next = seasons[index + 1];
            let payload = {
                season,
                last,
                next
            };
            response.writeHead(200);
            response.end(JSON.stringify(payload));
        }
        handlesRequest(request) {
            return /^[/]api[/]video[/]seasons[/]([0-9a-f]{16})[/]/.test(request.url ?? "/");
        }
    }
    class SeasonsRoute {
        handleRequest(request, response) {
            let user_id = getUserId(request);
            let parts = /^[/]api[/]video[/]seasons[/]([^/?]*)/.exec(request.url ?? "/");
            let query = decodeURIComponent(parts[1]);
            let url = liburl.parse(request.url ?? "/", true);
            let offset = getOptionalInteger(url, "offset") ?? 0;
            let length = getOptionalInteger(url, "length") ?? 24;
            let seasons = handler.searchForSeasons(query, offset, length, user_id);
            let payload = {
                seasons
            };
            response.writeHead(200);
            response.end(JSON.stringify(payload));
        }
        handlesRequest(request) {
            return /^[/]api[/]video[/]seasons[/]([^/?]*)/.test(request.url ?? "/");
        }
    }
    class DiscRoute {
        handleRequest(request, response) {
            let user_id = getUserId(request);
            let parts = /^[/]api[/]audio[/]discs[/]([0-9a-f]{16})[/]/.exec(request.url ?? "/");
            let season_id = parts[1];
            let disc = handler.lookupDisc(season_id, user_id);
            let discs = handler.lookupAlbum(disc.album.album_id, user_id).discs;
            let index = discs.findIndex((other_disc) => other_disc.disc_id === disc.disc_id);
            let last = discs[index - 1];
            let next = discs[index + 1];
            let payload = {
                disc,
                last,
                next
            };
            response.writeHead(200);
            response.end(JSON.stringify(payload));
        }
        handlesRequest(request) {
            return /^[/]api[/]audio[/]discs[/]([0-9a-f]{16})[/]/.test(request.url ?? "/");
        }
    }
    class DiscsRoute {
        handleRequest(request, response) {
            let user_id = getUserId(request);
            let parts = /^[/]api[/]audio[/]discs[/]([^/?]*)/.exec(request.url ?? "/");
            let query = decodeURIComponent(parts[1]);
            let url = liburl.parse(request.url ?? "/", true);
            let offset = getOptionalInteger(url, "offset") ?? 0;
            let length = getOptionalInteger(url, "length") ?? 24;
            let discs = handler.searchForDiscs(query, offset, length, user_id);
            let payload = {
                discs
            };
            response.writeHead(200);
            response.end(JSON.stringify(payload));
        }
        handlesRequest(request) {
            return /^[/]api[/]audio[/]discs[/]([^/?]*)/.test(request.url ?? "/");
        }
    }
    class UserAlbumsRoute {
        handleRequest(request, response) {
            let user_id = getUserId(request);
            let parts = /^[/]api[/]users[/]([0-9a-f]{16})?[/]albums[/]/.exec(request.url ?? "/");
            let url = liburl.parse(request.url ?? "/", true);
            let offset = getOptionalInteger(url, "offset") ?? 0;
            let length = getOptionalInteger(url, "length") ?? 24;
            let user = handler.lookupUser(parts[1] ?? user_id);
            let albums = handler.getUserAlbums(user.user_id, offset, length, user_id);
            let payload = {
                albums
            };
            response.writeHead(200);
            response.end(JSON.stringify(payload));
        }
        handlesRequest(request) {
            return /^[/]api[/]users[/]([0-9a-f]{16})?[/]albums[/]/.test(request.url ?? "/");
        }
    }
    class UserShowsRoute {
        handleRequest(request, response) {
            let user_id = getUserId(request);
            let parts = /^[/]api[/]users[/]([0-9a-f]{16})?[/]shows[/]/.exec(request.url ?? "/");
            let url = liburl.parse(request.url ?? "/", true);
            let offset = getOptionalInteger(url, "offset") ?? 0;
            let length = getOptionalInteger(url, "length") ?? 24;
            let user = handler.lookupUser(parts[1] ?? user_id);
            let shows = handler.getUserShows(user.user_id, offset, length, user_id);
            let payload = {
                shows
            };
            response.writeHead(200);
            response.end(JSON.stringify(payload));
        }
        handlesRequest(request) {
            return /^[/]api[/]users[/]([0-9a-f]{16})?[/]shows[/]/.test(request.url ?? "/");
        }
    }
    class UserRoute {
        handleRequest(request, response) {
            let user_id = getUserId(request);
            let parts = /^[/]api[/]users[/]([0-9a-f]{16})[/]/.exec(request.url ?? "/");
            let user = handler.lookupUser(parts[1]);
            let playlists = handler.getUserPlaylists(user.user_id, user_id);
            let payload = {
                user,
                playlists
            };
            response.writeHead(200);
            response.end(JSON.stringify(payload));
        }
        handlesRequest(request) {
            return /^[/]api[/]users[/]([0-9a-f]{16})[/]/.test(request.url ?? "/");
        }
    }
    class UsersRoute {
        handleRequest(request, response) {
            let user_id = getUserId(request);
            let parts = /^[/]api[/]users[/]([^/?]*)/.exec(request.url ?? "/");
            let query = decodeURIComponent(parts[1]);
            let url = liburl.parse(request.url ?? "/", true);
            let offset = getOptionalInteger(url, "offset") ?? 0;
            let length = getOptionalInteger(url, "length") ?? 24;
            let users = handler.searchForUsers(query, offset, length, user_id);
            let payload = {
                users
            };
            response.writeHead(200);
            response.end(JSON.stringify(payload));
        }
        handlesRequest(request) {
            return /^[/]api[/]users[/]([^/?]*)/.test(request.url ?? "/");
        }
    }
    class ActorShowsRoute {
        handleRequest(request, response) {
            let user_id = getUserId(request);
            let parts = /^[/]api[/]actors[/]([0-9a-f]{16})[/]shows[/]/.exec(request.url ?? "/");
            let actor_id = parts[1];
            let url = liburl.parse(request.url ?? "/", true);
            let offset = getOptionalInteger(url, "offset") ?? 0;
            let length = getOptionalInteger(url, "length") ?? 24;
            let shows = handler.getShowsFromActor(actor_id, user_id, offset, length);
            let payload = {
                shows
            };
            response.writeHead(200);
            response.end(JSON.stringify(payload));
        }
        handlesRequest(request) {
            return /^[/]api[/]actors[/]([0-9a-f]{16})[/]shows[/]/.test(request.url ?? "/");
        }
    }
    class ActorMoviesRoute {
        handleRequest(request, response) {
            let user_id = getUserId(request);
            let parts = /^[/]api[/]actors[/]([0-9a-f]{16})[/]movies[/]/.exec(request.url ?? "/");
            let actor_id = parts[1];
            let url = liburl.parse(request.url ?? "/", true);
            let offset = getOptionalInteger(url, "offset") ?? 0;
            let length = getOptionalInteger(url, "length") ?? 24;
            let movies = handler.getMoviesFromActor(actor_id, user_id, offset, length);
            let payload = {
                movies
            };
            response.writeHead(200);
            response.end(JSON.stringify(payload));
        }
        handlesRequest(request) {
            return /^[/]api[/]actors[/]([0-9a-f]{16})[/]movies[/]/.test(request.url ?? "/");
        }
    }
    class ActorRoute {
        handleRequest(request, response) {
            let user_id = getUserId(request);
            let parts = /^[/]api[/]actors[/]([0-9a-f]{16})[/]/.exec(request.url ?? "/");
            let actor_id = parts[1];
            let actor = handler.lookupActor(actor_id, user_id);
            let payload = {
                actor: actor
            };
            response.writeHead(200);
            response.end(JSON.stringify(payload));
        }
        handlesRequest(request) {
            return /^[/]api[/]actors[/]([0-9a-f]{16})[/]/.test(request.url ?? "/");
        }
    }
    class ActorsRoute {
        handleRequest(request, response) {
            let user_id = getUserId(request);
            let parts = /^[/]api[/]actors[/]([^/?]*)/.exec(request.url ?? "/");
            let query = decodeURIComponent(parts[1]);
            let url = liburl.parse(request.url ?? "/", true);
            let offset = getOptionalInteger(url, "offset") ?? 0;
            let length = getOptionalInteger(url, "length") ?? 24;
            let actors = handler.searchForActors(query, offset, length, user_id);
            let payload = {
                actors
            };
            response.writeHead(200);
            response.end(JSON.stringify(payload));
        }
        handlesRequest(request) {
            return /^[/]api[/]actors[/]([^/?]*)/.test(request.url ?? "/");
        }
    }
    class YearRoute {
        handleRequest(request, response) {
            let user_id = getUserId(request);
            let parts = /^[/]api[/]years[/]([0-9a-f]{16})[/]/.exec(request.url ?? "/");
            let year_id = parts[1];
            let year = handler.lookupYear(year_id, user_id);
            let url = liburl.parse(request.url ?? "/", true);
            let offset = getOptionalInteger(url, "offset") ?? 0;
            let length = getOptionalInteger(url, "length") ?? 24;
            let movies = handler.getMoviesFromYear(year_id, user_id, offset, length);
            let albums = handler.getAlbumsFromYear(year_id, user_id, offset, length);
            let payload = {
                year: year,
                movies: movies,
                albums: albums
            };
            response.writeHead(200);
            response.end(JSON.stringify(payload));
        }
        handlesRequest(request) {
            return /^[/]api[/]years[/]([0-9a-f]{16})[/]/.test(request.url ?? "/");
        }
    }
    class YearsRoute {
        handleRequest(request, response) {
            let user_id = getUserId(request);
            let parts = /^[/]api[/]years[/]([^/?]*)/.exec(request.url ?? "/");
            let query = decodeURIComponent(parts[1]);
            let url = liburl.parse(request.url ?? "/", true);
            let offset = getOptionalInteger(url, "offset") ?? 0;
            let length = getOptionalInteger(url, "length") ?? 24;
            let years = handler.searchForYears(query, offset, length, user_id);
            let payload = {
                years
            };
            response.writeHead(200);
            response.end(JSON.stringify(payload));
        }
        handlesRequest(request) {
            return /^[/]api[/]years[/]([^/?]*)/.test(request.url ?? "/");
        }
    }
    let router = new Router()
        .registerRoute(new UserAlbumsRoute())
        .registerRoute(new UserShowsRoute())
        .registerRoute(new AuthWithTokenRoute())
        .registerRoute(new AuthRoute())
        .registerRoute(new RegisterRoute())
        .registerRoute(new MovieMovieSuggestionsRoute())
        .registerRoute(new MovieRoute())
        .registerRoute(new MoviesRoute())
        .registerRoute(new ArtistRoute())
        .registerRoute(new ArtistsRoute())
        .registerRoute(new AlbumRoute())
        .registerRoute(new AlbumsRoute())
        .registerRoute(new EpisodeRoute())
        .registerRoute(new EpisodesRoute())
        .registerRoute(new ShowRoute())
        .registerRoute(new ShowsRoute())
        .registerRoute(new ActorShowsRoute())
        .registerRoute(new ActorMoviesRoute())
        .registerRoute(new ActorRoute())
        .registerRoute(new ActorsRoute())
        .registerRoute(new PlaylistRoute())
        .registerRoute(new PlaylistsRoute())
        .registerRoute(new TrackPlaylistsRoute())
        .registerRoute(new TrackRoute())
        .registerRoute(new TracksRoute())
        .registerRoute(new SeasonRoute())
        .registerRoute(new SeasonsRoute())
        .registerRoute(new DiscRoute())
        .registerRoute(new DiscsRoute())
        .registerRoute(new UserRoute())
        .registerRoute(new UsersRoute())
        .registerRoute(new CuesRoute())
        .registerRoute(new GenreShowsRoute())
        .registerRoute(new GenreMoviesRoute())
        .registerRoute(new GenreRoute())
        .registerRoute(new GenresRoute())
        .registerRoute(new YearRoute())
        .registerRoute(new YearsRoute())
        .registerRoute(new SearchRoute());
    let handleRequest = (request, response) => {
        try {
            router.route(request, response);
        }
        catch (error) {
            response.writeHead(500);
            response.end(JSON.stringify({ error: "" + error }));
        }
    };
    exports.handleRequest = handleRequest;
});
define("build/utils", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatTimestamp = exports.join = void 0;
    function join(...parameters) {
        return parameters.map((parameter) => {
            return String(parameter);
        }).join("");
    }
    exports.join = join;
    function formatTimestamp(ms) {
        let s = Math.floor(ms / 1000);
        ms -= (s * 1000);
        let m = Math.floor(s / 60);
        s -= (m * 60);
        let h = Math.floor(m / 60);
        m -= (h * 60);
        let fh = join("00", h).slice(-2);
        let fm = join("00", m).slice(-2);
        let fs = join("00", s).slice(-2);
        let fms = join("000", ms).slice(-3);
        return join(fh, ":", fm, ":", fs, ".", fms);
    }
    exports.formatTimestamp = formatTimestamp;
});
define("build/server/ffprobe", ["require", "exports", "node_modules/@joelek/ts-autoguard/build/autoguard-lib/index"], function (require, exports, ts_autoguard_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.FormatResult = exports.Format = exports.StreamsResult = exports.Stream = exports.VideoStream = exports.SubtitleStream = exports.ImageStream = exports.AudioStream = exports.StreamCommon = exports.FramesResult = exports.VideoFrame = void 0;
    exports.VideoFrame = ts_autoguard_1.guards.Object.of({
        "pkt_pts_time": ts_autoguard_1.guards.String
    });
    exports.FramesResult = ts_autoguard_1.guards.Object.of({
        "frames": ts_autoguard_1.guards.Array.of(ts_autoguard_1.guards.Reference.of(() => exports.VideoFrame))
    });
    exports.StreamCommon = ts_autoguard_1.guards.Object.of({
        "codec_name": ts_autoguard_1.guards.String
    });
    exports.AudioStream = ts_autoguard_1.guards.Intersection.of(ts_autoguard_1.guards.Reference.of(() => exports.StreamCommon), ts_autoguard_1.guards.Object.of({
        "codec_type": ts_autoguard_1.guards.StringLiteral.of("audio"),
        "start_time": ts_autoguard_1.guards.String,
        "duration": ts_autoguard_1.guards.String
    }));
    exports.ImageStream = ts_autoguard_1.guards.Intersection.of(ts_autoguard_1.guards.Reference.of(() => exports.StreamCommon), ts_autoguard_1.guards.Object.of({
        "codec_type": ts_autoguard_1.guards.StringLiteral.of("video"),
        "codec_time_base": ts_autoguard_1.guards.StringLiteral.of("0/1"),
        "width": ts_autoguard_1.guards.Number,
        "height": ts_autoguard_1.guards.Number
    }));
    exports.SubtitleStream = ts_autoguard_1.guards.Intersection.of(ts_autoguard_1.guards.Reference.of(() => exports.StreamCommon), ts_autoguard_1.guards.Object.of({
        "codec_type": ts_autoguard_1.guards.StringLiteral.of("subtitle")
    }));
    exports.VideoStream = ts_autoguard_1.guards.Intersection.of(ts_autoguard_1.guards.Reference.of(() => exports.StreamCommon), ts_autoguard_1.guards.Object.of({
        "codec_type": ts_autoguard_1.guards.StringLiteral.of("video"),
        "start_time": ts_autoguard_1.guards.String,
        "duration": ts_autoguard_1.guards.String,
        "width": ts_autoguard_1.guards.Number,
        "height": ts_autoguard_1.guards.Number
    }));
    exports.Stream = ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Reference.of(() => exports.AudioStream), ts_autoguard_1.guards.Reference.of(() => exports.ImageStream), ts_autoguard_1.guards.Reference.of(() => exports.SubtitleStream), ts_autoguard_1.guards.Reference.of(() => exports.VideoStream));
    exports.StreamsResult = ts_autoguard_1.guards.Object.of({
        "streams": ts_autoguard_1.guards.Array.of(ts_autoguard_1.guards.Reference.of(() => exports.Stream))
    });
    exports.Format = ts_autoguard_1.guards.Object.of({
        "format_name": ts_autoguard_1.guards.String,
        "tags": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.Object.of({
            "title": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.String),
            "date": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.String),
            "comment": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.String),
            "show": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.String),
            "episode_id": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.String),
            "episode_sort": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.String),
            "season_number": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.String),
            "track": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.String),
            "artist": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.String),
            "album_artist": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.String),
            "album": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.String),
            "disc": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.String)
        }))
    });
    exports.FormatResult = ts_autoguard_1.guards.Object.of({
        "format": ts_autoguard_1.guards.Reference.of(() => exports.Format)
    });
    exports.Autoguard = {
        "VideoFrame": exports.VideoFrame,
        "FramesResult": exports.FramesResult,
        "StreamCommon": exports.StreamCommon,
        "AudioStream": exports.AudioStream,
        "ImageStream": exports.ImageStream,
        "SubtitleStream": exports.SubtitleStream,
        "VideoStream": exports.VideoStream,
        "Stream": exports.Stream,
        "StreamsResult": exports.StreamsResult,
        "Format": exports.Format,
        "FormatResult": exports.FormatResult
    };
});
define("build/server/keyframes", ["require", "exports", "child_process", "build/server/ffprobe"], function (require, exports, libcp, libffprobe) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getKeyframeSegments = exports.getKeyframeOffsets = exports.getStreams = exports.combineOffsets = exports.makeSegments = void 0;
    function makeSegments(offsets_ms) {
        let segments = new Array();
        for (let i = 0; i + 1 < offsets_ms.length; i++) {
            segments.push({
                offset_ms: offsets_ms[i],
                duration_ms: offsets_ms[i + 1] - offsets_ms[i]
            });
        }
        return segments;
    }
    exports.makeSegments = makeSegments;
    function combineOffsets(offsets_ms, target_duration_ms) {
        let last_offset_ms = 0 - Infinity;
        let combined_offsets_ms = new Array();
        for (let i = 1; i < offsets_ms.length; i++) {
            if (offsets_ms[i] - last_offset_ms > target_duration_ms) {
                last_offset_ms = offsets_ms[i - 1];
                combined_offsets_ms.push(last_offset_ms);
            }
        }
        return combined_offsets_ms;
    }
    exports.combineOffsets = combineOffsets;
    async function getStreams(paths) {
        return new Promise((resolve, reject) => {
            let ffprobe = libcp.spawn("ffprobe", [
                "-hide_banner",
                "-i", paths.join("/"),
                "-show_streams",
                "-show_entries", "stream=start_time,duration",
                "-of", "json"
            ]);
            let chunks = new Array();
            ffprobe.stdout.on("data", (chunk) => {
                chunks.push(chunk);
            });
            ffprobe.on("exit", () => {
                let string = Buffer.concat(chunks).toString();
                let json = libffprobe.StreamsResult.as(JSON.parse(string));
                let streams = json.streams.filter((stream) => libffprobe.VideoStream.is(stream)).map((stream) => {
                    let offset_ms = Math.round(Number.parseFloat(stream.start_time) * 1000);
                    let duration_ms = Math.round(Number.parseFloat(stream.duration) * 1000);
                    return {
                        offset_ms,
                        duration_ms
                    };
                });
                resolve(streams);
            });
        });
    }
    exports.getStreams = getStreams;
    async function getKeyframeOffsets(paths, streamIndex) {
        return new Promise((resolve, reject) => {
            let ffprobe = libcp.spawn("ffprobe", [
                "-hide_banner",
                "-i", paths.join("/"),
                "-select_streams", `${streamIndex}`,
                "-skip_frame", "nokey",
                "-show_frames",
                "-show_entries", "frame=pkt_pts_time",
                "-of", "json"
            ]);
            let chunks = new Array();
            ffprobe.stdout.on("data", (chunk) => {
                chunks.push(chunk);
            });
            ffprobe.on("exit", () => {
                let string = Buffer.concat(chunks).toString();
                try {
                    let json = libffprobe.FramesResult.as(JSON.parse(string));
                    let frames = json.frames.map((frame) => {
                        return Math.round(Number.parseFloat(frame.pkt_pts_time) * 1000);
                    });
                    resolve(frames);
                }
                catch (error) {
                    //console.log(`Keyframes failed for ${paths.join("/")}!`);
                    reject(error);
                }
            });
        });
    }
    exports.getKeyframeOffsets = getKeyframeOffsets;
    async function getKeyframeSegments(paths, streamIndex, targetDurationMs) {
        let streams = await getStreams(paths);
        let keyframeOffsets = await getKeyframeOffsets(paths, streamIndex);
        let stream = streams[streamIndex];
        let combinedOffsets = combineOffsets([...keyframeOffsets, stream.duration_ms], targetDurationMs);
        let segments = makeSegments([...combinedOffsets, stream.duration_ms]);
        return segments;
    }
    exports.getKeyframeSegments = getKeyframeSegments;
});
define("build/server/subsearch", ["require", "exports", "fs", "child_process", "crypto", "build/database/indexer", "build/is", "build/utils", "build/server/keyframes"], function (require, exports, libfs, libcp, libcrypto, indexer, is, utils, keyframes) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generateMeme = exports.generateStill = void 0;
    function getMediaFile(subtitle) {
        let video_files = indexer.getVideoFilesFromSubtitleFile.lookup(subtitle.file_id).collect();
        return indexer.files.lookup(video_files[0].video_file_id);
    }
    function createWorkingDirectory(cb) {
        let id = libcrypto.randomBytes(8).toString("hex");
        let wd = [".", "private", "jobs", id];
        libfs.mkdirSync(wd.join("/"), { recursive: true });
        return cb(wd, id);
    }
    function renameFile(source, target) {
        libfs.mkdirSync(target.slice(0, -1).join("/"), { recursive: true });
        libfs.renameSync(source.join("/"), target.join("/"));
    }
    function deleteTree(root) {
        let stats = libfs.statSync(root);
        if (stats.isDirectory()) {
            let nodes = libfs.readdirSync(root).map((node) => {
                return root + "/" + node;
            });
            nodes.forEach(deleteTree);
            libfs.rmdirSync(root);
        }
        else if (stats.isFile()) {
            libfs.unlinkSync(root);
        }
    }
    async function generateStill(target, file) {
        let path = indexer.getPath(file);
        let offsets = await keyframes.getKeyframeOffsets(path, 0);
        let offset = offsets[Math.floor(offsets.length / 2)];
        return new Promise((resolve, reject) => {
            createWorkingDirectory((wd, id) => {
                let still = [...wd, "still.jpeg"];
                let cp = libcp.spawn("ffmpeg", [
                    "-ss", utils.formatTimestamp(offset),
                    "-i", path.join("/"),
                    "-q:v", "1",
                    "-frames:v", "1",
                    "-f", "singlejpeg",
                    "-fflags", "+bitexact",
                    "-map_metadata", "-1",
                    still.join("/"),
                    "-y"
                ]);
                cp.on("error", () => {
                    deleteTree(wd.join("/"));
                    return reject();
                });
                cp.on("exit", () => {
                    renameFile(still, target);
                    deleteTree(wd.join("/"));
                    return resolve();
                });
            });
        });
    }
    exports.generateStill = generateStill;
    function generateMeme(target, cue, cb) {
        let subtitle = indexer.subtitles.lookup(cue.subtitle_id);
        let file_subtitle = indexer.files.lookup(subtitle.file_id);
        const file_media = getMediaFile(subtitle);
        if (file_media == null) {
            return cb();
        }
        else {
            createWorkingDirectory((wd, id) => {
                let subtitle = [...wd, "subtitle.vtt"];
                let palette = [...wd, "palette.png"];
                let meme = [...wd, "meme.gif"];
                let cp = libcp.spawn("ffmpeg", [
                    "-ss", utils.formatTimestamp(cue.start_ms),
                    "-t", utils.formatTimestamp(Math.min(cue.duration_ms, 5000)),
                    "-i", indexer.getPath(file_subtitle).join("/"),
                    subtitle.join("/"),
                    "-y"
                ]);
                cp.on("error", () => {
                    console.log("ffmpeg command failed!");
                    deleteTree(wd.join("/"));
                    return cb();
                });
                cp.on("exit", () => {
                    let cp = libcp.spawn("ffmpeg", [
                        "-ss", utils.formatTimestamp(cue.start_ms),
                        "-t", utils.formatTimestamp(Math.min(cue.duration_ms, 5000)),
                        "-i", indexer.getPath(file_media).join("/"),
                        "-vf", "fps=15,scale=w=384:h=216:force_original_aspect_ratio=decrease,pad=384:216:-1:-1,subtitles=" + subtitle.join("/") + ":force_style='Bold=1,Fontsize=24,Outline=2',palettegen",
                        palette.join("/"),
                        "-y"
                    ]);
                    cp.on("exit", () => {
                        let cp = libcp.spawn("ffmpeg", [
                            "-ss", utils.formatTimestamp(cue.start_ms),
                            "-t", utils.formatTimestamp(Math.min(cue.duration_ms, 5000)),
                            "-i", indexer.getPath(file_media).join("/"),
                            "-i", palette.join("/"),
                            "-filter_complex", "fps=15,scale=w=384:h=216:force_original_aspect_ratio=decrease,pad=384:216:-1:-1,subtitles=" + subtitle.join("/") + ":force_style='Bold=1,Fontsize=24,Outline=2'[x];[x][1:v]paletteuse",
                            "-map_metadata", "-1",
                            meme.join("/"),
                            "-y"
                        ]);
                        cp.on("exit", () => {
                            renameFile(meme, target);
                            deleteTree(wd.join("/"));
                            return cb();
                        });
                    });
                });
            });
        }
    }
    exports.generateMeme = generateMeme;
    const queue = [];
    async function processQueue() {
        let job = queue.pop();
        if (is.absent(job)) {
            return;
        }
        try {
            await generateStill(job.target, job.file);
        }
        catch (error) { }
        setTimeout(processQueue, 10 * 1000);
    }
    for (let episode of indexer.video_files) {
        let target = [".", "private", "stills", episode.file_id];
        if (!libfs.existsSync(target.join("/"))) {
            let file = indexer.files.lookup(episode.file_id);
            queue.push({ target, file });
        }
    }
    setTimeout(processQueue);
});
define("build/observers/index", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ArrayObservable = exports.computed = exports.ObservableClass = void 0;
    class ObservableClass {
        constructor(state) {
            this.state = state;
            this.observers = new Array();
        }
        addObserver(observer) {
            let observable = new ObservableClass(observer(this.state));
            this.observers.push((state) => {
                observable.updateState(observer(state));
            });
            return observable.addObserver.bind(observable);
        }
        getState() {
            return this.state;
        }
        updateState(state) {
            if (state === this.state) {
                return;
            }
            this.state = state;
            for (let observer of this.observers) {
                observer(this.state);
            }
        }
    }
    exports.ObservableClass = ObservableClass;
    function computed(computer, ...observables) {
        let observable = new ObservableClass(computer(...observables.map((observable) => observable.getState())));
        let updater = () => {
            observable.updateState(computer(...observables.map((observable) => observable.getState())));
        };
        for (let observable of observables) {
            observable.addObserver(updater);
        }
        return observable;
    }
    exports.computed = computed;
    class ArrayObservable {
        constructor(state) {
            this.state = state;
            this.observers = new Array();
        }
        addObserver(observer) {
            this.observers.push(observer);
            for (let value of this.state) {
                observer.onappend?.(value);
            }
        }
        compute(observer) {
            let observable = new ObservableClass(observer(this.state));
            this.observers.push({
                onappend: (state) => {
                    observable.updateState(observer(this.state));
                },
                onsplice: (state, index) => {
                    observable.updateState(observer(this.state));
                }
            });
            return observable.addObserver.bind(observable);
        }
        getState() {
            return this.state;
        }
        append(state) {
            this.state.push(state);
            for (let observer of this.observers) {
                observer.onappend?.(state);
            }
        }
        splice(index) {
            if (index < 0 || index >= this.state.length) {
                throw `Expected an index of at most ${this.state.length}, got ${index}!`;
            }
            let state = this.state[index];
            this.state.splice(index, 1);
            for (let observer of this.observers) {
                observer.onsplice?.(state, index);
            }
        }
        update(state) {
            for (let i = this.state.length - 1; i >= 0; i--) {
                this.splice(i);
            }
            for (let v of state) {
                this.append(v);
            }
        }
    }
    exports.ArrayObservable = ArrayObservable;
});
define("build/player/schema/objects", ["require", "exports", "build/api/schema/objects", "build/api/schema/objects", "build/api/schema/objects", "build/api/schema/objects", "build/api/schema/objects", "build/api/schema/objects", "build/api/schema/objects", "build/api/schema/objects", "build/api/schema/objects", "node_modules/@joelek/ts-autoguard/build/autoguard-lib/index"], function (require, exports, objects_1, objects_2, objects_3, objects_4, objects_5, objects_6, objects_7, objects_8, objects_9, ts_autoguard_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.Session = exports.Device = exports.ContextItem = exports.Context = exports.ContextEpisode = exports.ContextSeason = exports.ContextShow = exports.ContextMovie = exports.ContextPlaylist = exports.ContextTrack = exports.ContextDisc = exports.ContextArtist = exports.ContextAlbum = void 0;
    exports.ContextAlbum = ts_autoguard_1.guards.Reference.of(() => objects_1.Album);
    exports.ContextArtist = ts_autoguard_1.guards.Reference.of(() => objects_2.Artist);
    exports.ContextDisc = ts_autoguard_1.guards.Reference.of(() => objects_3.Disc);
    exports.ContextTrack = ts_autoguard_1.guards.Reference.of(() => objects_9.Track);
    exports.ContextPlaylist = ts_autoguard_1.guards.Reference.of(() => objects_6.Playlist);
    exports.ContextMovie = ts_autoguard_1.guards.Reference.of(() => objects_5.Movie);
    exports.ContextShow = ts_autoguard_1.guards.Reference.of(() => objects_8.Show);
    exports.ContextSeason = ts_autoguard_1.guards.Reference.of(() => objects_7.Season);
    exports.ContextEpisode = ts_autoguard_1.guards.Reference.of(() => objects_4.Episode);
    exports.Context = ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Reference.of(() => exports.ContextAlbum), ts_autoguard_1.guards.Reference.of(() => exports.ContextArtist), ts_autoguard_1.guards.Reference.of(() => exports.ContextDisc), ts_autoguard_1.guards.Reference.of(() => exports.ContextTrack), ts_autoguard_1.guards.Reference.of(() => exports.ContextPlaylist), ts_autoguard_1.guards.Reference.of(() => exports.ContextMovie), ts_autoguard_1.guards.Reference.of(() => exports.ContextShow), ts_autoguard_1.guards.Reference.of(() => exports.ContextSeason), ts_autoguard_1.guards.Reference.of(() => exports.ContextEpisode));
    exports.ContextItem = ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Reference.of(() => exports.ContextTrack), ts_autoguard_1.guards.Reference.of(() => exports.ContextMovie), ts_autoguard_1.guards.Reference.of(() => exports.ContextEpisode));
    exports.Device = ts_autoguard_1.guards.Object.of({
        "id": ts_autoguard_1.guards.String,
        "protocol": ts_autoguard_1.guards.String,
        "name": ts_autoguard_1.guards.String,
        "type": ts_autoguard_1.guards.String
    });
    exports.Session = ts_autoguard_1.guards.Object.of({
        "context": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.Reference.of(() => exports.Context)),
        "device": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.Reference.of(() => exports.Device)),
        "index": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.Number),
        "playback": ts_autoguard_1.guards.Boolean,
        "progress": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.Number)
    });
    exports.Autoguard = {
        "ContextAlbum": exports.ContextAlbum,
        "ContextArtist": exports.ContextArtist,
        "ContextDisc": exports.ContextDisc,
        "ContextTrack": exports.ContextTrack,
        "ContextPlaylist": exports.ContextPlaylist,
        "ContextMovie": exports.ContextMovie,
        "ContextShow": exports.ContextShow,
        "ContextSeason": exports.ContextSeason,
        "ContextEpisode": exports.ContextEpisode,
        "Context": exports.Context,
        "ContextItem": exports.ContextItem,
        "Device": exports.Device,
        "Session": exports.Session
    };
});
define("build/player/schema/messages", ["require", "exports", "build/player/schema/objects", "build/player/schema/objects", "node_modules/@joelek/ts-autoguard/build/autoguard-lib/index"], function (require, exports, objects_1, objects_2, ts_autoguard_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.SetToken = exports.SetProgress = exports.SetPlayback = exports.SetLocalDevice = exports.SetIndex = exports.SetDevices = exports.SetDevice = exports.SetContext = void 0;
    exports.SetContext = ts_autoguard_1.guards.Object.of({
        "context": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.Reference.of(() => objects_1.Context))
    });
    exports.SetDevice = ts_autoguard_1.guards.Object.of({
        "device": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.Reference.of(() => objects_2.Device))
    });
    exports.SetDevices = ts_autoguard_1.guards.Object.of({
        "devices": ts_autoguard_1.guards.Array.of(ts_autoguard_1.guards.Reference.of(() => objects_2.Device))
    });
    exports.SetIndex = ts_autoguard_1.guards.Object.of({
        "index": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.Number)
    });
    exports.SetLocalDevice = ts_autoguard_1.guards.Object.of({
        "device": ts_autoguard_1.guards.Reference.of(() => objects_2.Device)
    });
    exports.SetPlayback = ts_autoguard_1.guards.Object.of({
        "playback": ts_autoguard_1.guards.Boolean
    });
    exports.SetProgress = ts_autoguard_1.guards.Object.of({
        "progress": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.Number)
    });
    exports.SetToken = ts_autoguard_1.guards.Object.of({
        "token": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.String)
    });
    exports.Autoguard = {
        "SetContext": exports.SetContext,
        "SetDevice": exports.SetDevice,
        "SetDevices": exports.SetDevices,
        "SetIndex": exports.SetIndex,
        "SetLocalDevice": exports.SetLocalDevice,
        "SetPlayback": exports.SetPlayback,
        "SetProgress": exports.SetProgress,
        "SetToken": exports.SetToken
    };
});
define("build/player/schema/index", ["require", "exports", "build/player/schema/messages", "build/player/schema/objects"], function (require, exports, messages, objects) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.objects = exports.messages = void 0;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.objects = exports.messages = void 0;
    exports.messages = messages;
    exports.objects = objects;
});
define("node_modules/@joelek/ts-sockets/build/shared", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StatusCode = exports.ReadyState = void 0;
    var ReadyState;
    (function (ReadyState) {
        ReadyState[ReadyState["CONNECTING"] = 0] = "CONNECTING";
        ReadyState[ReadyState["OPEN"] = 1] = "OPEN";
        ReadyState[ReadyState["CLOSING"] = 2] = "CLOSING";
        ReadyState[ReadyState["CLOSED"] = 3] = "CLOSED";
    })(ReadyState = exports.ReadyState || (exports.ReadyState = {}));
    ;
    var StatusCode;
    (function (StatusCode) {
        StatusCode[StatusCode["NORMAL"] = 1000] = "NORMAL";
        StatusCode[StatusCode["GOING_AWAY"] = 1001] = "GOING_AWAY";
        StatusCode[StatusCode["PROTOCOL_ERROR"] = 1002] = "PROTOCOL_ERROR";
        StatusCode[StatusCode["DATA_TYPE_NOT_ACCEPTED"] = 1003] = "DATA_TYPE_NOT_ACCEPTED";
        StatusCode[StatusCode["RESERVED_1004"] = 1004] = "RESERVED_1004";
        StatusCode[StatusCode["RESERVED_1005"] = 1005] = "RESERVED_1005";
        StatusCode[StatusCode["RESERVED_1006"] = 1006] = "RESERVED_1006";
        StatusCode[StatusCode["BAD_DATA_TYPE"] = 1007] = "BAD_DATA_TYPE";
        StatusCode[StatusCode["POLICY_VIOLATION"] = 1008] = "POLICY_VIOLATION";
        StatusCode[StatusCode["MESSAGE_TOO_BIG"] = 1009] = "MESSAGE_TOO_BIG";
        StatusCode[StatusCode["CLIENT_EXPECTED_EXTENSION"] = 1010] = "CLIENT_EXPECTED_EXTENSION";
        StatusCode[StatusCode["SERVER_UNEXPECTED_CONDITION"] = 1011] = "SERVER_UNEXPECTED_CONDITION";
        StatusCode[StatusCode["RESERVED_1015"] = 1015] = "RESERVED_1015";
    })(StatusCode = exports.StatusCode || (exports.StatusCode = {}));
    ;
});
define("build/typesockets/schema", ["require", "exports", "node_modules/@joelek/ts-autoguard/build/autoguard-lib/index"], function (require, exports, ts_autoguard_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.Envelope = void 0;
    exports.Envelope = ts_autoguard_1.guards.Object.of({
        "type": ts_autoguard_1.guards.String,
        "data": ts_autoguard_1.guards.Any,
        "id": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.String)
    });
    exports.Autoguard = {
        "Envelope": exports.Envelope
    };
});
define("build/typesockets/shared", ["require", "exports", "build/typesockets/schema", "build/is"], function (require, exports, schema, is) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Serializer = void 0;
    class Serializer {
        constructor(guards) {
            this.guards = guards;
        }
        deserialize(string, cb) {
            let envelope = schema.Envelope.as(JSON.parse(string));
            let id = envelope.id;
            let type = envelope.type;
            let data = envelope.data;
            let guard = this.guards[type];
            if (is.absent(guard)) {
                throw `Unknown message type "${type}"!`;
            }
            cb(type, guard.as(data), id);
        }
        serialize(type, data, id) {
            return JSON.stringify({
                type,
                data,
                id
            });
        }
    }
    exports.Serializer = Serializer;
    ;
});
define("build/typesockets/client", ["require", "exports", "node_modules/@joelek/ts-stdlib/build/index", "node_modules/@joelek/ts-sockets/build/shared", "build/typesockets/shared", "build/is"], function (require, exports, stdlib, sockets, shared, is) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TypeSocketClient = void 0;
    ;
    class TypeSocketClient {
        constructor(url, factory, guards) {
            this.nextConnectionAttemptDelayFactor = 2.0 + Math.random();
            this.nextConnectionAttemptDelay = 2000;
            this.router = new stdlib.routing.NamespacedMessageRouter();
            this.serializer = new shared.Serializer(guards);
            this.url = url;
            this.factory = factory;
            this.socket = this.makeSocket();
            this.requests = new Map();
        }
        makeId() {
            let string = "";
            for (let i = 0; i < 32; i++) {
                let number = Math.floor(Math.random() * 16);
                string += number.toString(16);
            }
            return string;
        }
        makeSocket() {
            let socket = this.factory(this.url);
            socket.addEventListener("close", this.onClose.bind(this));
            socket.addEventListener("error", this.onError.bind(this));
            socket.addEventListener("message", this.onMessage.bind(this));
            socket.addEventListener("open", this.onOpen.bind(this));
            return socket;
        }
        onClose(event) {
            this.router.route("sys", "disconnect", {});
        }
        onError(event) {
            setTimeout(() => {
                this.socket = this.makeSocket();
            }, this.nextConnectionAttemptDelay);
            this.nextConnectionAttemptDelay = Math.round(this.nextConnectionAttemptDelay * this.nextConnectionAttemptDelayFactor);
        }
        onMessage(event) {
            try {
                this.serializer.deserialize(event.data, (type, data, id) => {
                    this.router.route("sys", "message", {
                        type,
                        data
                    });
                    if (is.present(id)) {
                        let callback = this.requests.get(id);
                        if (is.present(callback)) {
                            this.requests.delete(id);
                            callback(type, data);
                        }
                    }
                    this.router.route("app", type, data);
                });
            }
            catch (error) {
                this.socket.close();
            }
        }
        onOpen(event) {
            this.nextConnectionAttemptDelay = 2000;
            this.router.route("sys", "connect", {});
        }
        queue(payload) {
            if (this.socket.readyState === sockets.ReadyState.OPEN) {
                this.socket.send(payload);
            }
            else {
                let onopen = () => {
                    this.socket.removeEventListener("open", onopen);
                    this.socket.send(payload);
                };
                this.socket.addEventListener("open", onopen);
            }
        }
        addEventListener(namespace, type, listener) {
            this.router.addObserver(namespace, type, listener);
        }
        close() {
            this.socket.close();
        }
        reconnect() {
            if (this.socket.readyState === sockets.ReadyState.CLOSED) {
                this.socket = this.makeSocket();
            }
        }
        removeEventListener(namespace, type, listener) {
            this.router.addObserver(namespace, type, listener);
        }
        request(type, response_type, data) {
            return new Promise((resolve, reject) => {
                let id = this.makeId();
                let payload = this.serializer.serialize(type, data, id);
                this.requests.set(id, (type, data) => {
                    if (type !== response_type) {
                        reject(`Received response with type "${type}" when expecting "${response_type}"!`);
                    }
                    else {
                        resolve(data);
                    }
                });
                this.queue(payload);
            });
        }
        send(type, data) {
            let payload = this.serializer.serialize(type, data);
            this.queue(payload);
        }
    }
    exports.TypeSocketClient = TypeSocketClient;
    ;
});
define("build/player/client", ["require", "exports", "build/is", "build/observers/index", "build/player/schema/index", "build/typesockets/client"], function (require, exports, is, observers, schema, typesockets) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ContextClient = void 0;
    class ContextClient {
        constructor(url, factory = (url) => new WebSocket(url)) {
            this.estimatedProgress = new observers.ObservableClass(undefined);
            this.estimatedProgressTimestamp = new observers.ObservableClass(undefined);
            this.token = new observers.ObservableClass(undefined);
            this.localDevice = new observers.ObservableClass(undefined);
            this.devices = new observers.ArrayObservable(new Array());
            this.device = new observers.ObservableClass(undefined);
            this.isDeviceLocal = new observers.ObservableClass(false);
            this.isDeviceRemote = new observers.ObservableClass(false);
            this.context = new observers.ObservableClass(undefined);
            this.contextPath = new observers.ObservableClass(undefined);
            this.flattenedContext = new observers.ObservableClass(undefined);
            this.lastIndex = new observers.ObservableClass(undefined);
            this.lastEntry = new observers.ObservableClass(undefined);
            this.lastLocalEntry = new observers.ObservableClass(undefined);
            this.currentIndex = new observers.ObservableClass(undefined);
            this.currentEntry = new observers.ObservableClass(undefined);
            this.currentLocalEntry = new observers.ObservableClass(undefined);
            this.nextIndex = new observers.ObservableClass(undefined);
            this.nextEntry = new observers.ObservableClass(undefined);
            this.nextLocalEntry = new observers.ObservableClass(undefined);
            this.playback = new observers.ObservableClass(false);
            this.progress = new observers.ObservableClass(undefined);
            this.localPlayback = new observers.ObservableClass(false);
            this.canPlayLast = new observers.ObservableClass(false);
            this.canPlayCurrent = new observers.ObservableClass(false);
            this.canPlayNext = new observers.ObservableClass(false);
            this.isCurrentEntryVideo = new observers.ObservableClass(false);
            this.isOnline = new observers.ObservableClass(false);
            this.tsc = new typesockets.TypeSocketClient(url, factory, schema.messages.Autoguard);
            this.tsc.addEventListener("sys", "connect", () => {
                this.isOnline.updateState(true);
            });
            this.tsc.addEventListener("sys", "disconnect", () => {
                this.isOnline.updateState(false);
            });
            this.context.addObserver((context) => {
                if (is.present(context)) {
                    if (schema.objects.ContextAlbum.is(context)) {
                        let files = [];
                        let album = context;
                        for (let disc of album.discs) {
                            files.push(...disc.tracks);
                        }
                        this.flattenedContext.updateState(files);
                    }
                    else if (schema.objects.ContextArtist.is(context)) {
                        let files = [];
                        let artist = context;
                        for (let album of artist.albums) {
                            for (let disc of album.discs) {
                                files.push(...disc.tracks);
                            }
                        }
                        this.flattenedContext.updateState(files);
                    }
                    else if (schema.objects.ContextEpisode.is(context)) {
                        let files = [];
                        let episode = context;
                        files.push(episode);
                        this.flattenedContext.updateState(files);
                    }
                    else if (schema.objects.ContextMovie.is(context)) {
                        let files = [];
                        let movie = context;
                        files.push(movie);
                        this.flattenedContext.updateState(files);
                    }
                    else if (schema.objects.ContextPlaylist.is(context)) {
                        let files = [];
                        let playlist = context;
                        for (let item of playlist.items) {
                            files.push(item.track);
                        }
                        this.flattenedContext.updateState(files);
                    }
                    else if (schema.objects.ContextSeason.is(context)) {
                        let files = [];
                        let season = context;
                        files.push(...season.episodes);
                        this.flattenedContext.updateState(files);
                    }
                    else if (schema.objects.ContextShow.is(context)) {
                        let files = [];
                        let show = context;
                        for (let season of show.seasons) {
                            files.push(...season.episodes);
                        }
                        this.flattenedContext.updateState(files);
                    }
                    else if (schema.objects.ContextTrack.is(context)) {
                        let files = [];
                        let track = context;
                        files.push(track);
                        this.flattenedContext.updateState(files);
                    }
                    else {
                        throw `Expected code to be unreachable!`;
                    }
                }
            });
            {
                let computer = () => {
                    let context = this.context.getState();
                    let currentIndex = this.currentIndex.getState();
                    if (is.present(context) && is.present(currentIndex)) {
                        if (schema.objects.ContextAlbum.is(context)) {
                            let discIndex = 0;
                            let trackIndex = currentIndex;
                            let album = context;
                            let discs = album.discs;
                            for (let d = 0; d < discs.length; d++) {
                                let length = discs[d].tracks.length;
                                if (trackIndex >= length) {
                                    discIndex += 1;
                                    trackIndex -= length;
                                }
                                else {
                                    break;
                                }
                            }
                            return this.contextPath.updateState([
                                context.album_id,
                                context.discs[discIndex].disc_id,
                                context.discs[discIndex].tracks[trackIndex].track_id
                            ]);
                        }
                        else if (schema.objects.ContextArtist.is(context)) {
                            let albumIndex = 0;
                            let discIndex = 0;
                            let trackIndex = currentIndex;
                            let artist = context;
                            let albums = artist.albums;
                            outer: for (let a = 0; a < albums.length; a++) {
                                let discs = albums[a].discs;
                                for (let d = 0; d < discs.length; d++) {
                                    let length = discs[d].tracks.length;
                                    if (trackIndex >= length) {
                                        discIndex += 1;
                                        trackIndex -= length;
                                    }
                                    else {
                                        break outer;
                                    }
                                }
                                albumIndex += 1;
                                discIndex = 0;
                            }
                            return this.contextPath.updateState([
                                context.artist_id,
                                context.albums[albumIndex].album_id,
                                context.albums[albumIndex].discs[discIndex].disc_id,
                                context.albums[albumIndex].discs[discIndex].tracks[trackIndex].track_id
                            ]);
                        }
                        else if (schema.objects.ContextEpisode.is(context)) {
                            return this.contextPath.updateState([
                                context.episode_id
                            ]);
                        }
                        else if (schema.objects.ContextMovie.is(context)) {
                            return this.contextPath.updateState([
                                context.movie_id
                            ]);
                        }
                        else if (schema.objects.ContextPlaylist.is(context)) {
                            let itemIndex = currentIndex;
                            return this.contextPath.updateState([
                                context.playlist_id,
                                context.items[itemIndex].track.track_id
                            ]);
                        }
                        else if (schema.objects.ContextShow.is(context)) {
                            let seasonIndex = 0;
                            let episodeIndex = currentIndex;
                            let show = context;
                            let seasons = show.seasons;
                            for (let d = 0; d < seasons.length; d++) {
                                let length = seasons[d].episodes.length;
                                if (episodeIndex >= length) {
                                    seasonIndex += 1;
                                    episodeIndex -= length;
                                }
                                else {
                                    break;
                                }
                            }
                            return this.contextPath.updateState([
                                context.show_id,
                                context.seasons[seasonIndex].season_id,
                                context.seasons[seasonIndex].episodes[episodeIndex].episode_id
                            ]);
                        }
                        else if (schema.objects.ContextSeason.is(context)) {
                            let episodeIndex = currentIndex;
                            return this.contextPath.updateState([
                                context.season_id,
                                context.episodes[episodeIndex].episode_id
                            ]);
                        }
                        else if (schema.objects.ContextTrack.is(context)) {
                            return this.contextPath.updateState([
                                context.track_id
                            ]);
                        }
                        else {
                            throw `Expected code to be unreachable!`;
                        }
                    }
                    this.contextPath.updateState(undefined);
                };
                this.context.addObserver(computer);
                this.currentIndex.addObserver(computer);
            }
            this.lastEntry.addObserver((lastEntry) => {
                this.canPlayLast.updateState(is.present(lastEntry));
            });
            this.currentEntry.addObserver((currentEntry) => {
                this.canPlayCurrent.updateState(is.present(currentEntry));
            });
            this.nextEntry.addObserver((nextEntry) => {
                this.canPlayNext.updateState(is.present(nextEntry));
            });
            this.progress.addObserver((progress) => {
                this.estimatedProgress.updateState(progress);
                this.estimatedProgressTimestamp.updateState(Date.now());
            });
            this.playback.addObserver((playback) => {
                let estimatedProgress = this.estimatedProgress.getState();
                let estimatedProgressTimestamp = this.estimatedProgressTimestamp.getState();
                let now = Date.now();
                if (!playback) {
                    if (is.present(estimatedProgress) && is.present(estimatedProgressTimestamp)) {
                        this.estimatedProgress.updateState(estimatedProgress + (now - estimatedProgressTimestamp) / 1000);
                    }
                }
                this.estimatedProgressTimestamp.updateState(now);
            });
            this.estimatedProgress.addObserver((estimatedProgress) => {
                console.log(`Estimated progress to ${estimatedProgress ?? 0}`);
            });
            {
                let computer = () => {
                    let playback = this.playback.getState();
                    let isDeviceLocal = this.isDeviceLocal.getState();
                    this.localPlayback.updateState(isDeviceLocal && playback);
                };
                this.playback.addObserver(computer);
                this.isDeviceLocal.addObserver(computer);
            }
            {
                let computer = () => {
                    let lastEntry = this.lastEntry.getState();
                    let isDeviceLocal = this.isDeviceLocal.getState();
                    this.lastLocalEntry.updateState(isDeviceLocal ? lastEntry : undefined);
                };
                this.lastEntry.addObserver(computer);
                this.isDeviceLocal.addObserver(computer);
            }
            {
                let computer = () => {
                    let currentEntry = this.currentEntry.getState();
                    let isDeviceLocal = this.isDeviceLocal.getState();
                    this.currentLocalEntry.updateState(isDeviceLocal ? currentEntry : undefined);
                };
                this.currentEntry.addObserver(computer);
                this.isDeviceLocal.addObserver(computer);
            }
            {
                let computer = () => {
                    let nextEntry = this.nextEntry.getState();
                    let isDeviceLocal = this.isDeviceLocal.getState();
                    this.nextLocalEntry.updateState(isDeviceLocal ? nextEntry : undefined);
                };
                this.nextEntry.addObserver(computer);
                this.isDeviceLocal.addObserver(computer);
            }
            {
                let computer = () => {
                    let localDevice = this.localDevice.getState();
                    let device = this.device.getState();
                    if (is.present(localDevice) && is.present(device)) {
                        if (localDevice.id === device.id) {
                            return this.isDeviceLocal.updateState(true);
                        }
                    }
                    return this.isDeviceLocal.updateState(false);
                };
                this.localDevice.addObserver(computer);
                this.device.addObserver(computer);
            }
            {
                let computer = () => {
                    let localDevice = this.localDevice.getState();
                    let device = this.device.getState();
                    if (is.present(localDevice) && is.present(device)) {
                        if (localDevice.id !== device.id) {
                            return this.isDeviceRemote.updateState(true);
                        }
                    }
                    return this.isDeviceRemote.updateState(false);
                };
                this.localDevice.addObserver(computer);
                this.device.addObserver(computer);
            }
            {
                let computer = () => {
                    let flattenedContext = this.flattenedContext.getState();
                    let currentIndex = this.currentIndex.getState();
                    if (is.present(flattenedContext) && is.present(currentIndex)) {
                        let index = currentIndex - 1;
                        if (index >= 0 && index < flattenedContext.length) {
                            return this.lastIndex.updateState(index);
                        }
                    }
                    return this.lastIndex.updateState(undefined);
                };
                this.flattenedContext.addObserver(computer);
                this.currentIndex.addObserver(computer);
            }
            {
                let computer = () => {
                    let flattenedContext = this.flattenedContext.getState();
                    let currentIndex = this.currentIndex.getState();
                    if (is.present(flattenedContext) && is.present(currentIndex)) {
                        let index = currentIndex + 1;
                        if (index >= 0 && index < flattenedContext.length) {
                            return this.nextIndex.updateState(index);
                        }
                    }
                    return this.nextIndex.updateState(undefined);
                };
                this.flattenedContext.addObserver(computer);
                this.currentIndex.addObserver(computer);
            }
            {
                let computer = () => {
                    let flattenedContext = this.flattenedContext.getState();
                    let lastIndex = this.lastIndex.getState();
                    if (is.present(flattenedContext) && is.present(lastIndex)) {
                        return this.lastEntry.updateState(flattenedContext[lastIndex]);
                    }
                    return this.lastEntry.updateState(undefined);
                };
                this.flattenedContext.addObserver(computer);
                this.lastIndex.addObserver(computer);
            }
            {
                let computer = () => {
                    let flattenedContext = this.flattenedContext.getState();
                    let contextIndex = this.currentIndex.getState();
                    if (is.present(flattenedContext) && is.present(contextIndex)) {
                        if (contextIndex >= 0 && contextIndex + 0 < flattenedContext.length) {
                            return this.currentEntry.updateState(flattenedContext[contextIndex + 0]);
                        }
                    }
                    return this.currentEntry.updateState(undefined);
                };
                this.flattenedContext.addObserver(computer);
                this.currentIndex.addObserver(computer);
            }
            {
                let computer = () => {
                    let flattenedContext = this.flattenedContext.getState();
                    let nextIndex = this.nextIndex.getState();
                    if (is.present(flattenedContext) && is.present(nextIndex)) {
                        return this.nextEntry.updateState(flattenedContext[nextIndex]);
                    }
                    return this.nextEntry.updateState(undefined);
                };
                this.flattenedContext.addObserver(computer);
                this.nextIndex.addObserver(computer);
            }
            this.tsc.addEventListener("app", "SetLocalDevice", (message) => {
                this.localDevice.updateState(message.device);
            });
            this.tsc.addEventListener("app", "SetDevices", (message) => {
                this.devices.update(message.devices);
            });
            this.tsc.addEventListener("app", "SetContext", (message) => {
                this.context.updateState(message.context);
            });
            this.tsc.addEventListener("app", "SetDevice", (message) => {
                this.device.updateState(message.device);
            });
            this.tsc.addEventListener("app", "SetIndex", (message) => {
                this.currentIndex.updateState(message.index);
            });
            this.tsc.addEventListener("app", "SetPlayback", (message) => {
                this.playback.updateState(message.playback);
            });
            this.tsc.addEventListener("app", "SetProgress", (message) => {
                this.progress.updateState(message.progress);
            });
            this.tsc.addEventListener("app", "SetToken", (message) => {
                this.token.updateState(message.token);
            });
            this.isOnline.addObserver((isOnline) => {
                if (!isOnline) {
                    this.context.updateState(undefined);
                    this.currentIndex.updateState(undefined);
                    this.playback.updateState(false);
                    this.progress.updateState(undefined);
                }
            });
            observers.computed((isOnline, token) => {
                if (isOnline) {
                    this.tsc.send("SetToken", {
                        token
                    });
                }
            }, this.isOnline, this.token);
        }
        play(context, index) {
            this.isCurrentEntryVideo.updateState(false);
            this.tsc.send("SetContext", {
                context
            });
            this.tsc.send("SetIndex", {
                index
            });
            this.tsc.send("SetPlayback", {
                playback: true
            });
        }
        authenticate(token) {
            this.token.updateState(token);
        }
        close() {
            this.tsc.close();
        }
        last() {
            let lastIndex = this.lastIndex.getState();
            if (is.present(lastIndex)) {
                this.currentIndex.updateState(lastIndex);
                this.tsc.send("SetIndex", {
                    index: lastIndex
                });
            }
            else {
                this.pause();
            }
        }
        next() {
            let nextIndex = this.nextIndex.getState();
            if (is.present(nextIndex)) {
                this.currentIndex.updateState(nextIndex);
                this.tsc.send("SetIndex", {
                    index: nextIndex
                });
            }
            else {
                this.pause();
            }
        }
        pause() {
            this.playback.updateState(false);
            this.tsc.send("SetPlayback", {
                playback: false
            });
        }
        playAlbum(album, discIndex, trackIndex) {
            let index = 0;
            if (is.present(discIndex)) {
                let discs = album.discs;
                if (discIndex < 0 || discIndex >= discs.length) {
                    throw `Expected ${discIndex} to be a number between 0 and ${discs.length}!`;
                }
                index += discs.slice(0, discIndex).reduce((sum, disc) => sum + disc.tracks.length, 0);
                if (is.present(trackIndex)) {
                    let tracks = discs[discIndex].tracks;
                    if (trackIndex < 0 || trackIndex >= tracks.length) {
                        throw `Expected ${trackIndex} to be a number between 0 and ${tracks.length}!`;
                    }
                    index += trackIndex;
                }
            }
            return this.play(album, index);
        }
        playArtist(artist, albumIndex, discIndex, trackIndex) {
            let index = 0;
            if (is.present(albumIndex)) {
                let albums = artist.albums;
                if (albumIndex < 0 || albumIndex >= albums.length) {
                    throw `Expected ${albumIndex} to be a number between 0 and ${albums.length}!`;
                }
                index += albums.slice(0, albumIndex).reduce((sum, album) => sum + album.discs.reduce((sum, disc) => sum + disc.tracks.length, 0), 0);
                if (is.present(discIndex)) {
                    let discs = albums[albumIndex].discs;
                    if (discIndex < 0 || discIndex >= discs.length) {
                        throw `Expected ${discIndex} to be a number between 0 and ${discs.length}!`;
                    }
                    index += discs.slice(0, discIndex).reduce((sum, disc) => sum + disc.tracks.length, 0);
                    if (is.present(trackIndex)) {
                        let tracks = discs[discIndex].tracks;
                        if (trackIndex < 0 || trackIndex >= tracks.length) {
                            throw `Expected ${trackIndex} to be a number between 0 and ${tracks.length}!`;
                        }
                        index += trackIndex;
                    }
                }
            }
            return this.play(artist, index);
        }
        playDisc(disc, trackIndex) {
            let index = 0;
            if (is.present(trackIndex)) {
                let tracks = disc.tracks;
                if (trackIndex < 0 || trackIndex >= tracks.length) {
                    throw `Expected ${trackIndex} to be a number between 0 and ${tracks.length}!`;
                }
                index += trackIndex;
            }
            return this.play(disc, index);
        }
        playEpisode(episode) {
            this.play(episode, 0);
        }
        playMovie(movie) {
            this.play(movie, 0);
        }
        playPlaylist(playlist, itemIndex) {
            let index = 0;
            if (is.present(itemIndex)) {
                let items = playlist.items;
                if (itemIndex < 0 || itemIndex >= items.length) {
                    throw `Expected ${itemIndex} to be a number between 0 and ${items.length}!`;
                }
                index += itemIndex;
            }
            return this.play(playlist, index);
        }
        playSeason(season, episodeIndex) {
            let index = 0;
            if (is.present(episodeIndex)) {
                let episodes = season.episodes;
                if (episodeIndex < 0 || episodeIndex >= episodes.length) {
                    throw `Expected ${episodeIndex} to be a number between 0 and ${episodes.length}!`;
                }
                index += episodeIndex;
            }
            return this.play(season, index);
        }
        playShow(show, seasonIndex, episodeIndex) {
            let index = 0;
            if (is.present(seasonIndex)) {
                let seasons = show.seasons;
                if (seasonIndex < 0 || seasonIndex >= seasons.length) {
                    throw `Expected ${seasonIndex} to be a number between 0 and ${seasons.length}!`;
                }
                index += seasons.slice(0, seasonIndex).reduce((sum, season) => sum + season.episodes.length, 0);
                if (is.present(episodeIndex)) {
                    let episodes = seasons[seasonIndex].episodes;
                    if (episodeIndex < 0 || episodeIndex >= episodes.length) {
                        throw `Expected ${episodeIndex} to be a number between 0 and ${episodes.length}!`;
                    }
                    index += episodeIndex;
                }
            }
            return this.play(show, index);
        }
        playTrack(track) {
            this.play(track, 0);
        }
        reconnect() {
            this.tsc.reconnect();
        }
        resume() {
            if (this.canPlayCurrent.getState()) {
                this.playback.updateState(true);
                this.tsc.send("SetPlayback", {
                    playback: true
                });
            }
        }
        seek(progress) {
            this.progress.updateState(progress);
            this.tsc.send("SetProgress", {
                progress: progress
            });
        }
        toggle() {
            if (this.playback.getState()) {
                this.pause();
            }
            else {
                this.resume();
            }
        }
        transfer(device) {
            this.tsc.send("SetDevice", {
                device: device
            });
        }
    }
    exports.ContextClient = ContextClient;
});
define("node_modules/@joelek/ts-sockets/build/frames", ["require", "exports", "crypto"], function (require, exports, libcrypto) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeFrame = exports.decodeFrame = exports.WebSocketFrameType = void 0;
    var WebSocketFrameType;
    (function (WebSocketFrameType) {
        WebSocketFrameType[WebSocketFrameType["CONTINUATION"] = 0] = "CONTINUATION";
        WebSocketFrameType[WebSocketFrameType["TEXT"] = 1] = "TEXT";
        WebSocketFrameType[WebSocketFrameType["BINARY"] = 2] = "BINARY";
        WebSocketFrameType[WebSocketFrameType["UNUSED_3"] = 3] = "UNUSED_3";
        WebSocketFrameType[WebSocketFrameType["UNUSED_4"] = 4] = "UNUSED_4";
        WebSocketFrameType[WebSocketFrameType["UNUSED_5"] = 5] = "UNUSED_5";
        WebSocketFrameType[WebSocketFrameType["UNUSED_6"] = 6] = "UNUSED_6";
        WebSocketFrameType[WebSocketFrameType["UNUSED_7"] = 7] = "UNUSED_7";
        WebSocketFrameType[WebSocketFrameType["CLOSE"] = 8] = "CLOSE";
        WebSocketFrameType[WebSocketFrameType["PING"] = 9] = "PING";
        WebSocketFrameType[WebSocketFrameType["PONG"] = 10] = "PONG";
        WebSocketFrameType[WebSocketFrameType["UNUSED_B"] = 11] = "UNUSED_B";
        WebSocketFrameType[WebSocketFrameType["UNUSED_C"] = 12] = "UNUSED_C";
        WebSocketFrameType[WebSocketFrameType["UNUSED_D"] = 13] = "UNUSED_D";
        WebSocketFrameType[WebSocketFrameType["UNUSED_E"] = 14] = "UNUSED_E";
        WebSocketFrameType[WebSocketFrameType["UNUSED_F"] = 15] = "UNUSED_F";
    })(WebSocketFrameType = exports.WebSocketFrameType || (exports.WebSocketFrameType = {}));
    ;
    function decodeFrame(state) {
        let final = ((state.buffer.readUInt8(state.offset) >> 7) & 0x01);
        let reserved1 = ((state.buffer.readUInt8(state.offset) >> 6) & 0x01);
        let reserved2 = ((state.buffer.readUInt8(state.offset) >> 5) & 0x01);
        let reserved3 = ((state.buffer.readUInt8(state.offset) >> 4) & 0x01);
        let opcode = ((state.buffer.readUInt8(state.offset) >> 0) & 0x0F);
        state.offset += 1;
        let masked = ((state.buffer.readUInt8(state.offset) >> 7) & 0x01);
        let payload_length = ((state.buffer.readUInt8(state.offset) >> 0) & 0x7F);
        state.offset += 1;
        if (payload_length === 126) {
            payload_length = state.buffer.readUInt16BE(state.offset);
            state.offset += 2;
            if (payload_length <= 125) {
                throw "Invalid frame encoding!";
            }
        }
        else if (payload_length === 127) {
            if (state.buffer.readUInt32BE(state.offset) !== 0) {
                throw "Invalid frame encoding!";
            }
            state.offset += 4;
            payload_length = state.buffer.readUInt32BE(state.offset);
            state.offset += 4;
            if (payload_length <= 65535) {
                throw "Invalid frame encoding!";
            }
        }
        let key = Buffer.alloc(4);
        if (masked === 1) {
            key = state.buffer.slice(state.offset, state.offset + 4);
            state.offset += 4;
        }
        if (state.offset + payload_length > state.buffer.length) {
            throw "Invalid frame encoding!";
        }
        let payload = state.buffer.slice(state.offset, state.offset + payload_length);
        state.offset += payload_length;
        if (masked === 1) {
            for (let i = 0; i < payload.length; i++) {
                payload[i] = payload[i] ^ key[i & 0x03];
            }
        }
        return {
            final,
            reserved1,
            reserved2,
            reserved3,
            opcode,
            masked,
            payload
        };
    }
    exports.decodeFrame = decodeFrame;
    ;
    function encodeFrame(frame) {
        let chunks = new Array();
        let payload_length = frame.payload.length;
        let header = Buffer.alloc(2);
        chunks.push(header);
        let byte0 = 0;
        byte0 |= ((frame.final & 0x01) << 7);
        byte0 |= ((frame.reserved1 & 0x01) << 6);
        byte0 |= ((frame.reserved2 & 0x01) << 5);
        byte0 |= ((frame.reserved3 & 0x01) << 4);
        byte0 |= ((frame.opcode & 0x0F) << 0);
        header.writeUInt8(byte0, 0);
        if (payload_length <= 125) {
            let byte1 = 0;
            byte1 |= ((frame.masked & 0x01) << 7);
            byte1 |= ((payload_length & 0x7F) << 0);
            header.writeUInt8(byte1, 1);
        }
        else if (payload_length <= 65535) {
            let byte1 = 0;
            byte1 |= ((frame.masked & 0x01) << 7);
            byte1 |= ((126 & 0x7F) << 0);
            header.writeUInt8(byte1, 1);
            let length = Buffer.alloc(2);
            length.writeUInt16BE(payload_length, 0);
            chunks.push(length);
        }
        else if (payload_length <= 4294967295) {
            let byte1 = 0;
            byte1 |= ((frame.masked & 0x01) << 7);
            byte1 |= ((127 & 0x7F) << 0);
            header.writeUInt8(byte1, 1);
            let length = Buffer.alloc(8);
            length.writeUInt32BE(payload_length, 4);
            chunks.push(length);
        }
        else {
            throw "Invalid frame size!";
        }
        if (frame.masked === 1) {
            let key = libcrypto.randomBytes(4);
            let payload = Buffer.concat([frame.payload]);
            for (let i = 0; i < payload.length; i++) {
                payload[i] = payload[i] ^ key[i & 0x03];
            }
            chunks.push(key, payload);
        }
        else {
            chunks.push(frame.payload);
        }
        return Buffer.concat(chunks);
    }
    exports.encodeFrame = encodeFrame;
    ;
});
define("node_modules/@joelek/ts-sockets/build/is", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.present = exports.absent = void 0;
    function absent(subject) {
        return subject == null;
    }
    exports.absent = absent;
    ;
    function present(subject) {
        return subject != null;
    }
    exports.present = present;
    ;
});
define("node_modules/@joelek/ts-sockets/build/utils", ["require", "exports", "node_modules/@joelek/ts-sockets/build/is"], function (require, exports, is) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BiMap = exports.getHeader = void 0;
    function getHeader(request, key) {
        let values = request.headers[key.toLowerCase()];
        if (is.present(values)) {
            if (values.constructor === String) {
                return values;
            }
            if (values.constructor === Array && values.length === 1) {
                return values[0];
            }
        }
        return null;
    }
    exports.getHeader = getHeader;
    ;
    class BiMap {
        constructor() {
            this.value_to_key = new Map();
            this.key_to_value = new Map();
        }
        [Symbol.iterator]() {
            return this.key_to_value[Symbol.iterator]();
        }
        add(key, value) {
            this.value_to_key.set(value, key);
            this.key_to_value.set(key, value);
        }
        key(value) {
            return this.value_to_key.get(value) || null;
        }
        remove(key) {
            let value = this.key_to_value.get(key);
            if (is.present(value)) {
                this.value_to_key.delete(value);
            }
            this.key_to_value.delete(key);
        }
        value(key) {
            return this.key_to_value.get(key) || null;
        }
    }
    exports.BiMap = BiMap;
    ;
});
define("node_modules/@joelek/ts-sockets/build/client", ["require", "exports", "crypto", "http", "https", "url", "node_modules/@joelek/ts-stdlib/build/index", "node_modules/@joelek/ts-sockets/build/frames", "node_modules/@joelek/ts-sockets/build/is", "node_modules/@joelek/ts-sockets/build/shared", "node_modules/@joelek/ts-sockets/build/utils"], function (require, exports, libcrypto, libhttp, libhttps, liburl, stdlib, frames, is, shared, utils) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WebSocketClient = void 0;
    function makeHttpPromise(url, options) {
        return new Promise((resolve, reject) => {
            libhttp.get(url, options)
                .on("upgrade", (response, socket, buffer) => {
                resolve({ response, socket, buffer });
            })
                .on("error", reject);
        });
    }
    function makeHttpsPromise(url, options) {
        return new Promise((resolve, reject) => {
            libhttps.get(url, options)
                .on("upgrade", (response, socket, buffer) => {
                resolve({ response, socket, buffer });
            })
                .on("error", reject);
        });
    }
    class WebSocketClient {
        constructor(url) {
            var _a;
            this.state = shared.ReadyState.CONNECTING;
            this.listeners = new stdlib.routing.MessageRouter();
            this.pending = new Array();
            this.socket = undefined;
            let key = libcrypto.randomBytes(16).toString("base64");
            let headers = {
                "Connection": "upgrade",
                "Host": (_a = liburl.parse(url).host) !== null && _a !== void 0 ? _a : "",
                "Sec-WebSocket-Key": key,
                "Sec-WebSocket-Version": "13",
                "Upgrade": "websocket"
            };
            (() => {
                if (url.startsWith("wss:")) {
                    return makeHttpsPromise("https:" + url.substring(4), { headers, rejectUnauthorized: false });
                }
                else if (url.startsWith("ws:")) {
                    return makeHttpPromise("http:" + url.substring(3), { headers });
                }
                else {
                    throw `Expected ${url} to be a WebSocket URL!`;
                }
            })().then((upgraded) => {
                var _a, _b;
                let response = upgraded.response;
                let socket = upgraded.socket;
                let buffer = upgraded.buffer;
                socket.on("close", () => {
                    this.state = shared.ReadyState.CLOSED;
                    this.listeners.route("close", undefined);
                });
                socket.on("error", () => {
                    this.state = shared.ReadyState.CLOSING;
                    this.listeners.route("error", undefined);
                    socket.end();
                });
                if (response.statusCode !== 101) {
                    return socket.emit("error");
                }
                if (((_a = utils.getHeader(response, "Connection")) === null || _a === void 0 ? void 0 : _a.toLowerCase()) !== "upgrade") {
                    return socket.emit("error");
                }
                if (((_b = utils.getHeader(response, "Upgrade")) === null || _b === void 0 ? void 0 : _b.toLowerCase()) !== "websocket") {
                    return socket.emit("error");
                }
                let accept = libcrypto.createHash("sha1")
                    .update(key + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11")
                    .digest("base64");
                if (utils.getHeader(response, "Sec-WebSocket-Accept") !== accept) {
                    return socket.emit("error");
                }
                this.socket = socket;
                let processBuffer = () => {
                    while (true) {
                        try {
                            let state = {
                                buffer,
                                offset: 0
                            };
                            let frame = frames.decodeFrame(state);
                            this.onFrame(socket, frame);
                            buffer = buffer.slice(state.offset);
                        }
                        catch (error) {
                            break;
                        }
                    }
                };
                this.socket.on("data", (chunk) => {
                    buffer = Buffer.concat([buffer, chunk]);
                    processBuffer();
                });
                this.state = shared.ReadyState.OPEN;
                this.listeners.route("open", undefined);
                processBuffer();
            });
        }
        onFrame(socket, frame) {
            if (frame.reserved1 !== 0 || frame.reserved2 !== 0 || frame.reserved3 !== 0) {
                return this.close(shared.StatusCode.PROTOCOL_ERROR);
            }
            if (frame.opcode < 8) {
                if (frame.opcode === frames.WebSocketFrameType.CONTINUATION || frame.opcode === frames.WebSocketFrameType.TEXT || frame.opcode == frames.WebSocketFrameType.BINARY) {
                    if (this.pending.length === 0) {
                        if (frame.opcode === frames.WebSocketFrameType.CONTINUATION) {
                            return this.close(shared.StatusCode.PROTOCOL_ERROR);
                        }
                    }
                    else {
                        if (frame.opcode !== frames.WebSocketFrameType.CONTINUATION) {
                            return this.close(shared.StatusCode.PROTOCOL_ERROR);
                        }
                    }
                    this.pending.push(frame.payload);
                    if (frame.final === 1) {
                        let buffer = Buffer.concat(this.pending);
                        this.pending.splice(0);
                        this.listeners.route("message", {
                            data: buffer.toString()
                        });
                    }
                }
                else {
                    return this.close(shared.StatusCode.PROTOCOL_ERROR);
                }
            }
            else {
                if (frame.final !== 1) {
                    return this.close(shared.StatusCode.PROTOCOL_ERROR);
                }
                if (frame.payload.length > 125) {
                    return this.close(shared.StatusCode.PROTOCOL_ERROR);
                }
                if (frame.opcode === frames.WebSocketFrameType.CLOSE) {
                    if (this.readyState === shared.ReadyState.CLOSING) {
                        return socket.end();
                    }
                    else {
                        socket.write(frames.encodeFrame(Object.assign(Object.assign({}, frame), { masked: 1 })), () => {
                            return socket.end();
                        });
                    }
                }
                else if (frame.opcode === frames.WebSocketFrameType.PING) {
                    socket.write(frames.encodeFrame(Object.assign(Object.assign({}, frame), { opcode: 0x0A, masked: 1 })));
                }
                else if (frame.opcode === frames.WebSocketFrameType.PONG) {
                }
                else {
                    return this.close(shared.StatusCode.PROTOCOL_ERROR);
                }
            }
        }
        addEventListener(type, listener) {
            this.listeners.addObserver(type, listener);
        }
        close(status) {
            if (this.state !== shared.ReadyState.OPEN) {
                throw `Expected socket to be open!`;
            }
            const socket = this.socket;
            if (is.absent(socket)) {
                throw `Expected socket to be open!`;
            }
            let payload = Buffer.alloc(0);
            if (is.present(status)) {
                payload = Buffer.concat([Buffer.alloc(2), Buffer.from("Connection closed by client.")]);
                payload.writeUInt16BE(status, 0);
            }
            let frame = frames.encodeFrame({
                final: 1,
                reserved1: 0,
                reserved2: 0,
                reserved3: 0,
                opcode: frames.WebSocketFrameType.CLOSE,
                masked: 1,
                payload: payload
            });
            socket.write(frame);
            this.state = shared.ReadyState.CLOSING;
        }
        removeEventListener(type, listener) {
            this.listeners.removeObserver(type, listener);
        }
        send(payload) {
            if (this.state !== shared.ReadyState.OPEN) {
                throw `Expected socket to be open!`;
            }
            let socket = this.socket;
            if (is.absent(socket)) {
                throw `Expected socket to be open!`;
            }
            let final = 1;
            let reserved1 = 0;
            let reserved2 = 0;
            let reserved3 = 0;
            let opcode = frames.WebSocketFrameType.BINARY;
            let masked = 1;
            if (!(payload instanceof Buffer)) {
                payload = Buffer.from(payload, "utf8");
                opcode = frames.WebSocketFrameType.TEXT;
            }
            let frame = frames.encodeFrame({
                final,
                reserved1,
                reserved2,
                reserved3,
                opcode,
                masked,
                payload
            });
            socket.write(frame);
        }
        get readyState() {
            return this.state;
        }
    }
    exports.WebSocketClient = WebSocketClient;
    ;
});
define("node_modules/@joelek/ts-sockets/build/server", ["require", "exports", "crypto", "tls", "node_modules/@joelek/ts-stdlib/build/index", "node_modules/@joelek/ts-sockets/build/frames", "node_modules/@joelek/ts-sockets/build/is", "node_modules/@joelek/ts-sockets/build/shared", "node_modules/@joelek/ts-sockets/build/utils"], function (require, exports, libcrypto, libtls, stdlib, frames, is, shared, utils) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WebSocketServer = void 0;
    function makeConnectionUrl(request) {
        let host = request.headers.host || "";
        let path = request.url || "/";
        let protocol = request.socket instanceof libtls.TLSSocket ? "wss:" : "ws:";
        return `${protocol}//${host}${path}`;
    }
    class WebSocketServer {
        constructor() {
            this.pending_chunks = new Map();
            this.states = new Map();
            this.connections = new utils.BiMap();
            this.router = new stdlib.routing.MessageRouter();
        }
        onFrame(connection_id, connection_url, socket, frame) {
            if (frame.reserved1 !== 0 || frame.reserved2 !== 0 || frame.reserved3 !== 0) {
                return this.close(connection_id, shared.StatusCode.PROTOCOL_ERROR);
            }
            if (frame.masked !== 1) {
                return this.close(connection_id, shared.StatusCode.PROTOCOL_ERROR);
            }
            if (frame.opcode < 8) {
                if (frame.opcode === frames.WebSocketFrameType.CONTINUATION || frame.opcode === frames.WebSocketFrameType.TEXT || frame.opcode == frames.WebSocketFrameType.BINARY) {
                    let pending_chunks = this.pending_chunks.get(connection_id);
                    if (is.absent(pending_chunks)) {
                        pending_chunks = new Array();
                        this.pending_chunks.set(connection_id, pending_chunks);
                    }
                    else {
                        if (frame.opcode !== frames.WebSocketFrameType.CONTINUATION) {
                            return this.close(connection_id, shared.StatusCode.PROTOCOL_ERROR);
                        }
                    }
                    pending_chunks.push(frame.payload);
                    if (frame.final === 1) {
                        let buffer = Buffer.concat(pending_chunks);
                        this.pending_chunks.delete(connection_id);
                        this.router.route("message", {
                            connection_id,
                            connection_url,
                            buffer
                        });
                    }
                }
                else {
                    return this.close(connection_id, shared.StatusCode.PROTOCOL_ERROR);
                }
            }
            else {
                if (frame.final !== 1) {
                    return this.close(connection_id, shared.StatusCode.PROTOCOL_ERROR);
                }
                if (frame.payload.length > 125) {
                    return this.close(connection_id, shared.StatusCode.PROTOCOL_ERROR);
                }
                if (frame.opcode === frames.WebSocketFrameType.CLOSE) {
                    if (this.states.get(connection_id) === shared.ReadyState.CLOSING) {
                        return socket.end();
                    }
                    else {
                        socket.write(frames.encodeFrame(Object.assign(Object.assign({}, frame), { masked: 0 })), () => {
                            return socket.end();
                        });
                    }
                }
                else if (frame.opcode === frames.WebSocketFrameType.PING) {
                    socket.write(frames.encodeFrame(Object.assign(Object.assign({}, frame), { opcode: 0x0A, masked: 0 })));
                }
                else if (frame.opcode === frames.WebSocketFrameType.PONG) {
                }
                else {
                    return this.close(connection_id, shared.StatusCode.PROTOCOL_ERROR);
                }
            }
        }
        broadcast(payload) {
            for (let [connection_id, socket] of this.connections) {
                if (this.states.get(connection_id) === shared.ReadyState.OPEN) {
                    this.send(connection_id, payload);
                }
            }
        }
        addEventListener(type, listener) {
            return this.router.addObserver(type, listener);
        }
        close(connection_id, status) {
            if (this.states.get(connection_id) !== shared.ReadyState.OPEN) {
                throw `Expected socket to be open!`;
            }
            const socket = this.connections.value(connection_id);
            if (is.absent(socket)) {
                throw "Connection with id \"" + connection_id + "\" has no socket!";
            }
            let payload = Buffer.alloc(0);
            if (is.present(status)) {
                payload = Buffer.concat([Buffer.alloc(2), Buffer.from("Connection closed by server.")]);
                payload.writeUInt16BE(status, 0);
            }
            let frame = frames.encodeFrame({
                final: 1,
                reserved1: 0,
                reserved2: 0,
                reserved3: 0,
                opcode: frames.WebSocketFrameType.CLOSE,
                masked: 0,
                payload: payload
            });
            socket.write(frame);
            this.states.set(connection_id, shared.ReadyState.CLOSING);
        }
        getRequestHandler() {
            return (request, response) => {
                let socket = request.socket;
                let connection_id = this.connections.key(socket);
                if (is.present(connection_id)) {
                    response.writeHead(400);
                    return response.end();
                }
                let major = request.httpVersionMajor;
                let minor = request.httpVersionMinor;
                if (major < 1 || (major === 1 && minor < 1)) {
                    response.writeHead(400);
                    return response.end();
                }
                let method = request.method;
                if (method !== "GET") {
                    response.writeHead(400);
                    return response.end();
                }
                let host = utils.getHeader(request, "Host");
                if (is.absent(host)) {
                    response.writeHead(400);
                    return response.end();
                }
                let upgrade = utils.getHeader(request, "Upgrade");
                if (is.absent(upgrade) || upgrade.toLowerCase() !== "websocket") {
                    response.writeHead(400);
                    return response.end();
                }
                let connection = utils.getHeader(request, "Connection");
                if (is.absent(connection) || connection.toLowerCase() !== "upgrade") {
                    response.writeHead(400);
                    return response.end();
                }
                let key = utils.getHeader(request, "Sec-WebSocket-Key");
                if (is.absent(key) || Buffer.from(key, "base64").length !== 16) {
                    response.writeHead(400);
                    return response.end();
                }
                let version = utils.getHeader(request, "Sec-WebSocket-Version");
                if (version !== "13") {
                    response.writeHead(426, {
                        "Sec-WebSocket-Version": "13"
                    });
                    return response.end();
                }
                let accept = libcrypto.createHash("sha1")
                    .update(key + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11")
                    .digest("base64");
                response.writeHead(101, {
                    "Upgrade": "websocket",
                    "Connection": "Upgrade",
                    "Sec-WebSocket-Accept": accept
                });
                return response.end(() => {
                    let connection_id = libcrypto.randomBytes(16).toString("hex");
                    let connection_url = makeConnectionUrl(request);
                    let buffer = Buffer.alloc(0);
                    socket.on("data", (chunk) => {
                        buffer = Buffer.concat([buffer, chunk]);
                        while (true) {
                            try {
                                let state = {
                                    buffer,
                                    offset: 0
                                };
                                let frame = frames.decodeFrame(state);
                                this.onFrame(connection_id, connection_url, socket, frame);
                                buffer = buffer.slice(state.offset);
                            }
                            catch (error) {
                                break;
                            }
                        }
                    });
                    socket.on("close", () => {
                        this.connections.remove(connection_id);
                        this.states.delete(connection_id);
                        this.router.route("disconnect", {
                            connection_id,
                            connection_url
                        });
                    });
                    socket.setTimeout(0);
                    this.connections.add(connection_id, socket);
                    this.states.set(connection_id, shared.ReadyState.OPEN);
                    this.router.route("connect", {
                        connection_id,
                        connection_url
                    });
                });
            };
        }
        removeEventListener(type, listener) {
            return this.router.removeObserver(type, listener);
        }
        send(connection_id, payload) {
            if (this.states.get(connection_id) !== shared.ReadyState.OPEN) {
                throw `Expected socket to be open!`;
            }
            let socket = this.connections.value(connection_id);
            if (is.absent(socket)) {
                throw "Connection with id \"" + connection_id + "\" has no socket!";
            }
            let final = 1;
            let reserved1 = 0;
            let reserved2 = 0;
            let reserved3 = 0;
            let opcode = frames.WebSocketFrameType.BINARY;
            let masked = 0;
            if (!(payload instanceof Buffer)) {
                payload = Buffer.from(payload, "utf8");
                opcode = frames.WebSocketFrameType.TEXT;
            }
            let frame = frames.encodeFrame({
                final,
                reserved1,
                reserved2,
                reserved3,
                opcode,
                masked,
                payload
            });
            socket.write(frame);
        }
    }
    exports.WebSocketServer = WebSocketServer;
});
define("node_modules/@joelek/ts-sockets/build/index", ["require", "exports", "node_modules/@joelek/ts-sockets/build/client", "node_modules/@joelek/ts-sockets/build/frames", "node_modules/@joelek/ts-sockets/build/server", "node_modules/@joelek/ts-sockets/build/shared", "node_modules/@joelek/ts-sockets/build/client", "node_modules/@joelek/ts-sockets/build/server"], function (require, exports, client, frames, server, shared, client_1, server_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shared = exports.server = exports.frames = exports.client = void 0;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.client = client;
    exports.frames = frames;
    exports.server = server;
    exports.shared = shared;
    Object.defineProperty(exports, "WebSocketClient", { enumerable: true, get: function () { return client_1.WebSocketClient; } });
    Object.defineProperty(exports, "WebSocketServer", { enumerable: true, get: function () { return server_1.WebSocketServer; } });
});
define("build/typesockets/server", ["require", "exports", "node_modules/@joelek/ts-stdlib/build/index", "node_modules/@joelek/ts-sockets/build/index", "build/typesockets/shared"], function (require, exports, stdlib, sockets, shared) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TypeSocketServer = void 0;
    class TypeSocketServer {
        constructor(guards, debug = false) {
            this.router = new stdlib.routing.NamespacedMessageRouter();
            this.serializer = new shared.Serializer(guards);
            this.socket = new sockets.WebSocketServer();
            this.debug = debug;
            this.socket.addEventListener("connect", (message) => {
                let connection_id = message.connection_id;
                let connection_url = message.connection_url;
                this.router.route("sys", "connect", {
                    connection_id,
                    connection_url
                });
            });
            this.socket.addEventListener("disconnect", (message) => {
                let connection_id = message.connection_id;
                let connection_url = message.connection_url;
                this.router.route("sys", "disconnect", {
                    connection_id,
                    connection_url
                });
            });
            this.socket.addEventListener("message", (message) => {
                let connection_id = message.connection_id;
                let connection_url = message.connection_url;
                let payload = message.buffer.toString();
                try {
                    this.serializer.deserialize(payload, (type, data, id) => {
                        if (this.debug) {
                            console.log(`${connection_id} -> ${type}`);
                        }
                        this.router.route("sys", "message", {
                            connection_id,
                            connection_url,
                            id,
                            type,
                            data
                        });
                        this.router.route("app", type, {
                            connection_id,
                            connection_url,
                            id,
                            data
                        });
                    });
                }
                catch (error) {
                    if (this.debug) {
                        console.log(error);
                    }
                }
            });
        }
        addEventListener(namespace, type, listener) {
            this.router.addObserver(namespace, type, listener);
        }
        broadcast(type, data) {
            let payload = this.serializer.serialize(type, data);
            this.socket.broadcast(payload);
        }
        close(connection_id) {
            this.socket.close(connection_id);
        }
        getRequestHandler() {
            return this.socket.getRequestHandler();
        }
        removeEventListener(namespace, type, listener) {
            this.router.addObserver(namespace, type, listener);
        }
        respond(message, type, data) {
            let payload = this.serializer.serialize(type, data, message.id);
            if (this.debug) {
                console.log(`${message.connection_id} <- ${type}`);
            }
            try {
                this.socket.send(message.connection_id, payload);
            }
            catch (error) {
                if (this.debug) {
                    console.log(error);
                }
            }
        }
        send(type, connection_ids, data) {
            let payload = this.serializer.serialize(type, data);
            for (let connection_id of Array.isArray(connection_ids) ? connection_ids : [connection_ids]) {
                if (this.debug) {
                    console.log(`${connection_id} <- ${type}`);
                }
                try {
                    this.socket.send(connection_id, payload);
                }
                catch (error) {
                    if (this.debug) {
                        console.log(error);
                    }
                }
            }
        }
    }
    exports.TypeSocketServer = TypeSocketServer;
    ;
});
define("build/typesockets/index", ["require", "exports", "build/typesockets/client", "build/typesockets/server", "build/typesockets/shared", "build/typesockets/client", "build/typesockets/server"], function (require, exports, client, server, shared, client_1, server_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shared = exports.server = exports.client = void 0;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TypeSocketServer = exports.TypeSocketClient = exports.shared = exports.server = exports.client = void 0;
    exports.client = client;
    exports.server = server;
    exports.shared = shared;
    Object.defineProperty(exports, "TypeSocketClient", { enumerable: true, get: function () { return client_1.TypeSocketClient; } });
    Object.defineProperty(exports, "TypeSocketServer", { enumerable: true, get: function () { return server_1.TypeSocketServer; } });
});
define("build/player/server", ["require", "exports", "url", "build/server/auth", "build/is", "build/observers/index", "build/player/schema/index", "build/typesockets/index"], function (require, exports, liburl, auth, is, observers, schema, typesockets) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ContextServer = void 0;
    function getQuery(url, key) {
        let values = url.query[key] ?? [];
        if (Array.isArray(values)) {
            return values;
        }
        else {
            return [values];
        }
    }
    function makeDevice(connection_id, connection_url) {
        let url = liburl.parse(connection_url, true);
        let protocol = getQuery(url, "protocol").pop() ?? "";
        let name = getQuery(url, "name").pop() ?? "";
        let type = getQuery(url, "type").pop() ?? "";
        return {
            id: connection_id,
            protocol: protocol,
            name: name,
            type: type
        };
    }
    class ContextServer {
        constructor() {
            this.tokens = new Map();
            this.sessions = new Map();
            this.chromecasts = new observers.ObservableClass([]);
            this.tss = new typesockets.TypeSocketServer(schema.messages.Autoguard);
            this.tss.addEventListener("sys", "connect", (message) => {
                console.log("connect: " + message.connection_url);
                let device = makeDevice(message.connection_id, message.connection_url);
                this.tss.send("SetLocalDevice", message.connection_id, {
                    device
                });
                if (device.protocol === "cast" || device.protocol === "airplay") {
                    this.chromecasts.updateState([...this.chromecasts.getState(), device]);
                }
            });
            this.tss.addEventListener("sys", "disconnect", (message) => {
                console.log("disconnect: " + message.connection_url);
                let device = makeDevice(message.connection_id, message.connection_url);
                this.revokeAuthentication(message.connection_id);
                if (device.protocol === "cast" || device.protocol === "airplay") {
                    this.chromecasts.updateState(this.chromecasts.getState().filter((chromecast) => {
                        return chromecast.id !== device.id;
                    }));
                }
            });
            this.tss.addEventListener("app", "SetToken", (message) => {
                this.revokeAuthentication(message.connection_id);
                let token = message.data.token;
                if (is.present(token)) {
                    let user_id = auth.getUserId(token);
                    this.tokens.set(message.connection_id, token);
                    let session = this.getSession(user_id);
                    let device = makeDevice(message.connection_id, message.connection_url);
                    session.devices.updateState([...session.devices.getState(), device]);
                    this.tss.send("SetContext", message.connection_id, {
                        context: session.context
                    });
                    this.tss.send("SetDevice", message.connection_id, {
                        device: session.device
                    });
                    this.tss.send("SetIndex", message.connection_id, {
                        index: session.index
                    });
                    this.tss.send("SetPlayback", message.connection_id, {
                        playback: session.playback
                    });
                    this.tss.send("SetProgress", message.connection_id, {
                        progress: session.progress
                    });
                    this.tss.send("SetToken", message.connection_id, {
                        token: token
                    });
                }
            });
            this.tss.addEventListener("app", "SetContext", (message) => {
                this.getExistingSession(message.connection_id, (session) => {
                    if (is.absent(session.device)) {
                        session.device = makeDevice(message.connection_id, message.connection_url);
                        this.tss.send("SetDevice", session.devices.getState().map((device) => {
                            return device.id;
                        }), {
                            device: session.device
                        });
                    }
                    session.index = undefined;
                    this.tss.send("SetIndex", session.devices.getState().map((device) => {
                        return device.id;
                    }), {
                        index: session.index
                    });
                    session.context = message.data.context;
                    this.tss.send("SetContext", session.devices.getState().map((device) => {
                        return device.id;
                    }), message.data);
                });
            });
            this.tss.addEventListener("app", "SetDevice", (message) => {
                this.getExistingSession(message.connection_id, (session) => {
                    this.updateProgress(session);
                    this.tss.send("SetProgress", session.devices.getState().map((device) => {
                        return device.id;
                    }), {
                        progress: session.progress
                    });
                    session.device = message.data.device;
                    this.tss.send("SetDevice", session.devices.getState().map((device) => {
                        return device.id;
                    }), message.data);
                    if (is.present(session.device)) {
                        this.tss.send("SetToken", session.device.id, {
                            token: this.tokens.get(message.connection_id)
                        });
                    }
                });
            });
            this.tss.addEventListener("app", "SetIndex", (message) => {
                this.getExistingSession(message.connection_id, (session) => {
                    if (is.absent(session.device)) {
                        session.device = makeDevice(message.connection_id, message.connection_url);
                        this.tss.send("SetDevice", session.devices.getState().map((device) => {
                            return device.id;
                        }), {
                            device: session.device
                        });
                    }
                    session.progress = is.present(message.data.index) ? 0 : undefined;
                    session.progressTimestamp = Date.now();
                    this.tss.send("SetProgress", session.devices.getState().map((device) => {
                        return device.id;
                    }), {
                        progress: session.progress
                    });
                    session.index = message.data.index;
                    this.tss.send("SetIndex", session.devices.getState().map((device) => {
                        return device.id;
                    }), message.data);
                });
            });
            this.tss.addEventListener("app", "SetPlayback", (message) => {
                this.getExistingSession(message.connection_id, (session) => {
                    if (is.absent(session.device)) {
                        session.device = makeDevice(message.connection_id, message.connection_url);
                        this.tss.send("SetDevice", session.devices.getState().map((device) => {
                            return device.id;
                        }), {
                            device: session.device
                        });
                    }
                    this.updateProgress(session);
                    session.playback = message.data.playback;
                    this.tss.send("SetPlayback", session.devices.getState().map((device) => {
                        return device.id;
                    }), message.data);
                });
            });
            this.tss.addEventListener("app", "SetProgress", (message) => {
                this.getExistingSession(message.connection_id, (session) => {
                    if (is.absent(session.device)) {
                        session.device = makeDevice(message.connection_id, message.connection_url);
                        this.tss.send("SetDevice", session.devices.getState().map((device) => {
                            return device.id;
                        }), {
                            device: session.device
                        });
                    }
                    session.progress = message.data.progress;
                    session.progressTimestamp = Date.now();
                    this.tss.send("SetProgress", session.devices.getState().map((device) => {
                        return device.id;
                    }), message.data);
                });
            });
        }
        getExistingSession(connection_id, callback) {
            let token = this.tokens.get(connection_id);
            if (is.present(token)) {
                let user_id = auth.getUserId(token);
                let session = this.sessions.get(user_id);
                if (is.present(session)) {
                    callback(session);
                }
            }
        }
        getSession(user_id) {
            let existingSession = this.sessions.get(user_id);
            if (is.present(existingSession)) {
                return existingSession;
            }
            const session = {
                playback: false,
                devices: new observers.ObservableClass(new Array())
            };
            let allDevices = new observers.ObservableClass([]);
            {
                let computer = () => {
                    let devices = session.devices.getState();
                    let chromecasts = this.chromecasts.getState().filter((chromecast) => {
                        return is.absent(devices.find((device) => {
                            return device.id === chromecast.id;
                        }));
                    });
                    allDevices.updateState([...devices, ...chromecasts]);
                };
                session.devices.addObserver(computer);
                this.chromecasts.addObserver(computer);
            }
            allDevices.addObserver((allDevices) => {
                this.tss.send("SetDevices", session.devices.getState().map((device) => {
                    return device.id;
                }), {
                    devices: allDevices
                });
            });
            session.devices.addObserver((devices) => {
                this.updateProgress(session);
            });
            session.devices.addObserver((devices) => {
                let deviceWasLost = is.absent(devices.find((device) => {
                    return device.id === session.device?.id;
                }));
                if (deviceWasLost) {
                    this.updateProgress(session);
                    session.playback = false;
                    this.tss.send("SetPlayback", devices.map((device) => {
                        return device.id;
                    }), {
                        playback: session.playback
                    });
                    session.device = undefined;
                    this.tss.send("SetDevice", devices.map((device) => {
                        return device.id;
                    }), {
                        device: session.device
                    });
                }
            });
            this.sessions.set(user_id, session);
            return session;
        }
        revokeAuthentication(connection_id) {
            let token = this.tokens.get(connection_id);
            this.tokens.delete(connection_id);
            if (is.present(token)) {
                let user_id = auth.getUserId(token);
                let session = this.sessions.get(user_id);
                if (is.present(session)) {
                    let devices = session.devices;
                    devices.updateState(devices.getState().filter((device) => {
                        return device.id !== connection_id;
                    }));
                }
            }
        }
        updateProgress(session) {
            let now = Date.now();
            if (session.playback) {
                if (is.present(session.progress) && is.present(session.progressTimestamp)) {
                    session.progress += (now - session.progressTimestamp) / 1000;
                }
            }
            session.progressTimestamp = now;
        }
        getRequestHandler() {
            return this.tss.getRequestHandler();
        }
    }
    exports.ContextServer = ContextServer;
});
define("build/player/index", ["require", "exports", "build/player/client", "build/player/server", "build/player/schema/index"], function (require, exports, client, server, schema) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.schema = exports.server = exports.client = void 0;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.schema = exports.server = exports.client = void 0;
    exports.client = client;
    exports.server = server;
    exports.schema = schema;
});
define("build/playlists/schema/messages", ["require", "exports", "build/api/schema/objects", "build/api/schema/objects", "node_modules/@joelek/ts-autoguard/build/autoguard-lib/index"], function (require, exports, objects_1, objects_2, ts_autoguard_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.UpdatePlaylistItem = exports.UpdatePlaylistItemResponse = exports.UpdatePlaylistItemRequest = exports.DeletePlaylistItem = exports.DeletePlaylistItemResponse = exports.DeletePlaylistItemRequest = exports.CreatePlaylistItem = exports.CreatePlaylistItemResponse = exports.CreatePlaylistItemRequest = exports.UpdatePlaylist = exports.UpdatePlaylistResponse = exports.UpdatePlaylistRequest = exports.DeletePlaylist = exports.DeletePlaylistResponse = exports.DeletePlaylistRequest = exports.CreatePlaylist = exports.CreatePlaylistResponse = exports.CreatePlaylistRequest = exports.PermissionsResponse = exports.PermissionsRequest = exports.SetToken = void 0;
    exports.SetToken = ts_autoguard_1.guards.Object.of({
        "token": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.String)
    });
    exports.PermissionsRequest = ts_autoguard_1.guards.Object.of({
        "playlist": ts_autoguard_1.guards.Object.of({
            "playlist_id": ts_autoguard_1.guards.String
        })
    });
    exports.PermissionsResponse = ts_autoguard_1.guards.Object.of({
        "permissions": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.StringLiteral.of("read"), ts_autoguard_1.guards.StringLiteral.of("write"))
    });
    exports.CreatePlaylistRequest = ts_autoguard_1.guards.Object.of({
        "playlist": ts_autoguard_1.guards.Object.of({
            "title": ts_autoguard_1.guards.String,
            "description": ts_autoguard_1.guards.String
        })
    });
    exports.CreatePlaylistResponse = ts_autoguard_1.guards.Object.of({
        "errors": ts_autoguard_1.guards.Array.of(ts_autoguard_1.guards.String),
        "playlist_id": ts_autoguard_1.guards.String
    });
    exports.CreatePlaylist = ts_autoguard_1.guards.Object.of({
        "playlist": ts_autoguard_1.guards.Reference.of(() => objects_1.PlaylistBase)
    });
    exports.DeletePlaylistRequest = ts_autoguard_1.guards.Object.of({
        "playlist": ts_autoguard_1.guards.Object.of({
            "playlist_id": ts_autoguard_1.guards.String
        })
    });
    exports.DeletePlaylistResponse = ts_autoguard_1.guards.Object.of({
        "errors": ts_autoguard_1.guards.Array.of(ts_autoguard_1.guards.String)
    });
    exports.DeletePlaylist = ts_autoguard_1.guards.Object.of({
        "playlist": ts_autoguard_1.guards.Reference.of(() => objects_1.PlaylistBase)
    });
    exports.UpdatePlaylistRequest = ts_autoguard_1.guards.Object.of({
        "playlist": ts_autoguard_1.guards.Object.of({
            "playlist_id": ts_autoguard_1.guards.String,
            "title": ts_autoguard_1.guards.String,
            "description": ts_autoguard_1.guards.String
        })
    });
    exports.UpdatePlaylistResponse = ts_autoguard_1.guards.Object.of({
        "errors": ts_autoguard_1.guards.Array.of(ts_autoguard_1.guards.String)
    });
    exports.UpdatePlaylist = ts_autoguard_1.guards.Object.of({
        "playlist": ts_autoguard_1.guards.Reference.of(() => objects_1.PlaylistBase)
    });
    exports.CreatePlaylistItemRequest = ts_autoguard_1.guards.Object.of({
        "playlist_item": ts_autoguard_1.guards.Object.of({
            "playlist_id": ts_autoguard_1.guards.String,
            "track_id": ts_autoguard_1.guards.String
        })
    });
    exports.CreatePlaylistItemResponse = ts_autoguard_1.guards.Object.of({
        "errors": ts_autoguard_1.guards.Array.of(ts_autoguard_1.guards.String),
        "playlist_item_id": ts_autoguard_1.guards.String
    });
    exports.CreatePlaylistItem = ts_autoguard_1.guards.Object.of({
        "playlist_item": ts_autoguard_1.guards.Reference.of(() => objects_2.PlaylistItemBase)
    });
    exports.DeletePlaylistItemRequest = ts_autoguard_1.guards.Object.of({
        "playlist_item": ts_autoguard_1.guards.Object.of({
            "playlist_item_id": ts_autoguard_1.guards.String
        })
    });
    exports.DeletePlaylistItemResponse = ts_autoguard_1.guards.Object.of({
        "errors": ts_autoguard_1.guards.Array.of(ts_autoguard_1.guards.String)
    });
    exports.DeletePlaylistItem = ts_autoguard_1.guards.Object.of({
        "playlist_item": ts_autoguard_1.guards.Reference.of(() => objects_2.PlaylistItemBase)
    });
    exports.UpdatePlaylistItemRequest = ts_autoguard_1.guards.Object.of({
        "playlist_item": ts_autoguard_1.guards.Object.of({
            "playlist_item_id": ts_autoguard_1.guards.String,
            "number": ts_autoguard_1.guards.Number
        })
    });
    exports.UpdatePlaylistItemResponse = ts_autoguard_1.guards.Object.of({
        "errors": ts_autoguard_1.guards.Array.of(ts_autoguard_1.guards.String)
    });
    exports.UpdatePlaylistItem = ts_autoguard_1.guards.Object.of({
        "playlist_item": ts_autoguard_1.guards.Reference.of(() => objects_2.PlaylistItemBase)
    });
    exports.Autoguard = {
        "SetToken": exports.SetToken,
        "PermissionsRequest": exports.PermissionsRequest,
        "PermissionsResponse": exports.PermissionsResponse,
        "CreatePlaylistRequest": exports.CreatePlaylistRequest,
        "CreatePlaylistResponse": exports.CreatePlaylistResponse,
        "CreatePlaylist": exports.CreatePlaylist,
        "DeletePlaylistRequest": exports.DeletePlaylistRequest,
        "DeletePlaylistResponse": exports.DeletePlaylistResponse,
        "DeletePlaylist": exports.DeletePlaylist,
        "UpdatePlaylistRequest": exports.UpdatePlaylistRequest,
        "UpdatePlaylistResponse": exports.UpdatePlaylistResponse,
        "UpdatePlaylist": exports.UpdatePlaylist,
        "CreatePlaylistItemRequest": exports.CreatePlaylistItemRequest,
        "CreatePlaylistItemResponse": exports.CreatePlaylistItemResponse,
        "CreatePlaylistItem": exports.CreatePlaylistItem,
        "DeletePlaylistItemRequest": exports.DeletePlaylistItemRequest,
        "DeletePlaylistItemResponse": exports.DeletePlaylistItemResponse,
        "DeletePlaylistItem": exports.DeletePlaylistItem,
        "UpdatePlaylistItemRequest": exports.UpdatePlaylistItemRequest,
        "UpdatePlaylistItemResponse": exports.UpdatePlaylistItemResponse,
        "UpdatePlaylistItem": exports.UpdatePlaylistItem
    };
});
define("build/playlists/client", ["require", "exports", "build/observers/index", "build/jsondb/index", "build/playlists/schema/messages", "build/typesockets/client"], function (require, exports, observers, jsondb, messages, typesockets) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PlaylistsClient = void 0;
    class PlaylistsClient {
        constructor(url, factory = (url) => new WebSocket(url)) {
            this.token = new observers.ObservableClass(undefined);
            this.online = new observers.ObservableClass(false);
            this.playlists = new observers.ArrayObservable(new Array());
            this.tsc = new typesockets.TypeSocketClient(url, factory, messages.Autoguard);
            this.tsc.addEventListener("sys", "connect", () => {
                this.online.updateState(true);
            });
            this.tsc.addEventListener("sys", "disconnect", () => {
                this.online.updateState(false);
            });
            observers.computed((isOnline, token) => {
                if (isOnline) {
                    this.tsc.send("SetToken", {
                        token
                    });
                }
            }, this.online, this.token);
            this.tsc.addEventListener("app", "CreatePlaylist", (message) => {
                let deletions = 0;
                for (let [index, playlist] of this.playlists.getState().entries()) {
                    let state = playlist.getState();
                    if (state.playlist_id === message.playlist.playlist_id) {
                        this.playlists.splice(index - deletions);
                    }
                }
                let playlist = {
                    ...message.playlist,
                    items: new Array()
                };
                this.playlists.append(new observers.ObservableClass(playlist));
            });
            this.tsc.addEventListener("app", "DeletePlaylist", (message) => {
                let deletions = 0;
                for (let [index, playlist] of this.playlists.getState().entries()) {
                    let state = playlist.getState();
                    if (state.playlist_id === message.playlist.playlist_id) {
                        this.playlists.splice(index - deletions);
                    }
                }
            });
            this.tsc.addEventListener("app", "UpdatePlaylist", (message) => {
                for (let [index, playlist] of this.playlists.getState().entries()) {
                    let state = playlist.getState();
                    if (state.playlist_id === message.playlist.playlist_id) {
                        playlist.updateState({
                            ...state,
                            ...message.playlist
                        });
                    }
                }
            });
            this.tsc.addEventListener("app", "CreatePlaylistItem", (message) => {
                for (let [index, playlist] of this.playlists.getState().entries()) {
                    let state = playlist.getState();
                    if (state.playlist_id === message.playlist_item.playlist.playlist_id) {
                        let items = state.items.filter((item) => item.playlist_item_id !== message.playlist_item.playlist_item_id);
                        let deletions = state.items.length - items.length;
                        items.push(message.playlist_item);
                        let additions = 1;
                        items = items
                            .map((item) => ({
                            ...item,
                            number: item.number + (item.number > message.playlist_item.number ? additions - deletions : 0)
                        }))
                            .sort(jsondb.NumericSort.increasing((record) => record.number));
                        state = {
                            ...state,
                            items: items
                        };
                        playlist.updateState(state);
                    }
                }
            });
            this.tsc.addEventListener("app", "DeletePlaylistItem", (message) => {
                for (let [index, playlist] of this.playlists.getState().entries()) {
                    let state = playlist.getState();
                    if (state.playlist_id === message.playlist_item.playlist.playlist_id) {
                        let items = state.items.filter((item) => item.playlist_item_id !== message.playlist_item.playlist_item_id);
                        let deletions = state.items.length - items.length;
                        let additions = 0;
                        items = items
                            .map((item) => ({
                            ...item,
                            number: item.number + (item.number > message.playlist_item.number ? additions - deletions : 0)
                        }))
                            .sort(jsondb.NumericSort.increasing((record) => record.number));
                        state = {
                            ...state,
                            items: items
                        };
                        playlist.updateState(state);
                    }
                }
            });
            this.tsc.addEventListener("app", "UpdatePlaylistItem", (message) => {
                for (let [index, playlist] of this.playlists.getState().entries()) {
                    let state = playlist.getState();
                    if (state.playlist_id === message.playlist_item.playlist.playlist_id) {
                        let old_index = state.items.findIndex((item) => item.playlist_item_id === message.playlist_item.playlist_item_id);
                        if (old_index >= 0) {
                            let new_index = message.playlist_item.number - 1;
                            if (new_index > old_index) {
                                for (let i = old_index + 1; i < new_index; i++) {
                                    state.items[i].number -= 1;
                                }
                                state.items.splice(new_index, 0, ...state.items.splice(old_index, 1));
                            }
                            else if (new_index < old_index) {
                                for (let i = new_index; i < old_index; i++) {
                                    state.items[i].number += 1;
                                }
                                state.items.splice(new_index, 0, ...state.items.splice(old_index, 1));
                            }
                            state.items[new_index] = {
                                ...state.items[new_index],
                                ...message.playlist_item
                            };
                            playlist.updateState({
                                ...state
                            });
                        }
                    }
                }
            });
        }
        authenticate(token) {
            this.token.updateState(token);
        }
        isOnline() {
            return this.online.getState();
        }
        getPermissions(request) {
            return this.tsc.request("PermissionsRequest", "PermissionsResponse", request);
        }
        createPlaylist(request) {
            return this.tsc.request("CreatePlaylistRequest", "CreatePlaylistResponse", request);
        }
        deletePlaylist(request) {
            return this.tsc.request("DeletePlaylistRequest", "DeletePlaylistResponse", request);
        }
        updatePlaylist(request) {
            return this.tsc.request("UpdatePlaylistRequest", "UpdatePlaylistResponse", request);
        }
        createPlaylistItem(request) {
            return this.tsc.request("CreatePlaylistItemRequest", "CreatePlaylistItemResponse", request);
        }
        deletePlaylistItem(request) {
            return this.tsc.request("DeletePlaylistItemRequest", "DeletePlaylistItemResponse", request);
        }
        updatePlaylistItem(request) {
            return this.tsc.request("UpdatePlaylistItemRequest", "UpdatePlaylistItemResponse", request);
        }
        close() {
            this.tsc.close();
        }
        reconnect() {
            this.tsc.reconnect();
        }
    }
    exports.PlaylistsClient = PlaylistsClient;
    ;
});
define("build/playlists/schema/objects", ["require", "exports"], function (require, exports) {
    "use strict";
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = void 0;
    exports.Autoguard = {};
});
define("build/playlists/schema/index", ["require", "exports", "build/playlists/schema/messages", "build/playlists/schema/objects"], function (require, exports, messages, objects) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.objects = exports.messages = void 0;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.objects = exports.messages = void 0;
    exports.messages = messages;
    exports.objects = objects;
});
define("build/api/index", ["require", "exports", "build/api/handler", "build/api/schema/index"], function (require, exports, handler, schema) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.schema = exports.handler = void 0;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.schema = exports.handler = void 0;
    exports.handler = handler;
    exports.schema = schema;
});
define("build/playlists/server", ["require", "exports", "crypto", "build/server/auth", "build/is", "build/playlists/schema/index", "build/database/indexer", "build/typesockets/index", "build/jsondb/index", "build/api/index"], function (require, exports, libcrypto, auth, is, schema, database, typesockets, jsondb, api) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PlaylistsServer = void 0;
    class PlaylistsServer {
        constructor() {
            this.tokens = new Map();
            this.sessions = new Map();
            this.tss = new typesockets.TypeSocketServer(schema.messages.Autoguard);
            this.tss.addEventListener("sys", "connect", (message) => {
            });
            this.tss.addEventListener("sys", "disconnect", (message) => {
                this.revokeAuthentication(message.connection_id);
            });
            this.tss.addEventListener("app", "SetToken", (message) => {
                this.revokeAuthentication(message.connection_id);
                let token = message.data.token;
                if (is.present(token)) {
                    let user_id = auth.getUserId(token);
                    this.tokens.set(message.connection_id, token);
                    let session = this.getOrCreateSession(user_id);
                    session.connections.add(message.connection_id);
                    for (let playlist of database.getPlaylistsFromUser.lookup(user_id)) {
                        this.tss.send("CreatePlaylist", message.connection_id, {
                            playlist: api.handler.lookupPlaylistBase(playlist.playlist_id, user_id)
                        });
                        for (let playlist_item of database.getPlaylistsItemsFromPlaylist.lookup(playlist.playlist_id)) {
                            this.tss.send("CreatePlaylistItem", message.connection_id, {
                                playlist_item: api.handler.lookupPlaylistItemBase(playlist_item.playlist_item_id, user_id)
                            });
                        }
                    }
                }
            });
            this.tss.addEventListener("app", "PermissionsRequest", (message) => {
                let token = this.tokens.get(message.connection_id);
                if (is.present(token)) {
                    let user_id = auth.getUserId(token);
                    let playlist = database.playlists.lookup(message.data.playlist.playlist_id);
                    if (playlist.user_id === user_id) {
                        this.tss.respond(message, "PermissionsResponse", {
                            permissions: "write"
                        });
                    }
                    else {
                        this.tss.respond(message, "PermissionsResponse", {
                            permissions: "read"
                        });
                    }
                }
            });
            this.tss.addEventListener("app", "CreatePlaylistRequest", (message) => {
                let token = this.tokens.get(message.connection_id);
                if (is.present(token)) {
                    let user_id = auth.getUserId(token);
                    let errors = new Array();
                    let title = message.data.playlist.title;
                    if (Buffer.from(title).length >= 256) {
                        errors.push(`The playlist title is too long!`);
                    }
                    let description = message.data.playlist.description;
                    if (Buffer.from(description).length >= 256) {
                        errors.push(`The playlist description is too long!`);
                    }
                    let playlist_id = libcrypto.randomBytes(8).toString("hex");
                    this.tss.respond(message, "CreatePlaylistResponse", {
                        errors,
                        playlist_id
                    });
                    if (errors.length > 0) {
                        return;
                    }
                    let playlist = {
                        playlist_id: playlist_id,
                        title: title,
                        description: description,
                        user_id: user_id
                    };
                    database.playlists.insert(playlist);
                    let session = this.getOrCreateSession(user_id);
                    this.tss.send("CreatePlaylist", Array.from(session.connections), {
                        playlist: api.handler.lookupPlaylistBase(playlist.playlist_id, user_id)
                    });
                }
            });
            this.tss.addEventListener("app", "DeletePlaylistRequest", (message) => {
                let token = this.tokens.get(message.connection_id);
                if (is.present(token)) {
                    let user_id = auth.getUserId(token);
                    let errors = new Array();
                    let playlist_id = message.data.playlist.playlist_id;
                    let playlist = database.playlists.lookup(playlist_id);
                    if (playlist.user_id !== user_id) {
                        errors.push(`You don't have sufficient rights to alter the desired playlist!`);
                    }
                    this.tss.respond(message, "DeletePlaylistResponse", {
                        errors
                    });
                    if (errors.length > 0) {
                        return;
                    }
                    let session = this.getOrCreateSession(user_id);
                    this.tss.send("DeletePlaylist", Array.from(session.connections), {
                        playlist: api.handler.lookupPlaylistBase(playlist.playlist_id, user_id)
                    });
                    database.playlists.remove(playlist);
                }
            });
            this.tss.addEventListener("app", "UpdatePlaylistRequest", (message) => {
                let token = this.tokens.get(message.connection_id);
                if (is.present(token)) {
                    let user_id = auth.getUserId(token);
                    let errors = new Array();
                    let playlist_id = message.data.playlist.playlist_id;
                    let playlist = database.playlists.lookup(playlist_id);
                    if (playlist.user_id !== user_id) {
                        errors.push(`You don't have sufficient rights to alter the desired playlist!`);
                    }
                    let title = message.data.playlist.title;
                    if (Buffer.from(title).length >= 256) {
                        errors.push(`The playlist title is too long!`);
                    }
                    let description = message.data.playlist.description;
                    if (Buffer.from(description).length >= 256) {
                        errors.push(`The playlist description is too long!`);
                    }
                    this.tss.respond(message, "UpdatePlaylistResponse", {
                        errors
                    });
                    if (errors.length > 0) {
                        return;
                    }
                    database.playlists.update({
                        ...playlist,
                        ...message.data.playlist
                    });
                    let session = this.getOrCreateSession(user_id);
                    this.tss.send("UpdatePlaylist", Array.from(session.connections), {
                        playlist: api.handler.lookupPlaylistBase(playlist.playlist_id, user_id)
                    });
                }
            });
            this.tss.addEventListener("app", "CreatePlaylistItemRequest", (message) => {
                let token = this.tokens.get(message.connection_id);
                if (is.present(token)) {
                    let user_id = auth.getUserId(token);
                    let errors = new Array();
                    let playlist_id = message.data.playlist_item.playlist_id;
                    let playlist = database.playlists.lookup(playlist_id);
                    if (playlist.user_id !== user_id) {
                        errors.push(`You don't have sufficient rights to alter the desired playlist!`);
                    }
                    let track_id = message.data.playlist_item.track_id;
                    let track = database.tracks.lookup(track_id);
                    let playlist_item_id = libcrypto.randomBytes(8).toString("hex");
                    this.tss.respond(message, "CreatePlaylistItemResponse", {
                        errors,
                        playlist_item_id
                    });
                    if (errors.length > 0) {
                        return;
                    }
                    let playlist_items = database.getPlaylistsItemsFromPlaylist.lookup(playlist_id)
                        .sort(jsondb.NumericSort.increasing((record) => record.number))
                        .collect();
                    let playlist_item = {
                        playlist_item_id: playlist_item_id,
                        playlist_id: playlist_id,
                        track_id: track_id,
                        number: (playlist_items.pop()?.number ?? 0) + 1,
                        added_ms: Date.now()
                    };
                    database.playlist_items.insert(playlist_item);
                    let session = this.getOrCreateSession(user_id);
                    this.tss.send("CreatePlaylistItem", Array.from(session.connections), {
                        playlist_item: api.handler.lookupPlaylistItemBase(playlist_item.playlist_item_id, user_id)
                    });
                }
            });
            this.tss.addEventListener("app", "DeletePlaylistItemRequest", (message) => {
                let token = this.tokens.get(message.connection_id);
                if (is.present(token)) {
                    let user_id = auth.getUserId(token);
                    let errors = new Array();
                    let playlist_item_id = message.data.playlist_item.playlist_item_id;
                    let playlist_item = database.playlist_items.lookup(playlist_item_id);
                    let playlist = database.playlists.lookup(playlist_item.playlist_id);
                    if (playlist.user_id !== user_id) {
                        errors.push(`You don't have sufficient rights to alter the desired playlist!`);
                    }
                    this.tss.respond(message, "DeletePlaylistItemResponse", {
                        errors
                    });
                    if (errors.length > 0) {
                        return;
                    }
                    let number = playlist_item.number;
                    let playlist_items = database.getPlaylistsItemsFromPlaylist.lookup(playlist.playlist_id)
                        .sort(jsondb.NumericSort.increasing((record) => record.number));
                    for (let playlist_item of playlist_items) {
                        if (playlist_item.number > number) {
                            playlist_item.number -= 1;
                            database.playlist_items.update(playlist_item);
                        }
                    }
                    let session = this.getOrCreateSession(user_id);
                    this.tss.send("DeletePlaylistItem", Array.from(session.connections), {
                        playlist_item: api.handler.lookupPlaylistItemBase(playlist_item.playlist_item_id, user_id)
                    });
                    database.playlist_items.remove(playlist_item);
                }
            });
            this.tss.addEventListener("app", "UpdatePlaylistItemRequest", (message) => {
                let token = this.tokens.get(message.connection_id);
                if (is.present(token)) {
                    let user_id = auth.getUserId(token);
                    let errors = new Array();
                    let playlist_item_id = message.data.playlist_item.playlist_item_id;
                    let playlist_item = database.playlist_items.lookup(playlist_item_id);
                    let playlist = database.playlists.lookup(playlist_item.playlist_id);
                    if (playlist.user_id !== user_id) {
                        errors.push(`You don't have sufficient rights to alter the desired playlist!`);
                    }
                    let number = message.data.playlist_item.number;
                    let playlist_items = database.getPlaylistsItemsFromPlaylist.lookup(playlist.playlist_id)
                        .sort(jsondb.NumericSort.increasing((record) => record.number))
                        .collect();
                    if (number < 1 || number > playlist_items.length) {
                        errors.push(`Expected a position between ${1} and ${playlist_items.length} (${number})!`);
                    }
                    this.tss.respond(message, "UpdatePlaylistItemResponse", {
                        errors
                    });
                    if (errors.length > 0) {
                        return;
                    }
                    let old_index = number - 1;
                    let new_index = message.data.playlist_item.number - 1;
                    if (new_index > old_index) {
                        for (let i = old_index + 1; i < new_index; i++) {
                            let playlist_item = playlist_items[i];
                            playlist_item.number -= 1;
                            database.playlist_items.update(playlist_item);
                        }
                    }
                    else if (new_index < old_index) {
                        for (let i = new_index; i < old_index; i++) {
                            let playlist_item = playlist_items[i];
                            playlist_item.number += 1;
                            database.playlist_items.update(playlist_item);
                        }
                    }
                    playlist_item.number = number;
                    database.playlist_items.update({
                        ...playlist_item,
                        ...message.data.playlist_item
                    });
                    let session = this.getOrCreateSession(user_id);
                    this.tss.send("UpdatePlaylistItem", Array.from(session.connections), {
                        playlist_item: api.handler.lookupPlaylistItemBase(playlist_item.playlist_item_id, user_id)
                    });
                }
            });
        }
        getOrCreateSession(user_id) {
            let session = this.sessions.get(user_id);
            if (is.present(session)) {
                return session;
            }
            session = {
                connections: new Set()
            };
            this.sessions.set(user_id, session);
            return session;
        }
        revokeAuthentication(connection_id) {
            let token = this.tokens.get(connection_id);
            this.tokens.delete(connection_id);
            if (is.present(token)) {
                let user_id = auth.getUserId(token);
                let session = this.sessions.get(user_id);
                if (is.present(session)) {
                    let connections = session.connections;
                    connections.delete(connection_id);
                }
            }
        }
        getRequestHandler() {
            return this.tss.getRequestHandler();
        }
    }
    exports.PlaylistsServer = PlaylistsServer;
    ;
});
define("build/playlists/index", ["require", "exports", "build/playlists/client", "build/playlists/server", "build/playlists/schema/index"], function (require, exports, client, server, schema) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.schema = exports.server = exports.client = void 0;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.schema = exports.server = exports.client = void 0;
    exports.client = client;
    exports.server = server;
    exports.schema = schema;
});
define("build/chromecast/protobuf", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serializeOptionalBuffer = exports.parseOptionalBuffer = exports.serializeRequiredBuffer = exports.parseRequiredBuffer = exports.serializeOptionalString = exports.parseOptionalString = exports.serializeRequiredString = exports.parseRequiredString = exports.serializeRequiredEnum = exports.parseRequiredEnum = exports.parseFields = exports.serializeField = exports.parseField = exports.serializeKey = exports.parseKey = exports.makeUInt64LE = exports.serializeVarint = exports.parseVarint = exports.WireType = exports.readBytes = exports.numberFromBigInt = void 0;
    function numberFromBigInt(bigint) {
        if (bigint > Number.MAX_SAFE_INTEGER || bigint < Number.MIN_SAFE_INTEGER) {
            throw `Expected a safe integer but got ${bigint}!`;
        }
        return Number(bigint);
    }
    exports.numberFromBigInt = numberFromBigInt;
    ;
    function readBytes(state, length) {
        let remaining = state.buffer.length - state.offset;
        if (length > remaining) {
            throw `Expected to read at most ${remaining} bytes but attempted to read ${length} bytes!`;
        }
        let buffer = state.buffer.slice(state.offset, state.offset + length);
        state.offset += length;
        return buffer;
    }
    exports.readBytes = readBytes;
    ;
    var WireType;
    (function (WireType) {
        WireType[WireType["VARINT"] = 0] = "VARINT";
        WireType[WireType["FIXED_64_BIT"] = 1] = "FIXED_64_BIT";
        WireType[WireType["LENGTH_DELIMITED"] = 2] = "LENGTH_DELIMITED";
        WireType[WireType["START_GROUP"] = 3] = "START_GROUP";
        WireType[WireType["END_GROUP"] = 4] = "END_GROUP";
        WireType[WireType["FIXED_32_BIT"] = 5] = "FIXED_32_BIT";
    })(WireType = exports.WireType || (exports.WireType = {}));
    ;
    function parseVarint(state) {
        let bytes = Buffer.alloc(10);
        for (let i = 0; i < 10; i++) {
            let byte = state.buffer.readUInt8(state.offset);
            state.offset += 1;
            bytes[i] = byte;
            if ((byte & 0x80) === 0) {
                if (i + 1 === 10) {
                    if ((byte & 0x7E) !== 0) {
                        throw "Expected a varint of at most 64 bits!";
                    }
                }
                let value = BigInt(0);
                for (let j = i; j >= 0; j--) {
                    value = (value << BigInt(7)) | BigInt(bytes[j] & 0x7F);
                }
                let buffer = Buffer.alloc(8);
                buffer.writeBigUInt64LE(value, 0);
                return buffer;
            }
        }
        throw "Expected a varint of at most 10 bytes!";
    }
    exports.parseVarint = parseVarint;
    ;
    function serializeVarint(buffer) {
        let bigint = buffer.readBigUInt64LE(0);
        let result = Buffer.alloc(10);
        for (let i = 0; i < 10; i++) {
            let byte = (bigint & BigInt(0x7F));
            bigint = (bigint >> BigInt(7));
            if (bigint > 0) {
                result.writeUInt8(numberFromBigInt(byte) | 0x80, i);
            }
            else {
                result.writeUInt8(numberFromBigInt(byte) | 0x00, i);
                return result.slice(0, i + 1);
            }
        }
        throw "Expected to serialize at most 10 bytes!";
    }
    exports.serializeVarint = serializeVarint;
    ;
    function makeUInt64LE(number) {
        let buffer = Buffer.alloc(8);
        buffer.writeBigUInt64LE(BigInt(number));
        return buffer;
    }
    exports.makeUInt64LE = makeUInt64LE;
    ;
    function parseKey(state) {
        let bigint = parseVarint(state).readBigUInt64LE(0);
        let field_number = numberFromBigInt(bigint >> BigInt(3));
        let wire_type = numberFromBigInt(bigint & BigInt(0x07));
        return {
            field_number,
            wire_type
        };
    }
    exports.parseKey = parseKey;
    ;
    function serializeKey(key) {
        let bigint = (BigInt(key.field_number) << BigInt(3)) | (BigInt(key.wire_type) & BigInt(0x07));
        let buffer = Buffer.alloc(8);
        buffer.writeBigUInt64LE(bigint, 0);
        return serializeVarint(buffer);
    }
    exports.serializeKey = serializeKey;
    ;
    function parseField(state) {
        let key = parseKey(state);
        if (key.wire_type === WireType.VARINT) {
            let data = parseVarint(state);
            return {
                key,
                data
            };
        }
        if (key.wire_type === WireType.FIXED_64_BIT) {
            let data = readBytes(state, 8);
            return {
                key,
                data
            };
        }
        if (key.wire_type === WireType.LENGTH_DELIMITED) {
            let bigint = parseVarint(state).readBigUInt64LE(0);
            let length = numberFromBigInt(bigint);
            let data = readBytes(state, length);
            return {
                key,
                data
            };
        }
        if (key.wire_type === WireType.START_GROUP) {
            let data = Buffer.alloc(0);
            return {
                key,
                data
            };
        }
        if (key.wire_type === WireType.END_GROUP) {
            let data = Buffer.alloc(0);
            return {
                key,
                data
            };
        }
        if (key.wire_type === WireType.FIXED_32_BIT) {
            let data = readBytes(state, 4);
            return {
                key,
                data
            };
        }
        throw "Expected a recognized wire type!";
    }
    exports.parseField = parseField;
    ;
    function serializeField(field) {
        if (field.key.wire_type === WireType.VARINT) {
            return Buffer.concat([
                serializeKey(field.key),
                serializeVarint(field.data)
            ]);
        }
        if (field.key.wire_type === WireType.FIXED_64_BIT) {
            if (field.data.length !== 8) {
                throw `Expected to serialize exactly 8 bytes!`;
            }
            return Buffer.concat([
                serializeKey(field.key),
                field.data
            ]);
        }
        if (field.key.wire_type === WireType.LENGTH_DELIMITED) {
            let length = Buffer.alloc(8);
            length.writeBigUInt64LE(BigInt(field.data.length));
            return Buffer.concat([
                serializeKey(field.key),
                serializeVarint(length),
                field.data
            ]);
        }
        if (field.key.wire_type === WireType.START_GROUP) {
            if (field.data.length !== 0) {
                throw `Expected to serialize exactly 0 bytes!`;
            }
            return Buffer.concat([
                serializeKey(field.key),
                field.data
            ]);
        }
        if (field.key.wire_type === WireType.END_GROUP) {
            if (field.data.length !== 0) {
                throw `Expected to serialize exactly 0 bytes!`;
            }
            return Buffer.concat([
                serializeKey(field.key),
                field.data
            ]);
        }
        if (field.key.wire_type === WireType.FIXED_32_BIT) {
            if (field.data.length !== 4) {
                throw `Expected to serialize exactly 4 bytes!`;
            }
            return Buffer.concat([
                serializeKey(field.key),
                field.data
            ]);
        }
        throw "Expected a recognized wire type!";
    }
    exports.serializeField = serializeField;
    ;
    function parseFields(state) {
        let fields = new Array();
        while (state.offset < state.buffer.length) {
            let field = parseField(state);
            fields.push(field);
        }
        return fields;
    }
    exports.parseFields = parseFields;
    ;
    function parseRequiredEnum(field_number, fields) {
        let candidates = fields.filter((field) => field.key.field_number === field_number);
        if (candidates.length === 0) {
            throw `Expected required field to be present!`;
        }
        let field = candidates[candidates.length - 1];
        let value = numberFromBigInt(field.data.readBigUInt64LE(0));
        return value;
    }
    exports.parseRequiredEnum = parseRequiredEnum;
    ;
    function serializeRequiredEnum(field_number, value) {
        let key = {
            field_number,
            wire_type: WireType.VARINT
        };
        let data = makeUInt64LE(value);
        return serializeField({
            key,
            data
        });
    }
    exports.serializeRequiredEnum = serializeRequiredEnum;
    ;
    function parseRequiredString(field_number, fields) {
        let candidates = fields.filter((field) => field.key.field_number === field_number);
        if (candidates.length === 0) {
            throw `Expected required field to be present!`;
        }
        let field = candidates[candidates.length - 1];
        let value = field.data.toString();
        return value;
    }
    exports.parseRequiredString = parseRequiredString;
    ;
    function serializeRequiredString(field_number, value) {
        let key = {
            field_number,
            wire_type: WireType.LENGTH_DELIMITED
        };
        let data = Buffer.from(value);
        return serializeField({
            key,
            data
        });
    }
    exports.serializeRequiredString = serializeRequiredString;
    ;
    function parseOptionalString(field_number, fields) {
        try {
            return parseRequiredString(field_number, fields);
        }
        catch (error) {
            return undefined;
        }
    }
    exports.parseOptionalString = parseOptionalString;
    ;
    function serializeOptionalString(field_number, value) {
        if (value == null) {
            return Buffer.alloc(0);
        }
        return serializeRequiredString(field_number, value);
    }
    exports.serializeOptionalString = serializeOptionalString;
    ;
    function parseRequiredBuffer(field_number, fields) {
        let candidates = fields.filter((field) => field.key.field_number === field_number);
        if (candidates.length === 0) {
            throw `Expected required field to be present!`;
        }
        let field = candidates[candidates.length - 1];
        let value = field.data;
        return value;
    }
    exports.parseRequiredBuffer = parseRequiredBuffer;
    ;
    function serializeRequiredBuffer(field_number, value) {
        let key = {
            field_number,
            wire_type: WireType.LENGTH_DELIMITED
        };
        let data = value;
        return serializeField({
            key,
            data
        });
    }
    exports.serializeRequiredBuffer = serializeRequiredBuffer;
    ;
    function parseOptionalBuffer(field_number, fields) {
        try {
            return parseRequiredBuffer(field_number, fields);
        }
        catch (error) {
            return undefined;
        }
    }
    exports.parseOptionalBuffer = parseOptionalBuffer;
    ;
    function serializeOptionalBuffer(field_number, value) {
        if (value == null) {
            return Buffer.alloc(0);
        }
        return serializeRequiredBuffer(field_number, value);
    }
    exports.serializeOptionalBuffer = serializeOptionalBuffer;
    ;
});
define("build/chromecast/cast_message", ["require", "exports", "build/chromecast/protobuf"], function (require, exports, protobuf) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serializeCastMessage = exports.parseCastMessage = exports.PayloadType = exports.ProtocolVersion = void 0;
    var ProtocolVersion;
    (function (ProtocolVersion) {
        ProtocolVersion[ProtocolVersion["CASTV2_1_0"] = 0] = "CASTV2_1_0";
    })(ProtocolVersion = exports.ProtocolVersion || (exports.ProtocolVersion = {}));
    ;
    var PayloadType;
    (function (PayloadType) {
        PayloadType[PayloadType["STRING"] = 0] = "STRING";
        PayloadType[PayloadType["BINARY"] = 1] = "BINARY";
    })(PayloadType = exports.PayloadType || (exports.PayloadType = {}));
    ;
    function parseCastMessage(buffer) {
        let fields = protobuf.parseFields({
            buffer: buffer,
            offset: 0
        });
        let protocol_version = protobuf.parseRequiredEnum(1, fields);
        let source_id = protobuf.parseRequiredString(2, fields);
        let destination_id = protobuf.parseRequiredString(3, fields);
        let namespace = protobuf.parseRequiredString(4, fields);
        let payload_type = protobuf.parseRequiredEnum(5, fields);
        let payload_utf8 = protobuf.parseOptionalString(6, fields);
        let payload_binary = protobuf.parseOptionalBuffer(7, fields);
        return {
            protocol_version,
            source_id,
            destination_id,
            namespace,
            payload_type,
            payload_utf8,
            payload_binary
        };
    }
    exports.parseCastMessage = parseCastMessage;
    ;
    function serializeCastMessage(message) {
        return Buffer.concat([
            protobuf.serializeRequiredEnum(1, message.protocol_version),
            protobuf.serializeRequiredString(2, message.source_id),
            protobuf.serializeRequiredString(3, message.destination_id),
            protobuf.serializeRequiredString(4, message.namespace),
            protobuf.serializeRequiredEnum(5, message.payload_type),
            protobuf.serializeOptionalString(6, message.payload_utf8),
            protobuf.serializeOptionalBuffer(7, message.payload_binary),
        ]);
    }
    exports.serializeCastMessage = serializeCastMessage;
    ;
});
define("build/mdns/index", ["require", "exports", "dgram", "build/is"], function (require, exports, libdgram, is) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.observe = exports.sendDiscoveryPacket = void 0;
    const MDNS_ADDRESS = "224.0.0.251";
    const MDNS_PORT = 5353;
    let map = new Map();
    function parseName(buffer, offset) {
        let labels = new Array();
        while (true) {
            let length = buffer.readUInt8(offset);
            if (length === 0) {
                offset += 1;
                break;
            }
            if (length < 192) {
                offset += 1;
                let label = buffer.slice(offset, offset + length);
                offset += length;
                labels.push(label.toString());
                continue;
            }
            let name = parseName(buffer, buffer.readUInt16BE(offset) & 0x3FFF);
            labels.push(name.labels.join("."));
            offset += 2;
            break;
        }
        return {
            labels: labels,
            offset: offset
        };
    }
    ;
    var Type;
    (function (Type) {
        Type[Type["A"] = 1] = "A";
        Type[Type["PTR"] = 12] = "PTR";
        Type[Type["TXT"] = 16] = "TXT";
        Type[Type["SRV"] = 33] = "SRV";
    })(Type || (Type = {}));
    ;
    async function parseQuestion(packet, offset) {
        let name = await parseName(packet, offset);
        offset = name.offset;
        let type = packet.readUInt16BE(offset);
        offset += 2;
        let kind = packet.readUInt16BE(offset);
        offset += 2;
        return {
            value: name.labels.join("."),
            type,
            kind,
            offset
        };
    }
    ;
    function parseA(answer) {
        let buffer = answer.packet;
        let data_offset = answer.data_offset;
        let a = buffer.readUInt8(data_offset);
        data_offset += 1;
        let b = buffer.readUInt8(data_offset);
        data_offset += 1;
        let c = buffer.readUInt8(data_offset);
        data_offset += 1;
        let d = buffer.readUInt8(data_offset);
        data_offset += 1;
        let ipv4 = `${a}.${b}.${c}.${d}`;
        return {
            ipv4
        };
    }
    function parsePTR(answer) {
        let buffer = answer.packet;
        let data_offset = answer.data_offset;
        let to = parseName(buffer, data_offset);
        data_offset = to.offset;
        return {
            to: to.labels.join(".")
        };
    }
    function parseTXT(answer) {
        let buffer = answer.packet;
        let data_offset = answer.data_offset;
        let content = parseName(buffer, data_offset);
        return {
            content: content.labels
        };
    }
    function parseSRV(answer) {
        let buffer = answer.packet;
        let data_offset = answer.data_offset;
        let priority = buffer.readUInt16BE(data_offset);
        data_offset += 2;
        let weight = buffer.readUInt16BE(data_offset);
        data_offset += 2;
        let port = buffer.readUInt16BE(data_offset);
        data_offset += 2;
        let to = parseName(buffer, data_offset);
        data_offset = to.offset;
        return {
            priority,
            weight,
            port,
            to: to.labels.join(".")
        };
    }
    function parseAnswer(packet, offset) {
        let name = parseName(packet, offset);
        offset = name.offset;
        let type = packet.readUInt16BE(offset);
        offset += 2;
        let kind = packet.readUInt16BE(offset);
        offset += 2;
        let ttl = packet.readUInt32BE(offset);
        offset += 4;
        let data_length = packet.readUInt16BE(offset);
        offset += 2;
        let data_offset = offset;
        if (data_offset + data_length > packet.length) {
            throw `Invalid buffer length!`;
        }
        offset += data_length;
        return {
            name: name.labels.join("."),
            type,
            kind,
            ttl,
            packet,
            data_offset,
            data_length
        };
    }
    ;
    async function parsePacket(buffer) {
        let offset = 0;
        let header = buffer.slice(offset, offset + 12);
        offset += 12;
        let id = header.readUInt16BE(0);
        let flags = header.readUInt16BE(2);
        let qdcount = header.readUInt16BE(4);
        let ancount = header.readUInt16BE(6);
        let nscount = header.readUInt16BE(8);
        let arcount = header.readUInt16BE(10);
        let questions = new Array();
        for (let i = 0; i < qdcount; i++) {
            let result = await parseQuestion(buffer, offset);
            questions.push(result);
            offset = result.offset;
        }
        let answers = new Array();
        for (let i = 0; i < ancount; i++) {
            let result = await parseAnswer(buffer, offset);
            answers.push(result);
            offset = result.data_offset + result.data_length;
        }
        let authorities = new Array();
        for (let i = 0; i < nscount; i++) {
            let result = await parseAnswer(buffer, offset);
            authorities.push(result);
            offset = result.data_offset + result.data_length;
        }
        let additionals = new Array();
        for (let i = 0; i < arcount; i++) {
            let result = await parseAnswer(buffer, offset);
            additionals.push(result);
            offset = result.data_offset + result.data_length;
        }
        return {
            buffer,
            questions,
            answers,
            authorities,
            additionals
        };
    }
    ;
    function lookupDevice(device, packet) {
        for (let answer of [...packet.answers, ...packet.authorities, ...packet.additionals]) {
            if (answer.name === device.hostname) {
                if (answer.type === Type.TXT) {
                    try {
                        let record = parseTXT(answer);
                        device = {
                            ...device,
                            service_info: record.content
                        };
                    }
                    catch (error) { }
                }
            }
        }
        for (let answer of [...packet.answers, ...packet.authorities, ...packet.additionals]) {
            if (answer.name === device.hostname) {
                if (answer.type === Type.A) {
                    let record = parseA(answer);
                    device = {
                        ...device,
                        hostname: record.ipv4
                    };
                    return device;
                }
                else if (answer.type === Type.PTR) {
                    let record = parsePTR(answer);
                    device = {
                        ...device,
                        hostname: record.to
                    };
                    return lookupDevice(device, packet);
                }
                else if (answer.type === Type.SRV) {
                    let record = parseSRV(answer);
                    device = {
                        ...device,
                        hostname: record.to
                    };
                    return lookupDevice(device, packet);
                }
            }
        }
    }
    function notifyObservers(packet) {
        for (let answer of packet.answers) {
            let hostname = answer.name;
            let observers = map.get(hostname);
            if (is.present(observers)) {
                let device = lookupDevice({ hostname }, packet);
                if (is.present(device)) {
                    for (let observer of observers) {
                        observer(device);
                    }
                }
            }
        }
    }
    ;
    const socket = libdgram.createSocket({ type: "udp4", reuseAddr: true });
    socket.on("listening", () => {
        socket.setMulticastLoopback(false);
        socket.addMembership(MDNS_ADDRESS, "0.0.0.0");
    });
    socket.on("message", async (buffer) => {
        try {
            let packet = await parsePacket(buffer);
            notifyObservers(packet);
        }
        catch (error) {
            console.log(`Expected a valid DNS packet!`);
            console.log(error);
        }
    });
    socket.bind(MDNS_PORT);
    // TODO: Encode labels properly.
    function sendDiscoveryPacket(host) {
        let buffers = Array();
        let head = Buffer.alloc(12);
        head.writeUInt16BE(1, 4);
        buffers.push(head);
        for (let label of host.split(".")) {
            if (label.length >= 64) {
                throw `Expected a label with a length less than 64!`;
            }
            let buffer = Buffer.alloc(1 + label.length);
            buffer.writeUInt8(label.length, 0);
            buffer.write(label, 1);
            buffers.push(buffer);
        }
        let tail = Buffer.alloc(5);
        tail.writeUInt8(0, 0);
        tail.writeUInt16BE(12, 1);
        tail.writeUInt16BE(1, 3);
        buffers.push(tail);
        socket.send(Buffer.concat(buffers), MDNS_PORT, MDNS_ADDRESS);
    }
    exports.sendDiscoveryPacket = sendDiscoveryPacket;
    ;
    ;
    function observe(host, observer) {
        let observers = map.get(host);
        if (is.absent(observers)) {
            observers = new Set();
            map.set(host, observers);
        }
        observers.add(observer);
        sendDiscoveryPacket(host);
        return {
            cancel() {
                let observers = map.get(host);
                if (is.present(observers)) {
                    observers.delete(observer);
                    if (observers.size === 0) {
                        map.delete(host);
                    }
                }
            }
        };
    }
    exports.observe = observe;
    ;
});
define("build/chromecast/schema/connection", ["require", "exports", "node_modules/@joelek/ts-autoguard/build/autoguard-lib/index"], function (require, exports, ts_autoguard_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.CLOSE = exports.CONNECT = void 0;
    exports.CONNECT = ts_autoguard_1.guards.Object.of({
        "type": ts_autoguard_1.guards.StringLiteral.of("CONNECT")
    });
    exports.CLOSE = ts_autoguard_1.guards.Object.of({
        "type": ts_autoguard_1.guards.StringLiteral.of("CLOSE")
    });
    exports.Autoguard = {
        "CONNECT": exports.CONNECT,
        "CLOSE": exports.CLOSE
    };
});
define("build/chromecast/schema/heartbeat", ["require", "exports", "node_modules/@joelek/ts-autoguard/build/autoguard-lib/index"], function (require, exports, ts_autoguard_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.PONG = exports.PING = void 0;
    exports.PING = ts_autoguard_1.guards.Object.of({
        "type": ts_autoguard_1.guards.StringLiteral.of("PING")
    });
    exports.PONG = ts_autoguard_1.guards.Object.of({
        "type": ts_autoguard_1.guards.StringLiteral.of("PONG")
    });
    exports.Autoguard = {
        "PING": exports.PING,
        "PONG": exports.PONG
    };
});
define("build/chromecast/schema/objects", ["require", "exports", "node_modules/@joelek/ts-autoguard/build/autoguard-lib/index"], function (require, exports, ts_autoguard_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.MediaStatus = exports.PhotoMediaMetadata = exports.MusicTrackMediaMetadata = exports.TvShowMediaMetadata = exports.MovieMediaMetadata = exports.GenericMediaMetadata = exports.MediaInformation = exports.Volume = exports.Image = void 0;
    exports.Image = ts_autoguard_1.guards.Object.of({
        "url": ts_autoguard_1.guards.String,
        "height": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.Number),
        "width": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.Number)
    });
    exports.Volume = ts_autoguard_1.guards.Object.of({
        "level": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.Number),
        "muted": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.Boolean)
    });
    exports.MediaInformation = ts_autoguard_1.guards.Object.of({
        "contentId": ts_autoguard_1.guards.String,
        "streamType": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.StringLiteral.of("NONE"), ts_autoguard_1.guards.StringLiteral.of("BUFFERED"), ts_autoguard_1.guards.StringLiteral.of("LIVE")),
        "contentType": ts_autoguard_1.guards.String,
        "metadata": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Reference.of(() => exports.GenericMediaMetadata), ts_autoguard_1.guards.Reference.of(() => exports.MovieMediaMetadata), ts_autoguard_1.guards.Reference.of(() => exports.TvShowMediaMetadata), ts_autoguard_1.guards.Reference.of(() => exports.MusicTrackMediaMetadata), ts_autoguard_1.guards.Reference.of(() => exports.PhotoMediaMetadata))),
        "duration": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.Number),
        "customData": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.Record.of(ts_autoguard_1.guards.Any)),
        "tracks": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.Array.of(ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Object.of({
            "trackId": ts_autoguard_1.guards.Number,
            "type": ts_autoguard_1.guards.String
        }), ts_autoguard_1.guards.Object.of({
            "trackId": ts_autoguard_1.guards.Number,
            "type": ts_autoguard_1.guards.StringLiteral.of("TEXT"),
            "trackType": ts_autoguard_1.guards.StringLiteral.of("TEXT"),
            "trackContentId": ts_autoguard_1.guards.String,
            "trackContentType": ts_autoguard_1.guards.String,
            "subtype": ts_autoguard_1.guards.StringLiteral.of("SUBTITLES"),
            "language": ts_autoguard_1.guards.String,
            "name": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.String),
            "customData": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.Record.of(ts_autoguard_1.guards.Any))
        }))))
    });
    exports.GenericMediaMetadata = ts_autoguard_1.guards.Object.of({
        "metadataType": ts_autoguard_1.guards.NumberLiteral.of(0),
        "title": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.String),
        "subtitle": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.String),
        "images": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.Array.of(ts_autoguard_1.guards.Reference.of(() => exports.Image))),
        "releaseDate": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.String)
    });
    exports.MovieMediaMetadata = ts_autoguard_1.guards.Object.of({
        "metadataType": ts_autoguard_1.guards.NumberLiteral.of(1),
        "title": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.String),
        "subtitle": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.String),
        "studio": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.String),
        "images": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.Array.of(ts_autoguard_1.guards.Reference.of(() => exports.Image))),
        "releaseDate": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.String)
    });
    exports.TvShowMediaMetadata = ts_autoguard_1.guards.Object.of({
        "metadataType": ts_autoguard_1.guards.NumberLiteral.of(2),
        "seriesTitle": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.String),
        "subtitle": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.String),
        "season": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.Number),
        "episode": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.Number),
        "images": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.Array.of(ts_autoguard_1.guards.Reference.of(() => exports.Image))),
        "originalAirDate": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.String)
    });
    exports.MusicTrackMediaMetadata = ts_autoguard_1.guards.Object.of({
        "metadataType": ts_autoguard_1.guards.NumberLiteral.of(3),
        "albumName": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.String),
        "title": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.String),
        "albumArtist": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.String),
        "artist": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.String),
        "composer": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.String),
        "trackNumber": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.Number),
        "discNumber": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.Number),
        "images": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.Array.of(ts_autoguard_1.guards.Reference.of(() => exports.Image))),
        "releaseDate": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.String)
    });
    exports.PhotoMediaMetadata = ts_autoguard_1.guards.Object.of({
        "metadataType": ts_autoguard_1.guards.NumberLiteral.of(4),
        "title": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.String),
        "artist": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.String),
        "location": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.String),
        "latitude": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.Number),
        "longitude": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.Number),
        "width": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.Number),
        "height": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.Number),
        "creationDateTime": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.String)
    });
    exports.MediaStatus = ts_autoguard_1.guards.Object.of({
        "mediaSessionId": ts_autoguard_1.guards.Number,
        "media": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Reference.of(() => exports.MediaInformation), ts_autoguard_1.guards.Object.of({}))),
        "playbackRate": ts_autoguard_1.guards.Number,
        "playerState": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.StringLiteral.of("IDLE"), ts_autoguard_1.guards.StringLiteral.of("PLAYING"), ts_autoguard_1.guards.StringLiteral.of("BUFFERING"), ts_autoguard_1.guards.StringLiteral.of("PAUSED")),
        "idleReason": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.StringLiteral.of("CANCELLED"), ts_autoguard_1.guards.StringLiteral.of("INTERRUPTED"), ts_autoguard_1.guards.StringLiteral.of("FINISHED"), ts_autoguard_1.guards.StringLiteral.of("ERROR"))),
        "currentTime": ts_autoguard_1.guards.Number,
        "supportedMediaCommands": ts_autoguard_1.guards.Number,
        "volume": ts_autoguard_1.guards.Reference.of(() => exports.Volume),
        "customData": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.Record.of(ts_autoguard_1.guards.Any))
    });
    exports.Autoguard = {
        "Image": exports.Image,
        "Volume": exports.Volume,
        "MediaInformation": exports.MediaInformation,
        "GenericMediaMetadata": exports.GenericMediaMetadata,
        "MovieMediaMetadata": exports.MovieMediaMetadata,
        "TvShowMediaMetadata": exports.TvShowMediaMetadata,
        "MusicTrackMediaMetadata": exports.MusicTrackMediaMetadata,
        "PhotoMediaMetadata": exports.PhotoMediaMetadata,
        "MediaStatus": exports.MediaStatus
    };
});
define("build/chromecast/schema/media", ["require", "exports", "build/chromecast/schema/objects", "build/chromecast/schema/objects", "build/chromecast/schema/objects", "node_modules/@joelek/ts-autoguard/build/autoguard-lib/index"], function (require, exports, objects_1, objects_2, objects_3, ts_autoguard_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.MEDIA_STATUS = exports.INVALID_REQUEST = exports.LOAD_CANCELLED = exports.LOAD_FAILED = exports.INVALID_PLAYER_STATE = exports.VOLUME = exports.GET_STATUS = exports.PLAY = exports.STOP = exports.SEEK = exports.PAUSE = exports.LOAD = void 0;
    exports.LOAD = ts_autoguard_1.guards.Object.of({
        "requestId": ts_autoguard_1.guards.Number,
        "type": ts_autoguard_1.guards.StringLiteral.of("LOAD"),
        "media": ts_autoguard_1.guards.Reference.of(() => objects_1.MediaInformation),
        "autoplay": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.Boolean),
        "currentTime": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.Number),
        "customData": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.Record.of(ts_autoguard_1.guards.Any)),
        "activeTrackIds": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.Array.of(ts_autoguard_1.guards.Number))
    });
    exports.PAUSE = ts_autoguard_1.guards.Object.of({
        "mediaSessionId": ts_autoguard_1.guards.Number,
        "requestId": ts_autoguard_1.guards.Number,
        "type": ts_autoguard_1.guards.StringLiteral.of("PAUSE"),
        "customData": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.Record.of(ts_autoguard_1.guards.Any))
    });
    exports.SEEK = ts_autoguard_1.guards.Object.of({
        "mediaSessionId": ts_autoguard_1.guards.Number,
        "requestId": ts_autoguard_1.guards.Number,
        "type": ts_autoguard_1.guards.StringLiteral.of("SEEK"),
        "resumeState": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.StringLiteral.of("PLAYBACK_START"), ts_autoguard_1.guards.StringLiteral.of("PLAYBACK_PAUSE"))),
        "currentTime": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.Number),
        "customData": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.Record.of(ts_autoguard_1.guards.Any))
    });
    exports.STOP = ts_autoguard_1.guards.Object.of({
        "mediaSessionId": ts_autoguard_1.guards.Number,
        "requestId": ts_autoguard_1.guards.Number,
        "type": ts_autoguard_1.guards.StringLiteral.of("STOP"),
        "customData": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.Record.of(ts_autoguard_1.guards.Any))
    });
    exports.PLAY = ts_autoguard_1.guards.Object.of({
        "mediaSessionId": ts_autoguard_1.guards.Number,
        "requestId": ts_autoguard_1.guards.Number,
        "type": ts_autoguard_1.guards.StringLiteral.of("PLAY"),
        "customData": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.Record.of(ts_autoguard_1.guards.Any))
    });
    exports.GET_STATUS = ts_autoguard_1.guards.Object.of({
        "mediaSessionId": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.Number),
        "requestId": ts_autoguard_1.guards.Number,
        "type": ts_autoguard_1.guards.StringLiteral.of("GET_STATUS"),
        "customData": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.Record.of(ts_autoguard_1.guards.Any))
    });
    exports.VOLUME = ts_autoguard_1.guards.Object.of({
        "mediaSessionId": ts_autoguard_1.guards.Number,
        "requestId": ts_autoguard_1.guards.Number,
        "type": ts_autoguard_1.guards.StringLiteral.of("VOLUME"),
        "volume": ts_autoguard_1.guards.Reference.of(() => objects_3.Volume),
        "customData": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.Record.of(ts_autoguard_1.guards.Any))
    });
    exports.INVALID_PLAYER_STATE = ts_autoguard_1.guards.Object.of({
        "requestId": ts_autoguard_1.guards.Number,
        "type": ts_autoguard_1.guards.StringLiteral.of("INVALID_PLAYER_STATE"),
        "customData": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.Record.of(ts_autoguard_1.guards.Any))
    });
    exports.LOAD_FAILED = ts_autoguard_1.guards.Object.of({
        "requestId": ts_autoguard_1.guards.Number,
        "type": ts_autoguard_1.guards.StringLiteral.of("LOAD_FAILED"),
        "customData": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.Record.of(ts_autoguard_1.guards.Any))
    });
    exports.LOAD_CANCELLED = ts_autoguard_1.guards.Object.of({
        "requestId": ts_autoguard_1.guards.Number,
        "type": ts_autoguard_1.guards.StringLiteral.of("LOAD_CANCELLED"),
        "customData": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.Record.of(ts_autoguard_1.guards.Any))
    });
    exports.INVALID_REQUEST = ts_autoguard_1.guards.Object.of({
        "requestId": ts_autoguard_1.guards.Number,
        "type": ts_autoguard_1.guards.StringLiteral.of("INVALID_REQUEST"),
        "reason": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.StringLiteral.of("INVALID_COMMAND"), ts_autoguard_1.guards.StringLiteral.of("DUPLICATE_REQUESTID")),
        "customData": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.Record.of(ts_autoguard_1.guards.Any))
    });
    exports.MEDIA_STATUS = ts_autoguard_1.guards.Object.of({
        "requestId": ts_autoguard_1.guards.Number,
        "type": ts_autoguard_1.guards.StringLiteral.of("MEDIA_STATUS"),
        "status": ts_autoguard_1.guards.Array.of(ts_autoguard_1.guards.Reference.of(() => objects_2.MediaStatus)),
        "customData": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.Record.of(ts_autoguard_1.guards.Any))
    });
    exports.Autoguard = {
        "LOAD": exports.LOAD,
        "PAUSE": exports.PAUSE,
        "SEEK": exports.SEEK,
        "STOP": exports.STOP,
        "PLAY": exports.PLAY,
        "GET_STATUS": exports.GET_STATUS,
        "VOLUME": exports.VOLUME,
        "INVALID_PLAYER_STATE": exports.INVALID_PLAYER_STATE,
        "LOAD_FAILED": exports.LOAD_FAILED,
        "LOAD_CANCELLED": exports.LOAD_CANCELLED,
        "INVALID_REQUEST": exports.INVALID_REQUEST,
        "MEDIA_STATUS": exports.MEDIA_STATUS
    };
});
define("build/chromecast/schema/receiver", ["require", "exports", "node_modules/@joelek/ts-autoguard/build/autoguard-lib/index"], function (require, exports, ts_autoguard_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.RECEIVER_STATUS = exports.SET_VOLUME = exports.GET_APP_AVAILABILITY = exports.GET_STATUS = exports.STOP = exports.LAUNCH = void 0;
    exports.LAUNCH = ts_autoguard_1.guards.Object.of({
        "type": ts_autoguard_1.guards.StringLiteral.of("LAUNCH"),
        "requestId": ts_autoguard_1.guards.Number,
        "appId": ts_autoguard_1.guards.String
    });
    exports.STOP = ts_autoguard_1.guards.Object.of({
        "type": ts_autoguard_1.guards.StringLiteral.of("STOP"),
        "requestId": ts_autoguard_1.guards.Number,
        "sessionId": ts_autoguard_1.guards.String
    });
    exports.GET_STATUS = ts_autoguard_1.guards.Object.of({
        "type": ts_autoguard_1.guards.StringLiteral.of("GET_STATUS"),
        "requestId": ts_autoguard_1.guards.Number
    });
    exports.GET_APP_AVAILABILITY = ts_autoguard_1.guards.Object.of({
        "type": ts_autoguard_1.guards.StringLiteral.of("GET_APP_AVAILABILITY"),
        "requestId": ts_autoguard_1.guards.Number,
        "appId": ts_autoguard_1.guards.Array.of(ts_autoguard_1.guards.String)
    });
    exports.SET_VOLUME = ts_autoguard_1.guards.Object.of({
        "type": ts_autoguard_1.guards.StringLiteral.of("SET_VOLUME"),
        "requestId": ts_autoguard_1.guards.Number,
        "volume": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Object.of({
            "level": ts_autoguard_1.guards.Number
        }), ts_autoguard_1.guards.Object.of({
            "muted": ts_autoguard_1.guards.Boolean
        }))
    });
    exports.RECEIVER_STATUS = ts_autoguard_1.guards.Object.of({
        "type": ts_autoguard_1.guards.StringLiteral.of("RECEIVER_STATUS"),
        "requestId": ts_autoguard_1.guards.Number,
        "status": ts_autoguard_1.guards.Object.of({
            "applications": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.Array.of(ts_autoguard_1.guards.Object.of({
                "appId": ts_autoguard_1.guards.String,
                "displayName": ts_autoguard_1.guards.String,
                "iconUrl": ts_autoguard_1.guards.String,
                "isIdleScreen": ts_autoguard_1.guards.Boolean,
                "launchedFromCloud": ts_autoguard_1.guards.Boolean,
                "namespaces": ts_autoguard_1.guards.Array.of(ts_autoguard_1.guards.Object.of({
                    "name": ts_autoguard_1.guards.String
                })),
                "sessionId": ts_autoguard_1.guards.String,
                "statusText": ts_autoguard_1.guards.String,
                "transportId": ts_autoguard_1.guards.String
            }))),
            "userEq": ts_autoguard_1.guards.Object.of({}),
            "volume": ts_autoguard_1.guards.Object.of({
                "controlType": ts_autoguard_1.guards.String,
                "level": ts_autoguard_1.guards.Number,
                "muted": ts_autoguard_1.guards.Boolean,
                "stepInterval": ts_autoguard_1.guards.Number
            })
        })
    });
    exports.Autoguard = {
        "LAUNCH": exports.LAUNCH,
        "STOP": exports.STOP,
        "GET_STATUS": exports.GET_STATUS,
        "GET_APP_AVAILABILITY": exports.GET_APP_AVAILABILITY,
        "SET_VOLUME": exports.SET_VOLUME,
        "RECEIVER_STATUS": exports.RECEIVER_STATUS
    };
});
define("build/chromecast/schema/index", ["require", "exports", "build/chromecast/schema/connection", "build/chromecast/schema/heartbeat", "build/chromecast/schema/media", "build/chromecast/schema/objects", "build/chromecast/schema/receiver"], function (require, exports, connection, heartbeat, media, objects, receiver) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.receiver = exports.objects = exports.media = exports.heartbeat = exports.connection = void 0;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.receiver = exports.objects = exports.media = exports.heartbeat = exports.connection = void 0;
    exports.connection = connection;
    exports.heartbeat = heartbeat;
    exports.media = media;
    exports.objects = objects;
    exports.receiver = receiver;
});
define("build/languages", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pref = exports.db = void 0;
    const db = {
        eng: {
            title: "English",
            iso639_1: "en",
            iso3166_1: "US"
        },
        swe: {
            title: "Swedish",
            iso639_1: "sv",
            iso3166_1: "SE"
        },
        jpn: {
            title: "Japanese",
            iso639_1: "ja",
            iso3166_1: "JP"
        }
    };
    exports.db = db;
    const pref = [
        "swe",
        "eng",
        "jpn"
    ];
    exports.pref = pref;
});
define("build/chromecast/chromecasts", ["require", "exports", "tls", "build/chromecast/cast_message", "build/mdns/index", "build/chromecast/schema/index", "build/is", "build/languages", "build/observers/index", "build/player/client", "node_modules/@joelek/ts-autoguard/build/autoguard-lib/index", "node_modules/@joelek/ts-sockets/build/index", "node_modules/@joelek/ts-stdlib/build/index", "build/api/schema/objects"], function (require, exports, libtls, cast_message, mdns, schema, is, languages, observers, libcontext, autoguard, sockets, stdlib, objects_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.discover = exports.observe = void 0;
    const DEBUG = false;
    function getLanguage(language) {
        let entry = languages.db[language ?? "eng"] ?? languages.db["eng"];
        return {
            language: [
                entry.iso639_1,
                entry.iso3166_1
            ].join("-"),
            name: entry.title
        };
    }
    function makeMediaInformation(item, media_server_host, token) {
        if (objects_1.Episode.is(item)) {
            let episode = item;
            let season = episode.season;
            let show = season.show;
            return {
                contentId: `${media_server_host}/files/${item.media.file_id}/?token=${token}`,
                contentType: episode.media.mime,
                streamType: "BUFFERED",
                metadata: {
                    metadataType: 0,
                    title: episode.title,
                    subtitle: show.title
                },
                tracks: episode.subtitles.map((subtitle, subtitleIndex) => ({
                    ...getLanguage(subtitle.language),
                    trackId: subtitleIndex,
                    type: "TEXT",
                    trackType: "TEXT",
                    trackContentId: `${media_server_host}/files/${subtitle.file_id}/?token=${token}`,
                    trackContentType: subtitle.mime,
                    subtype: "SUBTITLES"
                }))
            };
        }
        else if (objects_1.Movie.is(item)) {
            let movie = item;
            return {
                contentId: `${media_server_host}/files/${item.media.file_id}/?token=${token}`,
                contentType: movie.media.mime,
                streamType: "BUFFERED",
                metadata: {
                    metadataType: 0,
                    title: movie.title,
                    images: movie.artwork.map((image) => ({
                        url: `${media_server_host}/files/${image.file_id}/?token=${token}`
                    }))
                },
                tracks: movie.subtitles.map((subtitle, subtitleIndex) => ({
                    ...getLanguage(subtitle.language),
                    trackId: subtitleIndex,
                    type: "TEXT",
                    trackType: "TEXT",
                    trackContentId: `${media_server_host}/files/${subtitle.file_id}/?token=${token}`,
                    trackContentType: subtitle.mime,
                    subtype: "SUBTITLES"
                }))
            };
        }
        else if (objects_1.Track.is(item)) {
            let track = item;
            let disc = track.disc;
            let album = disc.album;
            return {
                contentId: `${media_server_host}/files/${item.media.file_id}/?token=${token}`,
                contentType: item.media.mime,
                streamType: "BUFFERED",
                metadata: {
                    metadataType: 0,
                    title: track.title,
                    subtitle: track.artists.map((artist) => artist.title).join(" \u00b7 "),
                    images: album.artwork.map((image) => ({
                        url: `${media_server_host}/files/${image.file_id}/?token=${token}`
                    }))
                }
            };
        }
        else {
            throw `Expected code to be unreachable!`;
        }
    }
    function getDeviceName(service_info) {
        for (let entry of service_info) {
            let parts = entry.split("=");
            if (parts.length >= 2) {
                let key = parts[0];
                if (key === "fn") {
                    return parts.slice(1).join("=");
                }
            }
        }
        return "Chromecast";
    }
    function getDeviceType(service_info) {
        for (let entry of service_info) {
            let parts = entry.split("=");
            if (parts.length >= 2) {
                let key = parts[0];
                if (key === "md") {
                    return parts.slice(1).join("=");
                }
            }
        }
        return "Generic Cast Device";
    }
    const connections = new Map();
    function observe(wss, media_server_host) {
        mdns.observe("_googlecast._tcp.local", async (service_device) => {
            try {
                let { hostname, service_info } = { ...service_device };
                let connection = connections.get(hostname);
                if (is.absent(connection)) {
                    let socket = libtls.connect({
                        host: hostname,
                        port: 8009,
                        rejectUnauthorized: false
                    });
                    connections.set(hostname, socket);
                    socket.on("secureConnect", () => {
                        console.log(`Connected to Cast device at ${hostname}.`);
                        let deviceName = getDeviceName(service_info ?? []);
                        let deviceType = getDeviceType(service_info ?? []);
                        new ChromecastPlayer(socket, wss, media_server_host, deviceName, deviceType);
                    });
                    socket.on("close", () => {
                        console.log(`Disconnected from Cast device at ${hostname}.`);
                        connections.delete(hostname);
                    });
                    socket.on("error", (error) => {
                        socket.destroy();
                    });
                }
            }
            catch (error) {
                console.log(error);
            }
        });
    }
    exports.observe = observe;
    ;
    function discover() {
        mdns.sendDiscoveryPacket("_googlecast._tcp.local");
    }
    exports.discover = discover;
    ;
    function unwrapPacketPayload(socket, onpayload) {
        let buffered = Buffer.alloc(0);
        let waiting_header = true;
        let bytes_required = 4;
        socket.on("data", (chunk) => {
            buffered = Buffer.concat([buffered, chunk]);
            while (buffered.length >= bytes_required) {
                let buffer = buffered.slice(0, bytes_required);
                buffered = buffered.slice(bytes_required);
                if (waiting_header) {
                    waiting_header = false;
                    bytes_required = buffer.readUInt32BE(0);
                }
                else {
                    waiting_header = true;
                    bytes_required = 4;
                    onpayload(buffer);
                }
            }
        });
    }
    class MessageHandler {
        constructor(socket, onmessage) {
            this.socket = socket;
            unwrapPacketPayload(socket, (payload) => {
                try {
                    let message = cast_message.parseCastMessage(payload);
                    if (DEBUG && message.namespace !== HearbeatHandler.NAMESPACE) {
                        console.log("incoming", message);
                    }
                    onmessage(message);
                }
                catch (error) {
                    console.log(error);
                }
            });
        }
        getRequestId() {
            return Math.floor(Math.random() * 65536);
        }
        send(message) {
            if (DEBUG && message.namespace !== HearbeatHandler.NAMESPACE) {
                console.log("outgoing", message);
            }
            let buffer = cast_message.serializeCastMessage({
                protocol_version: message.protocol_version ?? cast_message.ProtocolVersion.CASTV2_1_0,
                source_id: message.source_id ?? "sender-0",
                destination_id: message.destination_id ?? "receiver-0",
                namespace: message.namespace,
                payload_type: message.payload_type ?? cast_message.PayloadType.STRING,
                payload_utf8: message.payload_utf8,
                payload_binary: message.payload_binary
            });
            let header = Buffer.alloc(4);
            header.writeUInt32BE(buffer.length, 0);
            this.socket.write(header);
            this.socket.write(buffer);
        }
    }
    class ConnectionHandler {
        constructor(messageHandler) {
            this.messageHandler = messageHandler;
            this.serializer = new autoguard.serialization.MessageSerializer(schema.connection.Autoguard);
            this.listeners = new stdlib.routing.MessageRouter();
        }
        handle(message) {
            let data = JSON.parse(message.payload_utf8 ?? "{}");
            let type = autoguard.guards.String.as(data.type);
            this.serializer.deserialize(JSON.stringify({ type, data }), (type, data) => {
                this.listeners.route(type, data);
            });
        }
        send(type, data, transportId) {
            this.messageHandler.send({
                namespace: ConnectionHandler.NAMESPACE,
                destination_id: transportId,
                payload_utf8: JSON.stringify(data)
            });
        }
    }
    ConnectionHandler.NAMESPACE = "urn:x-cast:com.google.cast.tp.connection";
    class HearbeatHandler {
        constructor(messageHandler) {
            this.messageHandler = messageHandler;
            this.serializer = new autoguard.serialization.MessageSerializer(schema.heartbeat.Autoguard);
            this.listeners = new stdlib.routing.MessageRouter();
        }
        handle(message) {
            let data = JSON.parse(message.payload_utf8 ?? "{}");
            let type = autoguard.guards.String.as(data.type);
            this.serializer.deserialize(JSON.stringify({ type, data }), (type, data) => {
                this.listeners.route(type, data);
            });
        }
        send(type, data) {
            this.messageHandler.send({
                namespace: HearbeatHandler.NAMESPACE,
                payload_utf8: JSON.stringify(data)
            });
        }
    }
    HearbeatHandler.NAMESPACE = "urn:x-cast:com.google.cast.tp.heartbeat";
    class MediaHandler {
        constructor(messageHandler) {
            this.transportId = new observers.ObservableClass(undefined);
            this.mediaSessionId = new observers.ObservableClass(undefined);
            this.messageHandler = messageHandler;
            this.serializer = new autoguard.serialization.MessageSerializer(schema.media.Autoguard);
            this.callbacks = new Map();
            this.listeners = new stdlib.routing.MessageRouter();
        }
        handle(message) {
            let data = JSON.parse(message.payload_utf8 ?? "{}");
            let type = autoguard.guards.String.as(data.type);
            try {
                this.serializer.deserialize(JSON.stringify({ type, data }), (type, data) => {
                    let callback = this.callbacks.get(data.requestId);
                    if (is.present(callback)) {
                        this.callbacks.delete(data.requestId);
                        callback(data);
                    }
                    this.listeners.route(type, data);
                });
            }
            catch (error) {
                console.log(JSON.stringify(data, null, 2));
            }
        }
        send(type, data, callback) {
            data.requestId = this.messageHandler.getRequestId();
            if (is.present(callback)) {
                this.callbacks.set(data.requestId, callback);
            }
            this.messageHandler.send({
                namespace: MediaHandler.NAMESPACE,
                destination_id: this.transportId.getState(),
                payload_utf8: JSON.stringify(data)
            });
        }
    }
    MediaHandler.NAMESPACE = "urn:x-cast:com.google.cast.media";
    class ReceiverHandler {
        constructor(messageHandler) {
            this.messageHandler = messageHandler;
            this.serializer = new autoguard.serialization.MessageSerializer(schema.receiver.Autoguard);
            this.callbacks = new Map();
            this.listeners = new stdlib.routing.MessageRouter();
        }
        handle(message) {
            let data = JSON.parse(message.payload_utf8 ?? "{}");
            let type = autoguard.guards.String.as(data.type);
            this.serializer.deserialize(JSON.stringify({ type, data }), (type, data) => {
                let callback = this.callbacks.get(data.requestId);
                if (is.present(callback)) {
                    this.callbacks.delete(data.requestId);
                    callback(data);
                }
                this.listeners.route(type, data);
            });
        }
        send(type, data, callback) {
            data.requestId = this.messageHandler.getRequestId();
            if (is.present(callback)) {
                this.callbacks.set(data.requestId, callback);
            }
            this.messageHandler.send({
                namespace: ReceiverHandler.NAMESPACE,
                payload_utf8: JSON.stringify(data)
            });
        }
    }
    ReceiverHandler.NAMESPACE = "urn:x-cast:com.google.cast.receiver";
    const APPLICATION_ID = "CC1AD845";
    class ChromecastPlayer {
        constructor(socket, wss, media_server_host, device_name, device_type) {
            let messageHandler = new MessageHandler(socket, (message) => {
                let namespace = message.namespace;
                if (namespace === ConnectionHandler.NAMESPACE) {
                    this.connectionHandler.handle(message);
                }
                else if (namespace === HearbeatHandler.NAMESPACE) {
                    this.heartbeatHandler.handle(message);
                }
                else if (namespace === MediaHandler.NAMESPACE) {
                    this.mediaHandler.handle(message);
                }
                else if (namespace === ReceiverHandler.NAMESPACE) {
                    this.receiverHandler.handle(message);
                }
            });
            this.socket = socket;
            this.heartbeatHandler = new HearbeatHandler(messageHandler);
            this.connectionHandler = new ConnectionHandler(messageHandler);
            this.mediaHandler = new MediaHandler(messageHandler);
            this.receiverHandler = new ReceiverHandler(messageHandler);
            let url = `${wss ? "wss:" : "ws:"}//127.0.0.1/sockets/context/?protocol=cast&name=${encodeURIComponent(device_name)}&type=${encodeURIComponent(device_type)}`;
            this.context = new libcontext.ContextClient(url, (url) => new sockets.WebSocketClient(url));
            this.timer = undefined;
            socket.on("close", () => {
                if (is.present(this.timer)) {
                    clearTimeout(this.timer);
                }
                this.context.close();
            });
            this.connectionHandler.send("CONNECT", {
                type: "CONNECT"
            });
            this.connectionHandler.listeners.addObserver("CLOSE", (message) => {
                this.mediaHandler.transportId.updateState(undefined);
            });
            this.heartbeatHandler.listeners.addObserver("PING", (message) => {
                this.heartbeatHandler.send("PONG", {
                    "type": "PONG"
                });
            });
            this.heartbeatHandler.listeners.addObserver("PONG", (message) => {
                this.setTimer();
            });
            this.receiverHandler.listeners.addObserver("RECEIVER_STATUS", (message) => {
                let applications = message.status.applications ?? [];
                let application = applications.find((application) => {
                    return application.appId === APPLICATION_ID;
                });
                if (is.present(application)) {
                    this.mediaHandler.transportId.updateState(application.transportId);
                }
                else {
                    this.mediaHandler.transportId.updateState(undefined);
                }
            });
            this.mediaHandler.listeners.addObserver("MEDIA_STATUS", (message) => {
                let status = message.status[message.status.length - 1];
                if (is.present(status)) {
                    let mediaSessionId = this.mediaHandler.mediaSessionId.getState();
                    if (is.present(mediaSessionId)) {
                        if (status.mediaSessionId === mediaSessionId) {
                            if (this.context.isDeviceLocal.getState()) {
                                if (status.playerState === "IDLE" && status.idleReason === "FINISHED") {
                                    this.context.next();
                                }
                            }
                        }
                        else {
                            this.mediaHandler.mediaSessionId.updateState(undefined);
                        }
                    }
                }
            });
            this.setTimer();
            this.mediaHandler.transportId.addObserver((transportId) => {
                if (is.present(transportId)) {
                    this.connectionHandler.send("CONNECT", {
                        type: "CONNECT"
                    }, transportId);
                }
            });
            this.context.isDeviceLocal.addObserver((isDeviceLocal) => {
                if (isDeviceLocal) {
                    let transportId = this.mediaHandler.transportId.getState();
                    if (is.absent(transportId)) {
                        this.receiverHandler.send("LAUNCH", {
                            type: "LAUNCH",
                            requestId: -1,
                            appId: APPLICATION_ID
                        });
                    }
                }
                else {
                    let mediaSessionId = this.mediaHandler.mediaSessionId.getState();
                    if (is.present(mediaSessionId)) {
                        this.mediaHandler.send("STOP", {
                            type: "STOP",
                            requestId: -1,
                            mediaSessionId: mediaSessionId
                        });
                    }
                }
            });
            {
                let computer = () => {
                    let transportId = this.mediaHandler.transportId.getState();
                    let currentLocalEntry = this.context.currentLocalEntry.getState();
                    let token = this.context.token.getState();
                    if (is.present(transportId) && is.present(currentLocalEntry) && is.present(token)) {
                        let media = makeMediaInformation(currentLocalEntry, media_server_host, token);
                        let activeTrackIds;
                        if (is.present(media.tracks)) {
                            let swe = media.tracks.find((track) => {
                                return track.language === "sv-SE";
                            });
                            if (is.present(swe)) {
                                activeTrackIds = [swe.trackId];
                            }
                            else {
                                let eng = media.tracks.find((track) => {
                                    return track.language === "en-US";
                                });
                                if (is.present(eng)) {
                                    activeTrackIds = [eng.trackId];
                                }
                                else {
                                    let jpn = media.tracks.find((track) => {
                                        return track.language === "ja-JP";
                                    });
                                    if (is.present(jpn)) {
                                        activeTrackIds = [jpn.trackId];
                                    }
                                    else {
                                        if (media.tracks.length > 0) {
                                            activeTrackIds = [0];
                                        }
                                    }
                                }
                            }
                        }
                        this.mediaHandler.send("LOAD", {
                            type: "LOAD",
                            requestId: -1,
                            media: media,
                            autoplay: false,
                            activeTrackIds: activeTrackIds
                        }, (message) => {
                            if (schema.media.MEDIA_STATUS.is(message)) {
                                let status = message.status[message.status.length - 1];
                                if (is.present(status)) {
                                    this.mediaHandler.mediaSessionId.updateState(status.mediaSessionId);
                                }
                            }
                        });
                    }
                };
                this.mediaHandler.transportId.addObserver(computer);
                this.context.currentLocalEntry.addObserver(computer);
                this.context.token.addObserver(computer);
            }
            {
                // Transfer context when application is lost and device is local.
                this.mediaHandler.transportId.addObserver((transportId) => {
                    if (is.absent(transportId) && this.context.isDeviceLocal.getState()) {
                        this.context.transfer(undefined);
                    }
                });
            }
            {
                // Reset media session when application is lost.
                this.mediaHandler.transportId.addObserver((transportId) => {
                    if (is.absent(transportId)) {
                        this.mediaHandler.mediaSessionId.updateState(undefined);
                    }
                });
            }
            {
                // Handle playback changes when there is an active media session.
                let computer = () => {
                    let mediaSessionId = this.mediaHandler.mediaSessionId.getState();
                    if (is.present(mediaSessionId)) {
                        let playback = this.context.playback.getState();
                        if (playback) {
                            this.mediaHandler.send("PLAY", {
                                type: "PLAY",
                                requestId: -1,
                                mediaSessionId: mediaSessionId
                            });
                        }
                        else {
                            this.mediaHandler.send("PAUSE", {
                                type: "PAUSE",
                                requestId: -1,
                                mediaSessionId: mediaSessionId
                            });
                        }
                    }
                };
                this.mediaHandler.mediaSessionId.addObserver(computer);
                this.context.playback.addObserver(computer);
            }
            {
                // Handle progress changes when there is an active media session.
                let computer = () => {
                    let mediaSessionId = this.mediaHandler.mediaSessionId.getState();
                    if (is.present(mediaSessionId)) {
                        let progress = this.context.progress.getState() ?? 0;
                        this.mediaHandler.send("SEEK", {
                            type: "SEEK",
                            requestId: -1,
                            mediaSessionId: mediaSessionId,
                            currentTime: progress
                        });
                    }
                };
                this.mediaHandler.mediaSessionId.addObserver(computer);
                this.context.progress.addObserver(computer);
            }
        }
        setTimer() {
            if (is.present(this.timer)) {
                clearTimeout(this.timer);
                this.timer = undefined;
            }
            this.timer = setTimeout(() => {
                this.timer = undefined;
                this.heartbeatHandler.send("PING", {
                    type: "PING"
                });
                this.timer = setTimeout(() => {
                    this.socket.destroy();
                }, 5000);
            }, 5000);
        }
    }
});
define("build/airplay/schema/messages", ["require", "exports", "node_modules/@joelek/ts-autoguard/build/autoguard-lib/index"], function (require, exports, ts_autoguard_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.StoppedEvent = exports.PausedEvent = exports.PlayingEvent = exports.LoadingEvent = void 0;
    exports.LoadingEvent = ts_autoguard_1.guards.Object.of({
        "sessionID": ts_autoguard_1.guards.Number,
        "state": ts_autoguard_1.guards.StringLiteral.of("loading")
    });
    exports.PlayingEvent = ts_autoguard_1.guards.Object.of({
        "sessionID": ts_autoguard_1.guards.Number,
        "state": ts_autoguard_1.guards.StringLiteral.of("playing")
    });
    exports.PausedEvent = ts_autoguard_1.guards.Object.of({
        "sessionID": ts_autoguard_1.guards.Number,
        "state": ts_autoguard_1.guards.StringLiteral.of("paused")
    });
    exports.StoppedEvent = ts_autoguard_1.guards.Object.of({
        "sessionID": ts_autoguard_1.guards.Number,
        "state": ts_autoguard_1.guards.StringLiteral.of("stopped"),
        "reason": ts_autoguard_1.guards.String
    });
    exports.Autoguard = {
        "LoadingEvent": exports.LoadingEvent,
        "PlayingEvent": exports.PlayingEvent,
        "PausedEvent": exports.PausedEvent,
        "StoppedEvent": exports.StoppedEvent
    };
});
define("build/airplay/schema/index", ["require", "exports", "build/airplay/schema/messages"], function (require, exports, messages) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.messages = void 0;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.messages = void 0;
    exports.messages = messages;
});
define("build/airplay/api", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getServerInfo = exports.stop = exports.scrub = exports.rate = exports.play = void 0;
    function play(socket, session_id, url, progress_factor) {
        return socket.request({
            method: "POST",
            path: `/play`,
            headers: [
                { key: "Content-Type", value: "text/parameters" },
                { key: "X-Apple-Session-ID", value: session_id },
            ],
            body: Buffer.from([
                `Content-Location: ${url}`,
                `Start-Position: ${progress_factor}`,
                ``
            ].join("\n"))
        });
    }
    exports.play = play;
    ;
    function rate(socket, session_id, factor) {
        return socket.request({
            method: "POST",
            path: `/rate?value=${factor}`,
            headers: [
                { key: "X-Apple-Session-ID", value: session_id },
            ]
        });
    }
    exports.rate = rate;
    ;
    function scrub(socket, session_id, seconds) {
        return socket.request({
            method: "POST",
            path: `/scrub?position=${seconds}`,
            headers: [
                { key: "X-Apple-Session-ID", value: session_id },
            ]
        });
    }
    exports.scrub = scrub;
    ;
    function stop(socket, session_id) {
        return socket.request({
            method: "POST",
            path: `/stop`,
            headers: [
                { key: "X-Apple-Session-ID", value: session_id },
            ]
        });
    }
    exports.stop = stop;
    ;
    function getServerInfo(socket, session_id) {
        return socket.request({
            method: "GET",
            path: `/server-info`,
            headers: [
                { key: "X-Apple-Session-ID", value: session_id },
            ]
        });
    }
    exports.getServerInfo = getServerInfo;
    ;
});
define("build/airplay/http", ["require", "exports", "net", "node_modules/@joelek/ts-stdlib/build/index", "build/is"], function (require, exports, libnet, stdlib, is) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InboundSocket = exports.OutboundSocket = exports.serializeResponse = exports.parseResponse = exports.serializeRequest = exports.parseRequest = exports.serializeMessage = exports.parseMessage = void 0;
    function parseMessage(buffer) {
        let string = buffer.toString("binary");
        let lines = string.split("\r\n");
        let i = 0;
        let line = lines[i++];
        let headers = new Array();
        while (i < lines.length) {
            let line = lines[i++];
            if (line === "") {
                break;
            }
            let parts = line.split(": ");
            let key = parts[0];
            let value = parts.slice(1).join(": ");
            headers.push({
                key: Buffer.from(key, "binary").toString(),
                value: Buffer.from(value, "binary").toString()
            });
        }
        let body = Buffer.from(lines.slice(i).join("\r\n"), "binary");
        return {
            line: Buffer.from(line, "binary").toString(),
            headers,
            body
        };
    }
    exports.parseMessage = parseMessage;
    ;
    function serializeMessage(message) {
        let body = message.body ?? Buffer.alloc(0);
        let headers = [
            { key: "Content-Length", value: `${body.length}` },
            ...(message.headers ?? [])
        ];
        let head = Buffer.from([
            message.line,
            ...headers.map((header) => `${header.key}: ${header.value}`),
            ``,
            ``
        ].join("\r\n"));
        return Buffer.concat([head, body]);
    }
    exports.serializeMessage = serializeMessage;
    ;
    function parseRequest(buffer) {
        let message = parseMessage(buffer);
        let line = message.line;
        let parts = line.split(" ");
        if (parts.length !== 3) {
            throw `Expected three parts in request line!`;
        }
        return {
            method: parts[0],
            path: parts[1],
            version: parts[2],
            headers: message.headers,
            body: message.body
        };
    }
    exports.parseRequest = parseRequest;
    ;
    function serializeRequest(request) {
        return serializeMessage({
            line: `${request.method ?? "GET"} ${request.path ?? "/"} ${request.version ?? "HTTP/1.1"}`,
            headers: request.headers,
            body: request.body
        });
    }
    exports.serializeRequest = serializeRequest;
    ;
    function parseResponse(buffer) {
        let message = parseMessage(buffer);
        let line = message.line;
        let parts = line.split(" ");
        if (parts.length < 3) {
            throw `Expected at least three parts in response line!`;
        }
        if (!/^[1-9][0-9][0-9]$/.test(parts[1])) {
            throw `Expected a three-digit status!`;
        }
        return {
            version: parts[0],
            status: Number.parseInt(parts[1]),
            reason: parts.slice(2).join(" "),
            headers: message.headers,
            body: message.body
        };
    }
    exports.parseResponse = parseResponse;
    ;
    function serializeResponse(response) {
        return serializeMessage({
            line: `${response.version ?? "HTTP/1.1"} ${response.status ?? 200} ${response.reason ?? "OK"}`,
            headers: response.headers,
            body: response.body
        });
    }
    exports.serializeResponse = serializeResponse;
    ;
    class OutboundSocket extends stdlib.routing.MessageRouter {
        constructor(options) {
            super();
            let socket = libnet.createConnection(options);
            socket.on("connect", () => {
            });
            socket.on("close", () => {
                this.route("close", {});
            });
            socket.on("error", () => {
                socket.destroy();
            });
            this.socket = socket;
        }
        close() {
            this.socket.destroy();
        }
        async request(request) {
            return new Promise((resolve, reject) => {
                this.socket.write(serializeRequest(request));
                let ondata = async (buffer) => {
                    this.socket.off("data", ondata);
                    let response = parseResponse(buffer);
                    resolve(response);
                };
                this.socket.on("data", ondata);
            });
        }
    }
    exports.OutboundSocket = OutboundSocket;
    ;
    class InboundSocket extends stdlib.routing.MessageRouter {
        constructor(options, upgrade, handle) {
            super();
            let socket = libnet.createConnection(options);
            let ondata = (buffer) => {
                let response = parseResponse(buffer);
                if (response.status !== 101) {
                    return socket.emit("error", `Expected status 101!`);
                }
                let connection = response.headers.find((header) => header.key.toLowerCase() === "connection");
                if (is.absent(connection) || connection.value !== "Upgrade") {
                    return socket.emit("error", `Expected a valid connection header!`);
                }
                let upgrade = response.headers.find((header) => header.key.toLowerCase() === "upgrade");
                if (is.absent(upgrade) || upgrade.value !== "PTTH/1.0") {
                    return socket.emit("error", `Expected a valid upgrade header!`);
                }
                socket.off("data", ondata);
                socket.on("data", async (buffer) => {
                    try {
                        let request = parseRequest(buffer);
                        let response = await handle(request);
                        socket.write(serializeResponse(response));
                    }
                    catch (error) {
                        socket.emit("error", error);
                    }
                });
            };
            socket.on("data", ondata);
            socket.on("connect", () => {
                socket.write(serializeRequest({
                    ...upgrade,
                    headers: [
                        { key: "Connection", value: "Upgrade" },
                        { key: "Upgrade", value: "PTTH/1.0" },
                        ...(upgrade.headers ?? [])
                    ]
                }));
            });
            socket.on("close", () => {
                this.route("close", {});
            });
            socket.on("error", () => {
                socket.destroy();
            });
            this.socket = socket;
        }
        close() {
            this.socket.destroy();
        }
    }
    exports.InboundSocket = InboundSocket;
    ;
});
define("build/xml/index", ["require", "exports", "build/is"], function (require, exports, is) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parse = exports.XMLElement = exports.XMLAttribute = exports.XMLText = exports.XMLNode = exports.expect = exports.Tokenizer = void 0;
    const MATCHERS = {
        "WS": /^([\t\r\n ]+)/isu,
        "<": /^([<])/isu,
        ">": /^([>])/isu,
        "!": /^([!])/isu,
        "?": /^([?])/isu,
        "=": /^([=])/isu,
        "</": /^([<][/])/isu,
        "/>": /^([/][>])/isu,
        "IDENTIFIER": /^([a-z][a-z0-9_-]*)/isu,
        "STRING_LITERAL": /^("[^"]*")/isu,
        "TEXT_NODE": /^([^<>]+)[<]/isu
    };
    class Tokenizer {
        constructor(string) {
            let tokens = new Array();
            let row = 1;
            let col = 1;
            while (string.length > 0) {
                let token;
                for (let key in MATCHERS) {
                    let type = key;
                    let exec = MATCHERS[type].exec(string);
                    if (is.absent(exec)) {
                        continue;
                    }
                    if (is.absent(token) || (exec[1].length > token[1].length)) {
                        token = [type, exec[1]];
                    }
                }
                if (is.absent(token)) {
                    throw `Unrecognized token at row ${row}, col ${col}!`;
                }
                tokens.push({
                    type: token[0],
                    value: token[1],
                    row: row,
                    col: col
                });
                string = string.slice(token[1].length);
                let lines = token[1].split(/\r?\n/);
                if (lines.length > 1) {
                    row += lines.length - 1;
                    col = 1;
                }
                col += lines[lines.length - 1].length;
            }
            this.tokens = tokens.filter((token) => {
                return token.type !== "WS";
            });
            this.offset = 0;
        }
        peek() {
            return this.tokens[this.offset];
        }
        read() {
            if (this.offset >= this.tokens.length) {
                throw `Unexpectedly reached end of stream!`;
            }
            return this.tokens[this.offset++];
        }
        newContext(producer) {
            let offset = this.offset;
            try {
                return producer(() => this.read(), () => this.peek());
            }
            catch (error) {
                this.offset = offset;
                throw error;
            }
        }
    }
    exports.Tokenizer = Tokenizer;
    ;
    function expect(token, family) {
        let families = Array.isArray(family) ? family : [family];
        if (!families.includes(token.type)) {
            throw `Unexpected ${token.type} at row ${token.row}, col ${token.col}!`;
        }
        return token;
    }
    exports.expect = expect;
    ;
    class XMLNode {
        asElement() {
            throw `Expected node to be an XMLElement!`;
        }
        isElement() {
            try {
                this.asElement();
                return true;
            }
            catch (error) { }
            return false;
        }
        asText() {
            throw `Expected node to be an XMLText!`;
        }
        isText() {
            try {
                this.asText();
                return true;
            }
            catch (error) { }
            return false;
        }
    }
    exports.XMLNode = XMLNode;
    ;
    function parseNode(tokenizer) {
        try {
            return parseElement(tokenizer);
        }
        catch (error) { }
        try {
            return parseText(tokenizer);
        }
        catch (error) { }
        return tokenizer.newContext((read, peek) => {
            let token = peek();
            if (is.present(token)) {
                throw `Unexpected ${token.type} at ${token.row}, ${token.col}!`;
            }
            else {
                throw `Unexpectedly reached end of stream!`;
            }
        });
    }
    class XMLText extends XMLNode {
        constructor(value) {
            super();
            this.$value = value;
        }
        asText() {
            return this;
        }
        value() {
            return this.$value;
        }
    }
    exports.XMLText = XMLText;
    ;
    function parseText(tokenizer) {
        return tokenizer.newContext((read, peek) => {
            let value = expect(read(), ["TEXT_NODE", "IDENTIFIER"]).value;
            return new XMLText(value);
        });
    }
    class XMLAttribute {
        constructor(key, value) {
            this.$key = key;
            this.$value = value;
        }
        key() {
            return this.$key;
        }
        value() {
            return this.$value;
        }
    }
    exports.XMLAttribute = XMLAttribute;
    ;
    function parseAttribute(tokenizer) {
        return tokenizer.newContext((read, peek) => {
            let key = expect(read(), "IDENTIFIER").value;
            expect(read(), "=");
            let value = expect(read(), "STRING_LITERAL").value.slice(1, -1);
            return new XMLAttribute(key, value);
        });
    }
    class XMLArray {
        constructor(iterable) {
            this.array = Array.from(iterable);
        }
        get(index) {
            if (index < 0 || index >= this.array.length) {
                throw `Expected index ${index} to be between 0 and ${this.array.length}!`;
            }
            return this.array[index];
        }
        length() {
            return this.array.length;
        }
        [Symbol.iterator]() {
            return this.array[Symbol.iterator]();
        }
    }
    ;
    class XMLElement extends XMLNode {
        constructor(tag, attributes, children) {
            super();
            this.$tag = tag;
            this.$attributes = new XMLArray(attributes);
            this.$children = new XMLArray(children);
        }
        asElement() {
            return this;
        }
        tag(...expected) {
            let tag = this.$tag;
            if (!expected.includes(tag)) {
                throw `Expected tag to be one of [${expected.join(", ")}] but was ${tag}!`;
            }
            return tag;
        }
        attributes() {
            return this.$attributes;
        }
        children() {
            return this.$children;
        }
    }
    exports.XMLElement = XMLElement;
    ;
    function parseElement(tokenizer) {
        return tokenizer.newContext((read, peek) => {
            expect(read(), "<");
            let tag = expect(read(), "IDENTIFIER").value;
            let attributes = new Array();
            while (peek()?.type !== ">" && peek()?.type !== "/>") {
                let attribute = parseAttribute(tokenizer);
                attributes.push(attribute);
            }
            let children = new Array();
            let token = expect(read(), [">", "/>"]);
            if (token.type === ">") {
                while (peek()?.type !== "</") {
                    let child = parseNode(tokenizer);
                    children.push(child);
                }
                expect(read(), "</");
                if (expect(read(), "IDENTIFIER").value !== tag) {
                    throw ``;
                }
                expect(read(), ">");
            }
            return new XMLElement(tag, attributes, children);
        });
    }
    function parseHeader(tokenizer) {
        return tokenizer.newContext((read, peek) => {
            expect(read(), "<");
            expect(read(), "?");
            if (expect(read(), "IDENTIFIER").value !== "xml") {
                throw ``;
            }
            if (expect(read(), "IDENTIFIER").value !== "version") {
                throw ``;
            }
            expect(read(), "=");
            expect(read(), "STRING_LITERAL");
            if (expect(read(), "IDENTIFIER").value !== "encoding") {
                throw ``;
            }
            expect(read(), "=");
            expect(read(), "STRING_LITERAL");
            expect(read(), "?");
            expect(read(), ">");
        });
    }
    function parseDoctype(tokenizer) {
        return tokenizer.newContext((read, peek) => {
            expect(read(), "<");
            expect(read(), "!");
            if (expect(read(), "IDENTIFIER").value !== "DOCTYPE") {
                throw ``;
            }
            let name = expect(read(), "IDENTIFIER").value;
            let access = expect(read(), "IDENTIFIER").value;
            let type = expect(read(), "STRING_LITERAL").value;
            let url = expect(read(), "STRING_LITERAL").value;
            expect(read(), ">");
        });
    }
    function parseDocument(tokenizer) {
        return tokenizer.newContext((read, peek) => {
            let header = parseHeader(tokenizer);
            let doctype = parseDoctype(tokenizer);
            let root = parseElement(tokenizer);
            return {
                root
            };
        });
    }
    function parse(string) {
        let tokenizer = new Tokenizer(string.trim());
        return parseDocument(tokenizer);
    }
    exports.parse = parse;
});
define("build/airplay/plist", ["require", "exports", "build/xml/index"], function (require, exports, xml) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseFromString = void 0;
    function parseArray(element) {
        element.tag("array");
        let children = element.children();
        let array = [];
        for (let i = 0; i < children.length(); i += 1) {
            let value = children.get(i + 0).asElement();
            array.push(parseJSON(value));
        }
        return array;
    }
    function parseFalse(element) {
        element.tag("false");
        let children = element.children();
        if (children.length() !== 0) {
            throw `Expected exactly zero children!`;
        }
        return false;
    }
    function parseTrue(element) {
        element.tag("true");
        let children = element.children();
        if (children.length() !== 0) {
            throw `Expected exactly zero children!`;
        }
        return true;
    }
    function parseBoolean(element) {
        try {
            return parseFalse(element);
        }
        catch (error) { }
        try {
            return parseTrue(element);
        }
        catch (error) { }
        throw `Expected a boolean!`;
    }
    function parseInteger(element) {
        element.tag("integer");
        let children = element.children();
        if (children.length() !== 1) {
            throw `Expected exactly one child!`;
        }
        let text = children.get(0).asText().value();
        let number = Number.parseInt(text);
        if (Number.isNaN(number)) {
            throw `Expected an integer number!`;
        }
        return number;
    }
    function parseReal(element) {
        element.tag("real");
        let children = element.children();
        if (children.length() !== 1) {
            throw `Expected exactly one child!`;
        }
        let text = children.get(0).asText().value();
        let number = Number.parseFloat(text);
        if (Number.isNaN(number)) {
            throw `Expected a real-valued number!`;
        }
        return number;
    }
    function parseNumber(element) {
        try {
            return parseInteger(element);
        }
        catch (error) { }
        try {
            return parseReal(element);
        }
        catch (error) { }
        throw `Expected a number!`;
    }
    function parseKey(element) {
        element.tag("key");
        let children = element.children();
        if (children.length() !== 1) {
            throw `Expected exactly one child!`;
        }
        let text = children.get(0).asText().value();
        return text;
    }
    function parseObject(element) {
        element.tag("dict");
        let children = element.children();
        let object = {};
        for (let i = 0; i < children.length(); i += 2) {
            let key = children.get(i + 0).asElement();
            let value = children.get(i + 1).asElement();
            object[parseKey(key)] = parseJSON(value);
        }
        return object;
    }
    function parseString(element) {
        element.tag("string");
        let children = element.children();
        if (children.length() !== 1) {
            throw `Expected exactly one child!`;
        }
        let text = children.get(0).asText().value();
        return text;
    }
    function parseJSON(node) {
        try {
            return parseArray(node);
        }
        catch (error) { }
        try {
            return parseBoolean(node);
        }
        catch (error) { }
        try {
            return parseNumber(node);
        }
        catch (error) { }
        try {
            return parseObject(node);
        }
        catch (error) { }
        try {
            return parseString(node);
        }
        catch (error) { }
        throw `Expected a type!`;
    }
    function parseFromString(string) {
        let document = xml.parse(string);
        let root = document.root;
        root.tag("plist");
        let children = root.children();
        if (children.length() !== 1) {
            throw `Expected exactly one child!`;
        }
        return parseJSON(children.get(0).asElement());
    }
    exports.parseFromString = parseFromString;
    ;
});
define("build/airplay/device", ["require", "exports", "crypto", "node_modules/@joelek/ts-sockets/build/index", "node_modules/@joelek/ts-stdlib/build/index", "build/player/client", "build/is", "build/observers/index", "build/airplay/schema/index", "build/airplay/api", "build/airplay/http", "build/airplay/plist"], function (require, exports, libcrypto, sockets, stdlib, player, is, observers, schema, api, http, plist) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Device = void 0;
    const PORT = 7000;
    function makeCorrelationID() {
        return [
            libcrypto.randomBytes(4).toString("hex"),
            libcrypto.randomBytes(2).toString("hex"),
            libcrypto.randomBytes(2).toString("hex"),
            libcrypto.randomBytes(2).toString("hex"),
            libcrypto.randomBytes(6).toString("hex")
        ].join("-");
    }
    class Device extends stdlib.routing.MessageRouter {
        constructor(host, wss, media_server_host, device_name, device_type) {
            super();
            let correlation_id = makeCorrelationID();
            let outbound = new http.OutboundSocket({ host: host, port: PORT });
            outbound.addObserver("close", () => {
                this.route("close", {});
            });
            api.getServerInfo(outbound, correlation_id).then(() => {
                let inbound = new http.InboundSocket({ host: host, port: PORT }, {
                    method: "POST",
                    path: "/reverse",
                    headers: [
                        { key: "X-Apple-Purpose", value: "event" },
                        { key: "X-Apple-Session-ID", value: correlation_id }
                    ]
                }, async (request) => {
                    let string = request.body.toString();
                    let document = plist.parseFromString(string);
                    if (schema.messages.PlayingEvent.is(document)) {
                        context.resume();
                    }
                    else if (schema.messages.PausedEvent.is(document)) {
                        context.pause();
                    }
                    else if (schema.messages.StoppedEvent.is(document) && document.reason === "ended") {
                        context.next();
                    }
                    return {
                        status: 200,
                        reason: "OK"
                    };
                });
                inbound.addObserver("close", () => {
                    this.route("close", {});
                });
                let url = `${wss ? "wss:" : "ws:"}//127.0.0.1/sockets/context/?protocol=airplay&name=${encodeURIComponent(device_name)}&type=${encodeURIComponent(device_type)}`;
                let context = new player.ContextClient(url, (url) => new sockets.WebSocketClient(url));
                observers.computed(async (currentLocalEntry, token) => {
                    if (is.present(currentLocalEntry) && is.present(token)) {
                        let url = `${media_server_host}/files/${currentLocalEntry.media.file_id}/?token=${token}`;
                        await api.play(outbound, correlation_id, url, 0.0);
                    }
                    else {
                        await api.stop(outbound, correlation_id);
                    }
                }, context.currentLocalEntry, context.token);
                observers.computed(async (currentLocalEntry, progress) => {
                    if (is.present(currentLocalEntry) && is.present(progress)) {
                        await api.scrub(outbound, correlation_id, progress);
                    }
                }, context.currentLocalEntry, context.progress);
                observers.computed(async (playback) => {
                    await api.rate(outbound, correlation_id, playback ? 1.0 : 0.0);
                }, context.playback);
                this.addObserver("close", () => {
                    context.close();
                    outbound.close();
                    inbound.close();
                });
            });
        }
    }
    exports.Device = Device;
    ;
});
define("build/airplay/index", ["require", "exports", "build/mdns/index", "build/is", "build/airplay/device"], function (require, exports, mdns, is, device_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.discover = exports.observe = void 0;
    const devices = new Map();
    function getDeviceName(service_info) {
        let last = service_info[service_info.length - 1];
        if (is.present(last)) {
            let parts = /^([^.]+)[.]_airplay[.]_tcp[.]local$/.exec(last);
            if (is.present(parts)) {
                return parts[1];
            }
        }
        return "AirPlay";
    }
    function getDeviceType(service_info) {
        for (let entry of service_info) {
            let parts = entry.split("=");
            if (parts.length >= 2) {
                let key = parts[0];
                if (key === "model") {
                    return parts.slice(1).join("=");
                }
            }
        }
        return "Generic AirPlay Device";
    }
    function isProtocolSupported(service_info) {
        for (let entry of service_info) {
            let parts = entry.split("=");
            if (parts.length >= 2) {
                let key = parts[0];
                if (key === "protovers") {
                    return parts.slice(1).join("=") === "1.0";
                }
            }
        }
        return true;
    }
    function observe(wss, media_server_host) {
        mdns.observe("_airplay._tcp.local", async (service_device) => {
            try {
                let { hostname, service_info } = { ...service_device };
                let device = devices.get(hostname);
                if (is.absent(device) && isProtocolSupported(service_info ?? [])) {
                    let device_name = getDeviceName(service_info ?? []);
                    let device_type = getDeviceType(service_info ?? []);
                    let device = new device_1.Device(hostname, wss, media_server_host, device_name, device_type);
                    devices.set(hostname, device);
                    device.addObserver("close", function onclose() {
                        device.removeObserver("close", onclose);
                        devices.delete(hostname);
                    });
                }
            }
            catch (error) {
                console.log(error);
            }
        });
    }
    exports.observe = observe;
    ;
    function discover() {
        mdns.sendDiscoveryPacket("_airplay._tcp.local");
    }
    exports.discover = discover;
    ;
});
define("build/server/server", ["require", "exports", "crypto", "fs", "http", "https", "os", "path", "url", "build/api/api", "build/server/auth", "build/database/indexer", "build/server/subsearch", "build/player/index", "build/playlists/index", "build/chromecast/chromecasts", "build/airplay/index", "build/is", "build/config/index"], function (require, exports, libcrypto, libfs, libhttp, libhttps, libos, libpath, liburl, api, auth, indexer, subsearch, context, playlists, chromecasts, airplay, is, config_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    let send_data = (file_id, request, response) => {
        if (request.url === undefined) {
            throw new Error();
        }
        let user_id = "";
        try {
            var url = liburl.parse(request.url, true);
            user_id = auth.getUserId(url.query.token);
        }
        catch (error) {
            response.writeHead(401, {});
            return response.end();
        }
        let file = indexer.files.lookup(file_id);
        let path = indexer.getPath(file);
        let mime = "application/octet-stream";
        try {
            mime = indexer.audio_files.lookup(file.file_id).mime;
        }
        catch (error) { }
        try {
            mime = indexer.image_files.lookup(file.file_id).mime;
        }
        catch (error) { }
        try {
            mime = indexer.metadata_files.lookup(file.file_id).mime;
        }
        catch (error) { }
        try {
            mime = indexer.subtitle_files.lookup(file.file_id).mime;
        }
        catch (error) { }
        try {
            mime = indexer.video_files.lookup(file.file_id).mime;
        }
        catch (error) { }
        let filename = path.join(libpath.sep);
        let fd = libfs.openSync(filename, 'r');
        let size = libfs.fstatSync(fd).size;
        libfs.closeSync(fd);
        let parts2;
        let range = request.headers.range;
        if (range !== undefined && (parts2 = /^bytes\=((?:[0-9])|(?:[1-9][0-9]+))\-((?:[0-9])|(?:[1-9][0-9]+))?$/.exec(range)) != null) {
            let offset = parseInt(parts2[1]);
            let offset2 = parts2[2] ? parseInt(parts2[2]) : null;
            if (offset2 === null) {
                offset2 = size - 1;
            }
            if (offset >= size || offset2 >= size || offset2 < offset) {
                response.writeHead(416);
                response.end();
                return;
            }
            let length = offset2 - offset + 1;
            response.writeHead(206, {
                'Access-Control-Allow-Origin': '*',
                'Accept-Ranges': `bytes`,
                "Cache-Control": "private, max-age=86400",
                'Content-Range': `bytes ${offset}-${offset2}/${size}`,
                'Content-Type': mime,
                'Content-Length': `${length}`
            });
            var s = libfs.createReadStream(filename, {
                start: offset,
                end: offset2
            });
            s.addListener("close", () => {
                if (offset + s.bytesRead === size) {
                    let timestamp_ms = Date.now();
                    indexer.streams.insert({
                        stream_id: libcrypto.randomBytes(8).toString("hex"),
                        user_id,
                        file_id,
                        timestamp_ms
                    });
                }
            });
            s.on('open', function () {
                s.pipe(response);
            });
            s.on('error', function (error) {
                response.end();
            });
        }
        else {
            var s = libfs.createReadStream(filename);
            s.on('open', function () {
                response.writeHead(200, {
                    'Access-Control-Allow-Origin': '*',
                    'Accept-Ranges': `bytes`,
                    "Cache-Control": "private, max-age=86400",
                    'Content-Type': mime,
                    'Content-Length': `${size}`
                });
                s.pipe(response);
            });
            s.on('error', function (error) {
                response.writeHead(404);
                response.end();
            });
        }
    };
    const contextServer = new context.server.ContextServer();
    const playlistsServer = new playlists.server.PlaylistsServer();
    let indexTimer;
    function setupIndexTimer() {
        if (is.present(indexTimer)) {
            clearTimeout(indexTimer);
        }
        indexTimer = setTimeout(() => {
            indexTimer = undefined;
            indexer.runIndexer();
        }, 60 * 60 * 1000);
    }
    function requestHandler(request, response) {
        let host = request.headers["host"] || "";
        let method = request.method || "";
        let path = request.url || "";
        if (/^[/]sockets[/]context[/]/.test(path)) {
            return contextServer.getRequestHandler()(request, response);
        }
        if (/^[/]sockets[/]playlists[/]/.test(path)) {
            return playlistsServer.getRequestHandler()(request, response);
        }
        let startMs = Date.now();
        response.on("finish", () => {
            let duration_ms = Date.now() - startMs;
            process.stderr.write(`${response.statusCode} ${method}:${path} (${duration_ms} ms)\n`);
            setupIndexTimer();
        });
        if (false && /^[0-9]+[.][0-9]+[.][0-9]+[.][0-9]+(:[0-9]+)?$/.test(host)) {
            response.writeHead(400);
            response.end();
            return;
        }
        let parts;
        if (method === 'GET' && path === '/favicon.ico') {
            response.writeHead(404);
            response.end();
            return;
        }
        if (method === "POST" && path === "/discover") {
            airplay.discover();
            chromecasts.discover();
            response.writeHead(200);
            return response.end("{}");
        }
        if (method === 'GET' && (parts = /^[/]files[/]([0-9a-f]{16})[/]/.exec(path)) !== null) {
            let file_id = parts[1];
            return send_data(file_id, request, response);
        }
        if (/^[/]media[/]/.test(path)) {
            if ((parts = /^[/]media[/]stills[/]([0-9a-f]{16})[/]/.exec(path)) != null) {
                let file_id = parts[1];
                let file = indexer.files.lookup(file_id);
                let filename = [".", "private", "stills", file.file_id];
                if (libfs.existsSync(filename.join("/"))) {
                    let stream = libfs.createReadStream(filename.join("/"));
                    stream.on("open", () => {
                        response.writeHead(200, {
                            "Access-Control-Allow-Origin": "*",
                            "Cache-Control": "public, max-age=86400",
                            "Content-Type": "image/jpeg"
                        });
                        stream.pipe(response);
                    });
                }
                else {
                    response.writeHead(404);
                    return response.end();
                }
                return;
            }
            if ((parts = /^[/]media[/]gifs[/]([0-9a-f]{16})[/]/.exec(path)) != null) {
                let cue_id = parts[1];
                let cue = indexer.cues.lookup(cue_id);
                let filename = [".", "private", "gifs", cue.cue_id];
                if (libfs.existsSync(filename.join("/"))) {
                    let stream = libfs.createReadStream(filename.join("/"));
                    stream.on("open", () => {
                        response.writeHead(200, {
                            "Access-Control-Allow-Origin": "*",
                            "Cache-Control": "public, max-age=86400",
                            "Content-Type": "image/gif"
                        });
                        stream.pipe(response);
                    });
                }
                else {
                    subsearch.generateMeme(filename, cue, () => {
                        if (!libfs.existsSync(filename.join("/"))) {
                            response.writeHead(500);
                            return response.end();
                        }
                        let stream = libfs.createReadStream(filename.join("/"));
                        stream.on("open", () => {
                            response.writeHead(200, {
                                "Access-Control-Allow-Origin": "*",
                                "Cache-Control": "public, max-age=86400",
                                "Content-Type": "image/gif"
                            });
                            stream.pipe(response);
                        });
                    });
                }
                return;
            }
        }
        if (/^[/]api[/]/.test(path)) {
            return api.handleRequest(request, response);
        }
        if (path === "/manifest.json") {
            response.writeHead(200, {
                "Content-Type": "application/json"
            });
            return response.end(JSON.stringify({
                "name": "Circus",
                "start_url": "/",
                "display": "standalone",
                "theme_color": "#df4f7f",
                "background_color": "#1f1f1f",
                "icons": []
            }));
        }
        if (path === "/logo.png") {
            response.writeHead(200, {
                "Content-Type": "image/png"
            });
            libfs.createReadStream("./public/logo.png").pipe(response);
            return;
        }
        if (method === 'GET') {
            response.writeHead(200);
            response.end(`<!doctype html><html><head><base href="/"/><meta charset="utf-8"/><meta content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0" name="viewport"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" /><link rel="apple-touch-icon" href="logo.png" /><link rel="manifest" href="/manifest.json"/><link href="https://fonts.googleapis.com/css2?family=Nunito&family=Pacifico&display=swap" rel="stylesheet"/><title>Circus</title></head><body><script>${libfs.readFileSync('./dist/client.min.js')}</script></body></html>`);
            return;
        }
        console.log('unhandled', JSON.stringify(request.headers, null, "\t"));
        response.writeHead(400);
        response.end();
        return;
    }
    if (!libfs.existsSync("./private/certs/")) {
        libfs.mkdirSync("./private/certs/", { recursive: true });
    }
    function read(path) {
        if (libfs.existsSync(path)) {
            return libfs.readFileSync(path);
        }
        return undefined;
    }
    function getLocalIp(family = "ipv4") {
        let networkInterfaces = libos.networkInterfaces();
        for (let interfaceInfos of Object.values(networkInterfaces)) {
            if (is.present(interfaceInfos)) {
                for (let interfaceInfo of interfaceInfos) {
                    if (interfaceInfo.internal === true) {
                        continue;
                    }
                    if (interfaceInfo.family.toLowerCase() === family.toLowerCase()) {
                        return interfaceInfo.address;
                    }
                }
            }
        }
        throw `Expected a local interface!`;
    }
    let full_chain = read(config_1.default.certificate_path.join("/"));
    let dhparam = read("./private/certs/dhparam.pem");
    let certificate_key = read(config_1.default.certificate_key_path.join("/"));
    // TODO: Use hostname from certificate.
    let hostname = getLocalIp();
    let media_server_host = `http://${hostname}`;
    let http_server = libhttp.createServer({}, requestHandler);
    http_server.listen(config_1.default.http_port, () => {
        console.log(`http://${hostname}:${config_1.default.http_port}`);
    });
    http_server.keepAliveTimeout = 60 * 1000;
    if (full_chain && certificate_key) {
        let https_server = libhttps.createServer({
            cert: full_chain,
            dhparam: dhparam,
            key: certificate_key
        }, requestHandler);
        https_server.listen(config_1.default.https_port, () => {
            console.log(`https://${hostname}:${config_1.default.https_port}`);
        });
        https_server.keepAliveTimeout = 60 * 1000;
        airplay.observe(true, media_server_host);
        chromecasts.observe(true, media_server_host);
    }
    else {
        airplay.observe(false, media_server_host);
        chromecasts.observe(false, media_server_host);
    }
    for (let key of indexer.getKeysFromUser.lookup(undefined)) {
        console.log(`Registration key available: ${key.key_id}`);
    }
});
function define(e,t,l){null==this.x&&(this.x=new Map),null==this.z&&(this.z=(e=>require(e))),null==this.y&&(this.y=(e=>{let t=this.x.get(e);if(null==t||null!=t.module)return;let l=Array(),u={exports:{}};for(let e of t.dependencies){if("require"===e){l.push(this.z);continue}if("module"===e){l.push(u);continue}if("exports"===e){l.push(u.exports);continue}try{l.push(this.z(e));continue}catch(e){}let t=this.x.get(e);if(null==t||null==t.module)return;l.push(t.module.exports)}t.callback(...l),t.module=u;for(let e of t.dependencies)this.y(e)}));let u=this.x.get(e);if(null!=u)throw'Duplicate module found with name "'+e+'"!';u={callback:l,dependencies:t,module:null},this.x.set(e,u),this.y(e)}