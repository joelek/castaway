define("build/languages", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pref = exports.db = void 0;
    const db = {
        eng: {
            title: "English",
            iso639_1: "en",
            iso3166_1: "US"
        },
        swe: {
            title: "Swedish",
            iso639_1: "sv",
            iso3166_1: "SE"
        },
        jpn: {
            title: "Japanese",
            iso639_1: "ja",
            iso3166_1: "JP"
        }
    };
    exports.db = db;
    const pref = [
        "swe",
        "eng",
        "jpn"
    ];
    exports.pref = pref;
});
define("build/client/browserMediaSession", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setHandlers = exports.setMetadata = void 0;
    // @ts-nocheck
    function setMetadata(metadata) {
        if (navigator.mediaSession) {
            navigator.mediaSession.metadata = new globalThis.MediaMetadata(metadata);
        }
    }
    exports.setMetadata = setMetadata;
    function setHandlers(handlers) {
        if (navigator.mediaSession) {
            for (let type in handlers) {
                navigator.mediaSession.setActionHandler(type, handlers[type]);
            }
        }
    }
    exports.setHandlers = setHandlers;
});
define("build/observers/index", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ArrayObservable = exports.computed = exports.ObservableClass = void 0;
    class ObservableClass {
        constructor(state) {
            this.state = state;
            this.observers = new Array();
        }
        addObserver(observer) {
            let observable = new ObservableClass(observer(this.state));
            this.observers.push((state) => {
                observable.updateState(observer(state));
            });
            return observable.addObserver.bind(observable);
        }
        getState() {
            return this.state;
        }
        updateState(state) {
            if (state === this.state) {
                return;
            }
            this.state = state;
            for (let observer of this.observers) {
                observer(this.state);
            }
        }
    }
    exports.ObservableClass = ObservableClass;
    function computed(computer, ...observables) {
        let observable = new ObservableClass(computer(...observables.map((observable) => observable.getState())));
        let updater = () => {
            observable.updateState(computer(...observables.map((observable) => observable.getState())));
        };
        for (let observable of observables) {
            observable.addObserver(updater);
        }
        return observable;
    }
    exports.computed = computed;
    class ArrayObservable {
        constructor(state) {
            this.state = state;
            this.observers = new Array();
        }
        addObserver(observer) {
            this.observers.push(observer);
            for (let value of this.state) {
                observer.onappend?.(value);
            }
        }
        compute(observer) {
            let observable = new ObservableClass(observer(this.state));
            this.observers.push({
                onappend: (state) => {
                    observable.updateState(observer(this.state));
                },
                onsplice: (state, index) => {
                    observable.updateState(observer(this.state));
                }
            });
            return observable.addObserver.bind(observable);
        }
        getState() {
            return this.state;
        }
        append(state) {
            this.state.push(state);
            for (let observer of this.observers) {
                observer.onappend?.(state);
            }
        }
        splice(index) {
            if (index < 0 || index >= this.state.length) {
                throw `Expected an index of at most ${this.state.length}, got ${index}!`;
            }
            let state = this.state[index];
            this.state.splice(index, 1);
            for (let observer of this.observers) {
                observer.onsplice?.(state, index);
            }
        }
        update(state) {
            for (let i = this.state.length - 1; i >= 0; i--) {
                this.splice(i);
            }
            for (let v of state) {
                this.append(v);
            }
        }
    }
    exports.ArrayObservable = ArrayObservable;
});
define("build/is", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.present = exports.absent = void 0;
    function absent(subject) {
        return subject == null;
    }
    exports.absent = absent;
    function present(subject) {
        return subject != null;
    }
    exports.present = present;
});
define("node_modules/@joelek/ts-autoguard/build/autoguard-lib/guards", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Union = exports.Undefined = exports.Tuple = exports.StringLiteral = exports.String = exports.Reference = exports.Record = exports.Object = exports.NumberLiteral = exports.Number = exports.Null = exports.Intersection = exports.BooleanLiteral = exports.Boolean = exports.Array = exports.Any = void 0;
    exports.Any = {
        as(subject, path = "") {
            return subject;
        },
        is(subject) {
            try {
                this.as(subject);
            }
            catch (error) {
                return false;
            }
            return true;
        }
    };
    exports.Array = {
        of(guard) {
            return {
                as(subject, path = "") {
                    if ((subject != null) && (subject.constructor === globalThis.Array)) {
                        for (let i = 0; i < subject.length; i++) {
                            guard.as(subject[i], path + "[" + i + "]");
                        }
                        return subject;
                    }
                    throw "Expected an array at " + path + "!";
                },
                is(subject) {
                    try {
                        this.as(subject);
                    }
                    catch (error) {
                        return false;
                    }
                    return true;
                }
            };
        }
    };
    exports.Boolean = {
        as(subject, path = "") {
            if ((subject != null) && (subject.constructor === globalThis.Boolean)) {
                return subject;
            }
            throw "Expected a boolean at " + path + "!";
        },
        is(subject) {
            try {
                this.as(subject);
            }
            catch (error) {
                return false;
            }
            return true;
        }
    };
    exports.BooleanLiteral = {
        of(value) {
            return {
                as(subject, path = "") {
                    if (subject === value) {
                        return subject;
                    }
                    throw "Expected " + value + " at " + path + "!";
                },
                is(subject) {
                    try {
                        this.as(subject);
                    }
                    catch (error) {
                        return false;
                    }
                    return true;
                }
            };
        }
    };
    exports.Intersection = {
        of(...guards) {
            return {
                as(subject, path = "") {
                    for (let guard of guards) {
                        guard.as(subject, path);
                    }
                    return subject;
                },
                is(subject) {
                    try {
                        this.as(subject);
                    }
                    catch (error) {
                        return false;
                    }
                    return true;
                }
            };
        }
    };
    exports.Null = {
        as(subject, path = "") {
            if (subject === null) {
                return subject;
            }
            throw "Expected null at " + path + "!";
        },
        is(subject) {
            try {
                this.as(subject);
            }
            catch (error) {
                return false;
            }
            return true;
        }
    };
    exports.Number = {
        as(subject, path = "") {
            if ((subject != null) && (subject.constructor === globalThis.Number)) {
                return subject;
            }
            throw "Expected a number at " + path + "!";
        },
        is(subject) {
            try {
                this.as(subject);
            }
            catch (error) {
                return false;
            }
            return true;
        }
    };
    exports.NumberLiteral = {
        of(value) {
            return {
                as(subject, path = "") {
                    if (subject === value) {
                        return subject;
                    }
                    throw "Expected " + value + " at " + path + "!";
                },
                is(subject) {
                    try {
                        this.as(subject);
                    }
                    catch (error) {
                        return false;
                    }
                    return true;
                }
            };
        }
    };
    exports.Object = {
        of(guards) {
            return {
                as(subject, path = "") {
                    if ((subject != null) && (subject.constructor === globalThis.Object)) {
                        for (let key in guards) {
                            guards[key].as(subject[key], path + /^([a-z][a-z0-9_]*)$/is.test(key) ? "." + key : "[\"" + key + "\"]");
                        }
                        return subject;
                    }
                    throw "Expected an object at " + path + "!";
                },
                is(subject) {
                    try {
                        this.as(subject);
                    }
                    catch (error) {
                        return false;
                    }
                    return true;
                }
            };
        }
    };
    exports.Record = {
        of(guard) {
            return {
                as(subject, path = "") {
                    if ((subject != null) && (subject.constructor === globalThis.Object)) {
                        for (let key of globalThis.Object.keys(subject)) {
                            guard.as(subject[key], path + "[\"" + key + "\"]");
                        }
                        return subject;
                    }
                    throw "Expected a record at " + path + "!";
                },
                is(subject) {
                    try {
                        this.as(subject);
                    }
                    catch (error) {
                        return false;
                    }
                    return true;
                }
            };
        }
    };
    exports.Reference = {
        of(guard) {
            return {
                as(subject, path = "") {
                    return guard().as(subject, path);
                },
                is(subject) {
                    return guard().is(subject);
                }
            };
        }
    };
    exports.String = {
        as(subject, path = "") {
            if ((subject != null) && (subject.constructor === globalThis.String)) {
                return subject;
            }
            throw "Expected a string at " + path + "!";
        },
        is(subject) {
            try {
                this.as(subject);
            }
            catch (error) {
                return false;
            }
            return true;
        }
    };
    exports.StringLiteral = {
        of(value) {
            return {
                as(subject, path = "") {
                    if (subject === value) {
                        return subject;
                    }
                    throw "Expected \"" + value + "\" at " + path + "!";
                },
                is(subject) {
                    try {
                        this.as(subject);
                    }
                    catch (error) {
                        return false;
                    }
                    return true;
                }
            };
        }
    };
    exports.Tuple = {
        of(...guards) {
            return {
                as(subject, path = "") {
                    if ((subject != null) && (subject.constructor === globalThis.Array)) {
                        for (let i = 0; i < guards.length; i++) {
                            guards[i].as(subject[i], path + "[" + i + "]");
                        }
                        return subject;
                    }
                    throw "Expected a tuple at " + path + "!";
                },
                is(subject) {
                    try {
                        this.as(subject);
                    }
                    catch (error) {
                        return false;
                    }
                    return true;
                }
            };
        }
    };
    exports.Undefined = {
        as(subject, path = "") {
            if (subject === undefined) {
                return subject;
            }
            throw "Expected undefined at " + path + "!";
        },
        is(subject) {
            try {
                this.as(subject);
            }
            catch (error) {
                return false;
            }
            return true;
        }
    };
    exports.Union = {
        of(...guards) {
            return {
                as(subject, path = "") {
                    for (let guard of guards) {
                        try {
                            return guard.as(subject, path);
                        }
                        catch (error) { }
                    }
                    throw "Expected a union at " + path + "!";
                },
                is(subject) {
                    try {
                        this.as(subject);
                    }
                    catch (error) {
                        return false;
                    }
                    return true;
                }
            };
        }
    };
});
define("node_modules/@joelek/ts-autoguard/build/autoguard-lib/tokenization", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.expect = exports.Tokenizer = exports.Families = void 0;
    exports.Families = ((...tuple) => tuple)("WS", "(", ")", "[", "]", "{", "}", "?", "|", ".", "..", "/", "&", "@", ",", ":", "any", "boolean", "false", "null", "number", "string", "true", "undefined", "IDENTIFIER", "NUMBER_LITERAL", "STRING_LITERAL");
    class Tokenizer {
        constructor(string) {
            let matchers = {
                "WS": /^([\t\r\n ]+)/isu,
                "(": /^([\(])/isu,
                ")": /^([\)])/isu,
                "[": /^([\[])/isu,
                "]": /^([\]])/isu,
                "{": /^([\{])/isu,
                "}": /^([\}])/isu,
                "?": /^([\?])/isu,
                "|": /^([\|])/isu,
                ".": /^([\.])/isu,
                "..": /^([\.][\.])/isu,
                "/": /^([\/])/isu,
                "&": /^([&])/isu,
                "@": /^([@])/isu,
                ",": /^([,])/isu,
                ":": /^([:])/isu,
                "any": /^(any)/isu,
                "boolean": /^(boolean)/isu,
                "false": /^(false)/isu,
                "null": /^(null)/isu,
                "number": /^(number)/isu,
                "string": /^(string)/isu,
                "true": /^(true)/isu,
                "undefined": /^(undefined)/isu,
                "IDENTIFIER": /^([a-z][a-z0-9_]*)/isu,
                "NUMBER_LITERAL": /^(([1-9][0-9]+)|([0-9]))/isu,
                "STRING_LITERAL": /^(["][^"]*["])/isu
            };
            let tokens = new Array();
            let row = 1;
            let col = 1;
            while (string.length > 0) {
                let token;
                for (let key in matchers) {
                    let type = key;
                    let exec = matchers[type].exec(string);
                    if (exec == null) {
                        continue;
                    }
                    if ((token == null) || (exec[1].length > token[1].length)) {
                        token = [type, exec[1]];
                    }
                }
                if (token == null) {
                    throw `Unrecognized token at row ${row}, col ${col}!`;
                }
                tokens.push({
                    family: token[0],
                    value: token[1],
                    row: row,
                    col: col
                });
                string = string.slice(token[1].length);
                let lines = token[1].split(/\r?\n/);
                if (lines.length > 1) {
                    row += lines.length - 1;
                    col = 1;
                }
                col += lines[lines.length - 1].length;
            }
            this.tokens = tokens.filter((token) => {
                return token.family !== "WS";
            });
            this.offset = 0;
        }
        peek() {
            return this.tokens[this.offset];
        }
        read() {
            if (this.offset >= this.tokens.length) {
                throw `Unexpectedly reached end of stream!`;
            }
            return this.tokens[this.offset++];
        }
        newContext(producer) {
            let offset = this.offset;
            try {
                return producer(() => this.read(), () => this.peek());
            }
            catch (error) {
                this.offset = offset;
                throw error;
            }
        }
    }
    exports.Tokenizer = Tokenizer;
    ;
    function expect(token, family) {
        let families = Array.isArray(family) ? family : [family];
        if (!families.includes(token.family)) {
            throw `Unexpected ${token.family} at row ${token.row}, col ${token.col}!`;
        }
        return token;
    }
    exports.expect = expect;
    ;
});
define("node_modules/@joelek/ts-autoguard/build/autoguard-lib/language", ["require", "exports", "node_modules/@joelek/ts-autoguard/build/autoguard-lib/tokenization"], function (require, exports, tokenization) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Schema = exports.UnionType = exports.UndefinedType = exports.TupleType = exports.StringLiteralType = exports.StringType = exports.ReferenceType = exports.RecordType = exports.ObjectType = exports.NumberLiteralType = exports.NumberType = exports.NullType = exports.IntersectionType = exports.GroupType = exports.BooleanLiteralType = exports.BooleanType = exports.ArrayType = exports.AnyType = exports.Type = void 0;
    ;
    exports.Type = {
        parse(tokenizer, ...exclude) {
            try {
                return UnionType.parse(tokenizer, ...exclude);
            }
            catch (error) { }
            try {
                return IntersectionType.parse(tokenizer, ...exclude);
            }
            catch (error) { }
            try {
                return ArrayType.parse(tokenizer, ...exclude);
            }
            catch (error) { }
            try {
                return AnyType.parse(tokenizer);
            }
            catch (error) { }
            try {
                return BooleanType.parse(tokenizer);
            }
            catch (error) { }
            try {
                return BooleanLiteralType.parse(tokenizer);
            }
            catch (error) { }
            try {
                return NullType.parse(tokenizer);
            }
            catch (error) { }
            try {
                return NumberType.parse(tokenizer);
            }
            catch (error) { }
            try {
                return NumberLiteralType.parse(tokenizer);
            }
            catch (error) { }
            try {
                return StringType.parse(tokenizer);
            }
            catch (error) { }
            try {
                return StringLiteralType.parse(tokenizer);
            }
            catch (error) { }
            try {
                return UndefinedType.parse(tokenizer);
            }
            catch (error) { }
            try {
                return ReferenceType.parse(tokenizer);
            }
            catch (error) { }
            try {
                return TupleType.parse(tokenizer);
            }
            catch (error) { }
            try {
                return ObjectType.parse(tokenizer);
            }
            catch (error) { }
            try {
                return GroupType.parse(tokenizer);
            }
            catch (error) { }
            try {
                return RecordType.parse(tokenizer);
            }
            catch (error) { }
            return tokenizer.newContext((read, peek) => {
                let token = read();
                throw `Unexpected ${token.family} at row ${token.row}, col ${token.col}!`;
            });
        }
    };
    class AnyType {
        constructor() {
        }
        generateType(options) {
            return "any";
        }
        generateTypeGuard(options) {
            let lines = new Array();
            if (options.standalone) {
                lines.push("(subject, path) => {");
                lines.push("	return subject;");
                lines.push("}");
            }
            else {
                lines.push("autoguard.Any");
            }
            return lines.join(options.eol);
        }
        getImports() {
            return [];
        }
        static parse(tokenizer) {
            return tokenizer.newContext((read, peek) => {
                tokenization.expect(read(), "any");
                return AnyType.INSTANCE;
            });
        }
    }
    exports.AnyType = AnyType;
    AnyType.INSTANCE = new AnyType();
    ;
    class ArrayType {
        constructor(type) {
            this.type = type;
        }
        generateType(options) {
            return this.type.generateType(options) + "[]";
        }
        generateTypeGuard(options) {
            let lines = new Array();
            if (options.standalone) {
                lines.push("(subject, path) => {");
                lines.push("	if ((subject != null) && (subject.constructor === globalThis.Array)) {");
                lines.push("		for (let i = 0; i < subject.length; i++) {");
                lines.push("			(" + this.type.generateTypeGuard(Object.assign(Object.assign({}, options), { eol: options.eol + "\t\t\t" })) + ")(subject[i], path + \"[\" + i + \"]\");");
                lines.push("		}");
                lines.push("		return subject;");
                lines.push("	}");
                lines.push("	throw \"Expected an array at \" + path + \"!\";");
                lines.push("}");
            }
            else {
                lines.push("autoguard.Array.of(" + this.type.generateTypeGuard(Object.assign(Object.assign({}, options), { eol: options.eol })) + ")");
            }
            return lines.join(options.eol);
        }
        getImports() {
            return this.type.getImports();
        }
        static parse(tokenizer, ...exclude) {
            if (exclude.includes("Array")) {
                throw `Recursion prevention!`;
            }
            return tokenizer.newContext((read, peek) => {
                let type = exports.Type.parse(tokenizer, ...exclude, "Array");
                tokenization.expect(read(), "[");
                tokenization.expect(read(), "]");
                let array = new ArrayType(type);
                while (true) {
                    try {
                        tokenizer.newContext((read, peek) => {
                            tokenization.expect(read(), "[");
                            tokenization.expect(read(), "]");
                            array = new ArrayType(array);
                        });
                    }
                    catch (error) {
                        break;
                    }
                }
                return array;
            });
        }
    }
    exports.ArrayType = ArrayType;
    ;
    class BooleanType {
        constructor() {
        }
        generateType(options) {
            return "boolean";
        }
        generateTypeGuard(options) {
            let lines = new Array();
            if (options.standalone) {
                lines.push("(subject, path) => {");
                lines.push("	if ((subject != null) && (subject.constructor === globalThis.Boolean)) {");
                lines.push("		return subject as boolean;");
                lines.push("	}");
                lines.push("	throw \"Expected a boolean at \" + path + \"!\";");
                lines.push("}");
            }
            else {
                lines.push("autoguard.Boolean");
            }
            return lines.join(options.eol);
        }
        getImports() {
            return [];
        }
        static parse(tokenizer) {
            return tokenizer.newContext((read, peek) => {
                tokenization.expect(read(), "boolean");
                return BooleanType.INSTANCE;
            });
        }
    }
    exports.BooleanType = BooleanType;
    BooleanType.INSTANCE = new BooleanType();
    ;
    class BooleanLiteralType {
        constructor(value) {
            this.value = value;
        }
        generateType(options) {
            return "" + this.value;
        }
        generateTypeGuard(options) {
            let lines = new Array();
            if (options.standalone) {
                lines.push("(subject, path) => {");
                lines.push("	if (subject === " + this.generateType(Object.assign(Object.assign({}, options), { eol: options.eol + "\t" })) + ") {");
                lines.push("		return subject;");
                lines.push("	}");
                lines.push("	throw \"Expected " + this.value + " at \" + path + \"!\";");
                lines.push("}");
            }
            else {
                lines.push("autoguard.BooleanLiteral.of(" + this.generateType(Object.assign(Object.assign({}, options), { eol: options.eol })) + ")");
            }
            return lines.join(options.eol);
        }
        getImports() {
            return [];
        }
        static parse(tokenizer) {
            return tokenizer.newContext((read, peek) => {
                let token = tokenization.expect(read(), [
                    "true",
                    "false"
                ]);
                if (token.family === "true") {
                    return BooleanLiteralType.INSTANCE_TRUE;
                }
                else {
                    return BooleanLiteralType.INSTANCE_FALSE;
                }
            });
        }
    }
    exports.BooleanLiteralType = BooleanLiteralType;
    BooleanLiteralType.INSTANCE_TRUE = new BooleanLiteralType(true);
    BooleanLiteralType.INSTANCE_FALSE = new BooleanLiteralType(false);
    ;
    class GroupType {
        constructor(type) {
            this.type = type;
        }
        generateType(options) {
            return "(" + this.type.generateType(options) + ")";
        }
        generateTypeGuard(options) {
            return this.type.generateTypeGuard(options);
        }
        getImports() {
            return this.type.getImports();
        }
        static parse(tokenizer) {
            return tokenizer.newContext((read, peek) => {
                tokenization.expect(read(), "(");
                let type = exports.Type.parse(tokenizer);
                tokenization.expect(read(), ")");
                return new GroupType(type);
            });
        }
    }
    exports.GroupType = GroupType;
    ;
    class IntersectionType {
        constructor() {
            this.types = new Set();
        }
        add(type) {
            this.types.add(type);
            return this;
        }
        generateType(options) {
            let lines = new Array();
            for (let type of this.types) {
                lines.push(type.generateType(options));
            }
            let string = lines.join(" & ");
            return string;
        }
        generateTypeGuard(options) {
            let lines = new Array();
            if (options.standalone) {
                lines.push("(subject, path) => {");
                for (let type of this.types) {
                    lines.push("	(" + type.generateTypeGuard(Object.assign(Object.assign({}, options), { eol: options.eol + "\t" })) + ")(subject, path);");
                }
                lines.push("	return subject;");
                lines.push("}");
                return lines.join(options.eol);
            }
            else {
                for (let type of this.types) {
                    lines.push("	" + type.generateTypeGuard(Object.assign(Object.assign({}, options), { eol: options.eol + "\t" })));
                }
                return "autoguard.Intersection.of(" + options.eol + lines.join("," + options.eol) + options.eol + ")";
            }
        }
        getImports() {
            let imports = new Array();
            for (let type of this.types) {
                imports.push(...type.getImports());
            }
            return imports;
        }
        static parse(tokenizer, ...exclude) {
            if (exclude.includes("Intersection")) {
                throw `Recursion prevention!`;
            }
            return tokenizer.newContext((read, peek) => {
                var _a;
                let type = exports.Type.parse(tokenizer, ...exclude, "Intersection");
                let instance = new IntersectionType();
                instance.add(type);
                while (true) {
                    if (((_a = peek()) === null || _a === void 0 ? void 0 : _a.value) !== "&") {
                        break;
                    }
                    tokenization.expect(read(), "&");
                    let type = exports.Type.parse(tokenizer, ...exclude, "Intersection");
                    instance.add(type);
                }
                if (instance.types.size === 1) {
                    return type;
                }
                return instance;
            });
        }
    }
    exports.IntersectionType = IntersectionType;
    ;
    class NullType {
        constructor() {
        }
        generateType(options) {
            return "null";
        }
        generateTypeGuard(options) {
            let lines = new Array();
            if (options.standalone) {
                lines.push("(subject, path) => {");
                lines.push("	if (subject === null) {");
                lines.push("		return subject;");
                lines.push("	}");
                lines.push("	throw \"Expected null at \" + path + \"!\";");
                lines.push("}");
            }
            else {
                lines.push("autoguard.Null");
            }
            return lines.join(options.eol);
        }
        getImports() {
            return [];
        }
        static parse(tokenizer) {
            return tokenizer.newContext((read, peek) => {
                tokenization.expect(read(), "null");
                return NullType.INSTANCE;
            });
        }
    }
    exports.NullType = NullType;
    NullType.INSTANCE = new NullType();
    ;
    class NumberType {
        constructor() {
        }
        generateType(options) {
            return "number";
        }
        generateTypeGuard(options) {
            let lines = new Array();
            if (options.standalone) {
                lines.push("(subject, path) => {");
                lines.push("	if ((subject != null) && (subject.constructor === globalThis.Number)) {");
                lines.push("		return subject as number;");
                lines.push("	}");
                lines.push("	throw \"Expected a number at \" + path + \"!\";");
                lines.push("}");
            }
            else {
                lines.push("autoguard.Number");
            }
            return lines.join(options.eol);
        }
        getImports() {
            return [];
        }
        static parse(tokenizer) {
            return tokenizer.newContext((read, peek) => {
                tokenization.expect(read(), "number");
                return NumberType.INSTANCE;
            });
        }
    }
    exports.NumberType = NumberType;
    NumberType.INSTANCE = new NumberType();
    ;
    class NumberLiteralType {
        constructor(value) {
            this.value = value;
        }
        generateType(options) {
            return "" + this.value;
        }
        generateTypeGuard(options) {
            let lines = new Array();
            if (options.standalone) {
                lines.push("(subject, path) => {");
                lines.push("	if (subject === " + this.generateType(Object.assign(Object.assign({}, options), { eol: options.eol + "\t" })) + ") {");
                lines.push("		return subject;");
                lines.push("	}");
                lines.push("	throw \"Expected " + this.value + " at \" + path + \"!\";");
                lines.push("}");
            }
            else {
                lines.push("autoguard.NumberLiteral.of(" + this.generateType(Object.assign(Object.assign({}, options), { eol: options.eol })) + ")");
            }
            return lines.join(options.eol);
        }
        getImports() {
            return [];
        }
        static parse(tokenizer) {
            return tokenizer.newContext((read, peek) => {
                let value = tokenization.expect(read(), "NUMBER_LITERAL").value;
                return new NumberLiteralType(Number.parseInt(value));
            });
        }
    }
    exports.NumberLiteralType = NumberLiteralType;
    ;
    class ObjectType {
        constructor() {
            this.members = new Map();
        }
        add(key, value) {
            this.members.set(key, value);
            return this;
        }
        generateType(options) {
            if (this.members.size === 0) {
                return "{}";
            }
            let lines = new Array();
            for (let [key, value] of this.members) {
                lines.push("	\"" + key + "\"" + (value.optional ? "?" : "") + ": " + value.type.generateType(Object.assign(Object.assign({}, options), { eol: options.eol + "\t" })));
            }
            let string = lines.length > 0 ? options.eol + lines.join("," + options.eol) + options.eol : "";
            return "{" + string + "}";
        }
        generateTypeGuard(options) {
            let lines = new Array();
            if (options.standalone) {
                lines.push("(subject, path) => {");
                lines.push("	if ((subject != null) && (subject.constructor === globalThis.Object)) {");
                for (let [key, value] of this.members) {
                    let type = value.type;
                    if (value.optional) {
                        let union = new UnionType();
                        union.add(UndefinedType.INSTANCE);
                        union.add(type);
                        type = union;
                    }
                    let tail = /^([a-z][a-z0-9_]*)$/is.test(key) ? "\"." + key + "\"" : "\"[\\\"" + key + "\\\"]\"";
                    lines.push("		(" + type.generateTypeGuard(Object.assign(Object.assign({}, options), { eol: options.eol + "\t\t" })) + ")(subject[\"" + key + "\"], path + " + tail + ");");
                }
                lines.push("		return subject;");
                lines.push("	}");
                lines.push("	throw \"Expected an object at \" + path + \"!\";");
                lines.push("}");
                return lines.join(options.eol);
            }
            else {
                for (let [key, value] of this.members) {
                    let type = value.type;
                    if (value.optional) {
                        let union = new UnionType();
                        union.add(UndefinedType.INSTANCE);
                        union.add(type);
                        type = union;
                    }
                    lines.push("	\"" + key + "\": " + type.generateTypeGuard(Object.assign(Object.assign({}, options), { eol: options.eol + "\t" })));
                }
                let type = this.typename != null ? this.typename : this.generateType(options);
                let guard = lines.length > 0 ? options.eol + lines.join("," + options.eol) + options.eol : "";
                return "autoguard.Object.of<" + type + ">({" + guard + "})";
            }
        }
        getImports() {
            let imports = new Array();
            for (let [key, value] of this.members) {
                let type = value.type;
                imports.push(...type.getImports());
            }
            return imports;
        }
        setTypename(typename) {
            this.typename = typename;
        }
        static parse(tokenizer) {
            return tokenizer.newContext((read, peek) => {
                var _a, _b, _c;
                tokenization.expect(read(), "{");
                let instance = new ObjectType();
                if (((_a = peek()) === null || _a === void 0 ? void 0 : _a.value) !== "}") {
                    while (true) {
                        let optional = false;
                        let token = tokenization.expect(read(), [
                            "any",
                            "boolean",
                            "false",
                            "null",
                            "number",
                            "string",
                            "true",
                            "undefined",
                            "IDENTIFIER",
                            "STRING_LITERAL"
                        ]);
                        let key = token.family === "STRING_LITERAL" ? token.value.slice(1, -1) : token.value;
                        if (((_b = peek()) === null || _b === void 0 ? void 0 : _b.value) === "?") {
                            read();
                            optional = true;
                        }
                        tokenization.expect(read(), ":");
                        let type = exports.Type.parse(tokenizer);
                        instance.add(key, {
                            type,
                            optional
                        });
                        if (((_c = peek()) === null || _c === void 0 ? void 0 : _c.value) !== ",") {
                            break;
                        }
                        tokenization.expect(read(), ",");
                    }
                }
                tokenization.expect(read(), "}");
                return instance;
            });
        }
    }
    exports.ObjectType = ObjectType;
    ;
    class RecordType {
        constructor(type) {
            this.type = type;
        }
        generateType(options) {
            return "Record<string, undefined | " + this.type.generateType(options) + ">";
        }
        generateTypeGuard(options) {
            let lines = new Array();
            if (options.standalone) {
                lines.push("(subject, path) => {");
                lines.push("	if ((subject != null) && (subject.constructor === globalThis.Object)) {");
                lines.push("		for (let key of globalThis.Object.keys(subject)) {");
                lines.push("			(" + this.type.generateTypeGuard(Object.assign(Object.assign({}, options), { eol: options.eol + "\t\t\t" })) + ")(subject[key], path + \"[\\\"\" + key + \"\\\"]\");");
                lines.push("		}");
                lines.push("		return subject;");
                lines.push("	}");
                lines.push("	throw \"Expected a record at \" + path + \"!\";");
                lines.push("}");
            }
            else {
                lines.push("autoguard.Record.of(" + this.type.generateTypeGuard(Object.assign(Object.assign({}, options), { eol: options.eol })) + ")");
            }
            return lines.join(options.eol);
        }
        getImports() {
            return this.type.getImports();
        }
        static parse(tokenizer) {
            return tokenizer.newContext((read, peek) => {
                tokenization.expect(read(), "{");
                let type = exports.Type.parse(tokenizer);
                tokenization.expect(read(), "}");
                return new RecordType(type);
            });
        }
    }
    exports.RecordType = RecordType;
    ;
    class ReferenceType {
        constructor(path, typename) {
            this.path = path;
            this.typename = typename;
        }
        generateType(options) {
            return this.typename;
        }
        generateTypeGuard(options) {
            if (options.standalone) {
                return this.typename + ".as";
            }
            else {
                return "autoguard.Reference.of<" + this.typename + ">(() => " + this.typename + ")";
            }
        }
        getImports() {
            if (this.path.length > 0) {
                return [
                    {
                        path: this.path,
                        typename: this.typename
                    }
                ];
            }
            return [];
        }
        static parse(tokenizer) {
            return tokenizer.newContext((read, peek) => {
                var _a, _b;
                if (((_a = peek()) === null || _a === void 0 ? void 0 : _a.family) === "@") {
                    tokenization.expect(read(), "@");
                }
                let tokens = new Array();
                while (true) {
                    let token = read();
                    tokenization.expect(token, [".", "..", "IDENTIFIER"]);
                    tokens.push(token);
                    if (((_b = peek()) === null || _b === void 0 ? void 0 : _b.family) !== "/") {
                        break;
                    }
                    tokenization.expect(read(), "/");
                }
                let last = tokens.pop();
                tokenization.expect(last, "IDENTIFIER");
                return new ReferenceType(tokens.map((token) => token.value), last.value);
            });
        }
    }
    exports.ReferenceType = ReferenceType;
    ;
    class StringType {
        constructor() {
        }
        generateType(options) {
            return "string";
        }
        generateTypeGuard(options) {
            let lines = new Array();
            if (options.standalone) {
                lines.push("(subject, path) => {");
                lines.push("	if ((subject != null) && (subject.constructor === globalThis.String)) {");
                lines.push("		return subject as string;");
                lines.push("	}");
                lines.push("	throw \"Expected a string at \" + path + \"!\";");
                lines.push("}");
            }
            else {
                lines.push("autoguard.String");
            }
            return lines.join(options.eol);
        }
        getImports() {
            return [];
        }
        static parse(tokenizer) {
            return tokenizer.newContext((read, peek) => {
                tokenization.expect(read(), "string");
                return StringType.INSTANCE;
            });
        }
    }
    exports.StringType = StringType;
    StringType.INSTANCE = new StringType();
    ;
    class StringLiteralType {
        constructor(value) {
            this.value = value;
        }
        generateType(options) {
            return "\"" + this.value + "\"";
        }
        generateTypeGuard(options) {
            let lines = new Array();
            if (options.standalone) {
                lines.push("(subject, path) => {");
                lines.push("	if (subject === " + this.generateType(Object.assign(Object.assign({}, options), { eol: options.eol + "\t" })) + ") {");
                lines.push("		return subject;");
                lines.push("	}");
                lines.push("	throw \"Expected \\\"" + this.value + "\\\" at \" + path + \"!\";");
                lines.push("}");
            }
            else {
                lines.push("autoguard.StringLiteral.of(\"" + this.value + "\")");
            }
            return lines.join(options.eol);
        }
        getImports() {
            return [];
        }
        static parse(tokenizer) {
            return tokenizer.newContext((read, peek) => {
                let value = tokenization.expect(read(), "STRING_LITERAL").value;
                return new StringLiteralType(value.slice(1, -1));
            });
        }
    }
    exports.StringLiteralType = StringLiteralType;
    ;
    class TupleType {
        constructor() {
            this.types = new Array();
        }
        add(type) {
            this.types.push(type);
            return this;
        }
        generateType(options) {
            let strings = new Array();
            for (let type of this.types) {
                strings.push("	" + type.generateType(Object.assign(Object.assign({}, options), { eol: options.eol + "\t" })));
            }
            let string = strings.length > 0 ? options.eol + strings.join("," + options.eol) + options.eol : "";
            return "[" + string + "]";
        }
        generateTypeGuard(options) {
            let lines = new Array();
            if (options.standalone) {
                lines.push("(subject, path) => {");
                lines.push("	if ((subject != null) && (subject.constructor === globalThis.Array)) {");
                for (let i = 0; i < this.types.length; i++) {
                    let type = this.types[i];
                    lines.push("		(" + type.generateTypeGuard(Object.assign(Object.assign({}, options), { eol: options.eol + "\t\t" })) + ")(subject[" + i + "], path + \"[" + i + "]\");");
                }
                lines.push("		return subject as " + this.generateType(Object.assign(Object.assign({}, options), { eol: options.eol + "\t\t" })) + ";");
                lines.push("	}");
                lines.push("	throw \"Expected a tuple at \" + path + \"!\";");
                lines.push("}");
                return lines.join(options.eol);
            }
            else {
                for (let type of this.types) {
                    lines.push("	" + type.generateTypeGuard(Object.assign(Object.assign({}, options), { eol: options.eol + "\t" })));
                }
                let string = lines.length > 0 ? options.eol + lines.join("," + options.eol) + options.eol : "";
                return "autoguard.Tuple.of(" + string + ")";
            }
        }
        getImports() {
            let imports = new Array();
            for (let type of this.types) {
                imports.push(...type.getImports());
            }
            return imports;
        }
        static parse(tokenizer) {
            return tokenizer.newContext((read, peek) => {
                var _a, _b;
                tokenization.expect(read(), "[");
                let instance = new TupleType();
                if (((_a = peek()) === null || _a === void 0 ? void 0 : _a.value) !== "]") {
                    while (true) {
                        let type = exports.Type.parse(tokenizer);
                        instance.add(type);
                        if (((_b = peek()) === null || _b === void 0 ? void 0 : _b.value) !== ",") {
                            break;
                        }
                        tokenization.expect(read(), ",");
                    }
                }
                tokenization.expect(read(), "]");
                return instance;
            });
        }
    }
    exports.TupleType = TupleType;
    ;
    class UndefinedType {
        constructor() {
        }
        generateType(options) {
            return "undefined";
        }
        generateTypeGuard(options) {
            let lines = new Array();
            if (options.standalone) {
                lines.push("(subject, path) => {");
                lines.push("	if (subject === undefined) {");
                lines.push("		return subject;");
                lines.push("	}");
                lines.push("	throw \"Expected undefined at \" + path + \"!\";");
                lines.push("}");
            }
            else {
                lines.push("autoguard.Undefined");
            }
            return lines.join(options.eol);
        }
        getImports() {
            return [];
        }
        static parse(tokenizer) {
            return tokenizer.newContext((read, peek) => {
                tokenization.expect(read(), "undefined");
                return UndefinedType.INSTANCE;
            });
        }
    }
    exports.UndefinedType = UndefinedType;
    UndefinedType.INSTANCE = new UndefinedType();
    ;
    class UnionType {
        constructor() {
            this.types = new Set();
        }
        add(type) {
            this.types.add(type);
            return this;
        }
        generateType(options) {
            let lines = new Array();
            for (let type of this.types) {
                lines.push(type.generateType(options));
            }
            let string = lines.join(" | ");
            return string;
        }
        generateTypeGuard(options) {
            let lines = new Array();
            if (options.standalone) {
                lines.push("(subject, path) => {");
                for (let type of this.types) {
                    lines.push("	try {");
                    lines.push("		return (" + type.generateTypeGuard(Object.assign(Object.assign({}, options), { eol: options.eol + "\t\t" })) + ")(subject, path);");
                    lines.push("	} catch (error) {}");
                }
                lines.push("	throw \"Expected a union at \" + path + \"!\";");
                lines.push("}");
                return lines.join(options.eol);
            }
            else {
                for (let type of this.types) {
                    lines.push("	" + type.generateTypeGuard(Object.assign(Object.assign({}, options), { eol: options.eol + "\t" })));
                }
                return "autoguard.Union.of(" + options.eol + lines.join("," + options.eol) + options.eol + ")";
            }
        }
        getImports() {
            let imports = new Array();
            for (let type of this.types) {
                imports.push(...type.getImports());
            }
            return imports;
        }
        static parse(tokenizer, ...exclude) {
            if (exclude.includes("Union")) {
                throw `Recursion prevention!`;
            }
            return tokenizer.newContext((read, peek) => {
                var _a;
                let type = exports.Type.parse(tokenizer, ...exclude, "Union");
                let instance = new UnionType();
                instance.add(type);
                while (true) {
                    if (((_a = peek()) === null || _a === void 0 ? void 0 : _a.value) !== "|") {
                        break;
                    }
                    tokenization.expect(read(), "|");
                    let type = exports.Type.parse(tokenizer, ...exclude, "Union");
                    instance.add(type);
                }
                if (instance.types.size === 1) {
                    return type;
                }
                return instance;
            });
        }
    }
    exports.UnionType = UnionType;
    ;
    class Schema {
        constructor() {
            this.types = new Map();
        }
        getImports() {
            let imports = new Map();
            for (let [key, value] of this.types) {
                let entries = value.getImports();
                for (let entry of entries) {
                    imports.set(entry.typename, entry.path);
                }
            }
            return Array.from(imports.entries())
                .sort((one, two) => one[0].localeCompare(two[0]))
                .map((entry) => {
                return {
                    path: entry[1],
                    typename: entry[0]
                };
            });
        }
        add(key, value) {
            this.types.set(key, value);
            return this;
        }
        generateModule(options) {
            let lines = new Array();
            lines.push("// This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.");
            lines.push("");
            let imports = this.getImports();
            for (let entry of imports) {
                lines.push("import { " + entry.typename + " } from \"" + entry.path.join("/") + "\";");
            }
            if (!options.standalone) {
                lines.push("import { guards as autoguard } from \"@joelek/ts-autoguard\";");
            }
            lines.push("");
            for (let [key, value] of this.types) {
                lines.push("export type " + key + " = " + value.generateType(options) + ";");
                lines.push("");
                if (options.standalone) {
                    lines.push("export const " + key + " = {");
                    lines.push("	as(subject: any, path: string = \"\"): " + key + " {");
                    lines.push("		return (" + value.generateTypeGuard(Object.assign(Object.assign({}, options), { eol: options.eol + "\t\t" })) + ")(subject, path);");
                    lines.push("	},");
                    lines.push("	is(subject: any): subject is " + key + " {");
                    lines.push("		try {");
                    lines.push("			this.as(subject);");
                    lines.push("		} catch (error) {");
                    lines.push("			return false;");
                    lines.push("		}");
                    lines.push("		return true;");
                    lines.push("	}");
                    lines.push("};");
                    lines.push("");
                }
                else {
                    lines.push("export const " + key + " = " + value.generateTypeGuard(Object.assign(Object.assign({}, options), { eol: options.eol })) + ";");
                    lines.push("");
                }
            }
            let autoguard = new ObjectType();
            for (let [key, value] of this.types) {
                autoguard.add(key, {
                    type: new ReferenceType([], key),
                    optional: false
                });
            }
            lines.push("export type Autoguard = " + autoguard.generateType(options) + ";");
            lines.push("");
            lines.push("export const Autoguard = " + autoguard.generateType(options) + ";");
            lines.push("");
            return lines.join(options.eol);
        }
        static parse(tokenizer) {
            return tokenizer.newContext((read, peek) => {
                var _a, _b, _c;
                tokenization.expect(read(), "{");
                let instance = new Schema();
                if (((_a = peek()) === null || _a === void 0 ? void 0 : _a.value) !== "}") {
                    while (true) {
                        let identifier = tokenization.expect(read(), "IDENTIFIER").value;
                        tokenization.expect(read(), ":");
                        let type = exports.Type.parse(tokenizer);
                        (_b = type.setTypename) === null || _b === void 0 ? void 0 : _b.call(type, identifier);
                        instance.add(identifier, type);
                        if (((_c = peek()) === null || _c === void 0 ? void 0 : _c.value) !== ",") {
                            break;
                        }
                        tokenization.expect(read(), ",");
                    }
                }
                tokenization.expect(read(), "}");
                if (peek() != null) {
                    throw `Expected end of stream!`;
                }
                return instance;
            });
        }
    }
    exports.Schema = Schema;
    ;
});
define("node_modules/@joelek/ts-autoguard/build/autoguard-lib/serialization", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MessageSerializer = void 0;
    class MessageSerializer {
        constructor(guards) {
            this.guards = guards;
        }
        deserialize(string, cb) {
            let json = JSON.parse(string);
            if ((json != null) && (json.constructor === Object)) {
                if ((json.type != null) && (json.type.constructor === String)) {
                    let type = json.type;
                    let data = json.data;
                    let guard = this.guards[type];
                    if (guard === undefined) {
                        throw "Unknown message type \"" + type + "\"!";
                    }
                    cb(type, guard.as(data));
                    return;
                }
            }
            throw "Invalid message envelope!";
        }
        serialize(type, data) {
            return JSON.stringify({
                type,
                data
            });
        }
    }
    exports.MessageSerializer = MessageSerializer;
    ;
});
define("node_modules/@joelek/ts-autoguard/build/autoguard-lib/index", ["require", "exports", "node_modules/@joelek/ts-autoguard/build/autoguard-lib/guards", "node_modules/@joelek/ts-autoguard/build/autoguard-lib/language", "node_modules/@joelek/ts-autoguard/build/autoguard-lib/serialization", "node_modules/@joelek/ts-autoguard/build/autoguard-lib/tokenization"], function (require, exports, guards, language, serialization, tokenization) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.transform = exports.tokenization = exports.serialization = exports.language = exports.guards = void 0;
    exports.guards = guards;
    exports.language = language;
    exports.serialization = serialization;
    exports.tokenization = tokenization;
    function transform(string, options) {
        let tokenizer = new tokenization.Tokenizer(string);
        let schema = language.Schema.parse(tokenizer);
        return schema.generateModule(options);
    }
    exports.transform = transform;
});
define("build/database/schema", ["require", "exports", "node_modules/@joelek/ts-autoguard/build/autoguard-lib/index"], function (require, exports, ts_autoguard_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.Year = exports.PlaylistItem = exports.Playlist = exports.Stream = exports.Token = exports.Key = exports.User = exports.Cue = exports.Subtitle = exports.ShowGenre = exports.MovieGenre = exports.Genre = exports.ShowActor = exports.MovieActor = exports.Actor = exports.MovieFile = exports.Movie = exports.EpisodeFile = exports.Episode = exports.Season = exports.ShowFile = exports.Show = exports.TrackArtist = exports.AlbumArtist = exports.TrackFile = exports.Track = exports.Disc = exports.AlbumFile = exports.Album = exports.Artist = exports.VideoSubtitle = exports.VideoFile = exports.SubtitleFile = exports.MetadataFile = exports.ImageFile = exports.AudioFile = exports.File = exports.Directory = void 0;
    exports.Directory = ts_autoguard_1.guards.Object.of({
        "directory_id": ts_autoguard_1.guards.String,
        "name": ts_autoguard_1.guards.String,
        "parent_directory_id": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.String)
    });
    exports.File = ts_autoguard_1.guards.Object.of({
        "file_id": ts_autoguard_1.guards.String,
        "name": ts_autoguard_1.guards.String,
        "parent_directory_id": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.String),
        "index_timestamp": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.Number)
    });
    exports.AudioFile = ts_autoguard_1.guards.Object.of({
        "file_id": ts_autoguard_1.guards.String,
        "mime": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.StringLiteral.of("audio/mp4"), ts_autoguard_1.guards.StringLiteral.of("audio/mp3")),
        "duration_ms": ts_autoguard_1.guards.Number
    });
    exports.ImageFile = ts_autoguard_1.guards.Object.of({
        "file_id": ts_autoguard_1.guards.String,
        "mime": ts_autoguard_1.guards.StringLiteral.of("image/jpeg"),
        "width": ts_autoguard_1.guards.Number,
        "height": ts_autoguard_1.guards.Number
    });
    exports.MetadataFile = ts_autoguard_1.guards.Object.of({
        "file_id": ts_autoguard_1.guards.String,
        "mime": ts_autoguard_1.guards.StringLiteral.of("application/json")
    });
    exports.SubtitleFile = ts_autoguard_1.guards.Object.of({
        "file_id": ts_autoguard_1.guards.String,
        "mime": ts_autoguard_1.guards.StringLiteral.of("text/vtt"),
        "duration_ms": ts_autoguard_1.guards.Number,
        "language": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.String)
    });
    exports.VideoFile = ts_autoguard_1.guards.Object.of({
        "file_id": ts_autoguard_1.guards.String,
        "mime": ts_autoguard_1.guards.StringLiteral.of("video/mp4"),
        "duration_ms": ts_autoguard_1.guards.Number,
        "width": ts_autoguard_1.guards.Number,
        "height": ts_autoguard_1.guards.Number
    });
    exports.VideoSubtitle = ts_autoguard_1.guards.Object.of({
        "video_file_id": ts_autoguard_1.guards.String,
        "subtitle_file_id": ts_autoguard_1.guards.String
    });
    exports.Artist = ts_autoguard_1.guards.Object.of({
        "artist_id": ts_autoguard_1.guards.String,
        "name": ts_autoguard_1.guards.String
    });
    exports.Album = ts_autoguard_1.guards.Object.of({
        "album_id": ts_autoguard_1.guards.String,
        "title": ts_autoguard_1.guards.String,
        "year": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.Number)
    });
    exports.AlbumFile = ts_autoguard_1.guards.Object.of({
        "album_id": ts_autoguard_1.guards.String,
        "file_id": ts_autoguard_1.guards.String
    });
    exports.Disc = ts_autoguard_1.guards.Object.of({
        "disc_id": ts_autoguard_1.guards.String,
        "album_id": ts_autoguard_1.guards.String,
        "number": ts_autoguard_1.guards.Number
    });
    exports.Track = ts_autoguard_1.guards.Object.of({
        "track_id": ts_autoguard_1.guards.String,
        "disc_id": ts_autoguard_1.guards.String,
        "title": ts_autoguard_1.guards.String,
        "number": ts_autoguard_1.guards.Number
    });
    exports.TrackFile = ts_autoguard_1.guards.Object.of({
        "track_id": ts_autoguard_1.guards.String,
        "file_id": ts_autoguard_1.guards.String
    });
    exports.AlbumArtist = ts_autoguard_1.guards.Object.of({
        "album_id": ts_autoguard_1.guards.String,
        "artist_id": ts_autoguard_1.guards.String,
        "order": ts_autoguard_1.guards.Number
    });
    exports.TrackArtist = ts_autoguard_1.guards.Object.of({
        "track_id": ts_autoguard_1.guards.String,
        "artist_id": ts_autoguard_1.guards.String,
        "order": ts_autoguard_1.guards.Number
    });
    exports.Show = ts_autoguard_1.guards.Object.of({
        "show_id": ts_autoguard_1.guards.String,
        "name": ts_autoguard_1.guards.String,
        "summary": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.String)
    });
    exports.ShowFile = ts_autoguard_1.guards.Object.of({
        "show_id": ts_autoguard_1.guards.String,
        "file_id": ts_autoguard_1.guards.String
    });
    exports.Season = ts_autoguard_1.guards.Object.of({
        "season_id": ts_autoguard_1.guards.String,
        "show_id": ts_autoguard_1.guards.String,
        "number": ts_autoguard_1.guards.Number
    });
    exports.Episode = ts_autoguard_1.guards.Object.of({
        "episode_id": ts_autoguard_1.guards.String,
        "season_id": ts_autoguard_1.guards.String,
        "title": ts_autoguard_1.guards.String,
        "number": ts_autoguard_1.guards.Number,
        "year": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.Number),
        "summary": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.String)
    });
    exports.EpisodeFile = ts_autoguard_1.guards.Object.of({
        "episode_id": ts_autoguard_1.guards.String,
        "file_id": ts_autoguard_1.guards.String
    });
    exports.Movie = ts_autoguard_1.guards.Object.of({
        "movie_id": ts_autoguard_1.guards.String,
        "title": ts_autoguard_1.guards.String,
        "year": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.Number),
        "summary": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.String)
    });
    exports.MovieFile = ts_autoguard_1.guards.Object.of({
        "movie_id": ts_autoguard_1.guards.String,
        "file_id": ts_autoguard_1.guards.String
    });
    exports.Actor = ts_autoguard_1.guards.Object.of({
        "actor_id": ts_autoguard_1.guards.String,
        "name": ts_autoguard_1.guards.String
    });
    exports.MovieActor = ts_autoguard_1.guards.Object.of({
        "movie_id": ts_autoguard_1.guards.String,
        "actor_id": ts_autoguard_1.guards.String,
        "order": ts_autoguard_1.guards.Number
    });
    exports.ShowActor = ts_autoguard_1.guards.Object.of({
        "show_id": ts_autoguard_1.guards.String,
        "actor_id": ts_autoguard_1.guards.String,
        "order": ts_autoguard_1.guards.Number
    });
    exports.Genre = ts_autoguard_1.guards.Object.of({
        "genre_id": ts_autoguard_1.guards.String,
        "name": ts_autoguard_1.guards.String
    });
    exports.MovieGenre = ts_autoguard_1.guards.Object.of({
        "movie_id": ts_autoguard_1.guards.String,
        "genre_id": ts_autoguard_1.guards.String,
        "order": ts_autoguard_1.guards.Number
    });
    exports.ShowGenre = ts_autoguard_1.guards.Object.of({
        "show_id": ts_autoguard_1.guards.String,
        "genre_id": ts_autoguard_1.guards.String,
        "order": ts_autoguard_1.guards.Number
    });
    exports.Subtitle = ts_autoguard_1.guards.Object.of({
        "subtitle_id": ts_autoguard_1.guards.String,
        "file_id": ts_autoguard_1.guards.String
    });
    exports.Cue = ts_autoguard_1.guards.Object.of({
        "cue_id": ts_autoguard_1.guards.String,
        "subtitle_id": ts_autoguard_1.guards.String,
        "start_ms": ts_autoguard_1.guards.Number,
        "duration_ms": ts_autoguard_1.guards.Number,
        "lines": ts_autoguard_1.guards.String
    });
    exports.User = ts_autoguard_1.guards.Object.of({
        "user_id": ts_autoguard_1.guards.String,
        "name": ts_autoguard_1.guards.String,
        "username": ts_autoguard_1.guards.String,
        "password": ts_autoguard_1.guards.String
    });
    exports.Key = ts_autoguard_1.guards.Object.of({
        "key_id": ts_autoguard_1.guards.String,
        "user_id": ts_autoguard_1.guards.Union.of(ts_autoguard_1.guards.Undefined, ts_autoguard_1.guards.String)
    });
    exports.Token = ts_autoguard_1.guards.Object.of({
        "token_id": ts_autoguard_1.guards.String,
        "user_id": ts_autoguard_1.guards.String,
        "hash": ts_autoguard_1.guards.String,
        "expires_ms": ts_autoguard_1.guards.Number
    });
    exports.Stream = ts_autoguard_1.guards.Object.of({
        "stream_id": ts_autoguard_1.guards.String,
        "user_id": ts_autoguard_1.guards.String,
        "file_id": ts_autoguard_1.guards.String,
        "timestamp_ms": ts_autoguard_1.guards.Number
    });
    exports.Playlist = ts_autoguard_1.guards.Object.of({
        "playlist_id": ts_autoguard_1.guards.String,
        "title": ts_autoguard_1.guards.String,
        "description": ts_autoguard_1.guards.String,
        "user_id": ts_autoguard_1.guards.String
    });
    exports.PlaylistItem = ts_autoguard_1.guards.Object.of({
        "playlist_item_id": ts_autoguard_1.guards.String,
        "playlist_id": ts_autoguard_1.guards.String,
        "track_id": ts_autoguard_1.guards.String,
        "number": ts_autoguard_1.guards.Number,
        "added_ms": ts_autoguard_1.guards.Number
    });
    exports.Year = ts_autoguard_1.guards.Object.of({
        "year_id": ts_autoguard_1.guards.String,
        "year": ts_autoguard_1.guards.Number
    });
    exports.Autoguard = {
        "Directory": exports.Directory,
        "File": exports.File,
        "AudioFile": exports.AudioFile,
        "ImageFile": exports.ImageFile,
        "MetadataFile": exports.MetadataFile,
        "SubtitleFile": exports.SubtitleFile,
        "VideoFile": exports.VideoFile,
        "VideoSubtitle": exports.VideoSubtitle,
        "Artist": exports.Artist,
        "Album": exports.Album,
        "AlbumFile": exports.AlbumFile,
        "Disc": exports.Disc,
        "Track": exports.Track,
        "TrackFile": exports.TrackFile,
        "AlbumArtist": exports.AlbumArtist,
        "TrackArtist": exports.TrackArtist,
        "Show": exports.Show,
        "ShowFile": exports.ShowFile,
        "Season": exports.Season,
        "Episode": exports.Episode,
        "EpisodeFile": exports.EpisodeFile,
        "Movie": exports.Movie,
        "MovieFile": exports.MovieFile,
        "Actor": exports.Actor,
        "MovieActor": exports.MovieActor,
        "ShowActor": exports.ShowActor,
        "Genre": exports.Genre,
        "MovieGenre": exports.MovieGenre,
        "ShowGenre": exports.ShowGenre,
        "Subtitle": exports.Subtitle,
        "Cue": exports.Cue,
        "User": exports.User,
        "Key": exports.Key,
        "Token": exports.Token,
        "Stream": exports.Stream,
        "Playlist": exports.Playlist,
        "PlaylistItem": exports.PlaylistItem,
        "Year": exports.Year
    };
});
define("build/api/schema/objects", ["require", "exports", "build/database/schema", "build/database/schema", "build/database/schema", "build/database/schema", "node_modules/@joelek/ts-autoguard/build/autoguard-lib/index"], function (require, exports, schema_1, schema_2, schema_3, schema_4, ts_autoguard_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.Entity = exports.EntityBase = exports.Year = exports.YearBase = exports.Cue = exports.CueBase = exports.Subtitle = exports.SubtitleBase = exports.Episode = exports.EpisodeBase = exports.Season = exports.SeasonBase = exports.Show = exports.ShowBase = exports.Movie = exports.MovieBase = exports.Genre = exports.GenreBase = exports.PlaylistItem = exports.PlaylistItemBase = exports.Playlist = exports.PlaylistBase = exports.User = exports.UserBase = exports.Track = exports.TrackBase = exports.Disc = exports.DiscBase = exports.Album = exports.AlbumBase = exports.Artist = exports.ArtistBase = exports.Actor = exports.ActorBase = void 0;
    exports.ActorBase = ts_autoguard_2.guards.Object.of({
        "actor_id": ts_autoguard_2.guards.String,
        "name": ts_autoguard_2.guards.String
    });
    exports.Actor = ts_autoguard_2.guards.Intersection.of(ts_autoguard_2.guards.Reference.of(() => exports.ActorBase), ts_autoguard_2.guards.Object.of({}));
    exports.ArtistBase = ts_autoguard_2.guards.Object.of({
        "artist_id": ts_autoguard_2.guards.String,
        "title": ts_autoguard_2.guards.String
    });
    exports.Artist = ts_autoguard_2.guards.Intersection.of(ts_autoguard_2.guards.Reference.of(() => exports.ArtistBase), ts_autoguard_2.guards.Object.of({
        "albums": ts_autoguard_2.guards.Array.of(ts_autoguard_2.guards.Reference.of(() => exports.Album))
    }));
    exports.AlbumBase = ts_autoguard_2.guards.Object.of({
        "album_id": ts_autoguard_2.guards.String,
        "title": ts_autoguard_2.guards.String,
        "artwork": ts_autoguard_2.guards.Array.of(ts_autoguard_2.guards.Reference.of(() => schema_2.ImageFile))
    });
    exports.Album = ts_autoguard_2.guards.Intersection.of(ts_autoguard_2.guards.Reference.of(() => exports.AlbumBase), ts_autoguard_2.guards.Object.of({
        "artists": ts_autoguard_2.guards.Array.of(ts_autoguard_2.guards.Reference.of(() => exports.ArtistBase)),
        "discs": ts_autoguard_2.guards.Array.of(ts_autoguard_2.guards.Reference.of(() => exports.Disc)),
        "year": ts_autoguard_2.guards.Union.of(ts_autoguard_2.guards.Undefined, ts_autoguard_2.guards.Number)
    }));
    exports.DiscBase = ts_autoguard_2.guards.Object.of({
        "disc_id": ts_autoguard_2.guards.String,
        "album": ts_autoguard_2.guards.Reference.of(() => exports.AlbumBase),
        "number": ts_autoguard_2.guards.Number
    });
    exports.Disc = ts_autoguard_2.guards.Intersection.of(ts_autoguard_2.guards.Reference.of(() => exports.DiscBase), ts_autoguard_2.guards.Object.of({
        "tracks": ts_autoguard_2.guards.Array.of(ts_autoguard_2.guards.Reference.of(() => exports.Track))
    }));
    exports.TrackBase = ts_autoguard_2.guards.Object.of({
        "track_id": ts_autoguard_2.guards.String,
        "title": ts_autoguard_2.guards.String,
        "disc": ts_autoguard_2.guards.Reference.of(() => exports.DiscBase),
        "number": ts_autoguard_2.guards.Number
    });
    exports.Track = ts_autoguard_2.guards.Intersection.of(ts_autoguard_2.guards.Reference.of(() => exports.TrackBase), ts_autoguard_2.guards.Object.of({
        "artists": ts_autoguard_2.guards.Array.of(ts_autoguard_2.guards.Reference.of(() => exports.ArtistBase)),
        "last_stream_date": ts_autoguard_2.guards.Union.of(ts_autoguard_2.guards.Undefined, ts_autoguard_2.guards.Number),
        "media": ts_autoguard_2.guards.Reference.of(() => schema_1.AudioFile)
    }));
    exports.UserBase = ts_autoguard_2.guards.Object.of({
        "user_id": ts_autoguard_2.guards.String,
        "name": ts_autoguard_2.guards.String,
        "username": ts_autoguard_2.guards.String
    });
    exports.User = ts_autoguard_2.guards.Intersection.of(ts_autoguard_2.guards.Reference.of(() => exports.UserBase), ts_autoguard_2.guards.Object.of({}));
    exports.PlaylistBase = ts_autoguard_2.guards.Object.of({
        "playlist_id": ts_autoguard_2.guards.String,
        "title": ts_autoguard_2.guards.String,
        "description": ts_autoguard_2.guards.String,
        "user": ts_autoguard_2.guards.Reference.of(() => exports.UserBase)
    });
    exports.Playlist = ts_autoguard_2.guards.Intersection.of(ts_autoguard_2.guards.Reference.of(() => exports.PlaylistBase), ts_autoguard_2.guards.Object.of({
        "items": ts_autoguard_2.guards.Array.of(ts_autoguard_2.guards.Reference.of(() => exports.PlaylistItem))
    }));
    exports.PlaylistItemBase = ts_autoguard_2.guards.Object.of({
        "playlist_item_id": ts_autoguard_2.guards.String,
        "number": ts_autoguard_2.guards.Number,
        "playlist": ts_autoguard_2.guards.Reference.of(() => exports.PlaylistBase),
        "track": ts_autoguard_2.guards.Reference.of(() => exports.Track)
    });
    exports.PlaylistItem = ts_autoguard_2.guards.Intersection.of(ts_autoguard_2.guards.Reference.of(() => exports.PlaylistItemBase), ts_autoguard_2.guards.Object.of({}));
    exports.GenreBase = ts_autoguard_2.guards.Object.of({
        "genre_id": ts_autoguard_2.guards.String,
        "title": ts_autoguard_2.guards.String
    });
    exports.Genre = ts_autoguard_2.guards.Intersection.of(ts_autoguard_2.guards.Reference.of(() => exports.GenreBase), ts_autoguard_2.guards.Object.of({}));
    exports.MovieBase = ts_autoguard_2.guards.Object.of({
        "movie_id": ts_autoguard_2.guards.String,
        "title": ts_autoguard_2.guards.String,
        "artwork": ts_autoguard_2.guards.Array.of(ts_autoguard_2.guards.Reference.of(() => schema_2.ImageFile))
    });
    exports.Movie = ts_autoguard_2.guards.Intersection.of(ts_autoguard_2.guards.Reference.of(() => exports.MovieBase), ts_autoguard_2.guards.Object.of({
        "year": ts_autoguard_2.guards.Union.of(ts_autoguard_2.guards.Undefined, ts_autoguard_2.guards.Number),
        "summary": ts_autoguard_2.guards.Union.of(ts_autoguard_2.guards.Undefined, ts_autoguard_2.guards.String),
        "genres": ts_autoguard_2.guards.Array.of(ts_autoguard_2.guards.Reference.of(() => exports.Genre)),
        "actors": ts_autoguard_2.guards.Array.of(ts_autoguard_2.guards.Reference.of(() => exports.Actor)),
        "last_stream_date": ts_autoguard_2.guards.Union.of(ts_autoguard_2.guards.Undefined, ts_autoguard_2.guards.Number),
        "media": ts_autoguard_2.guards.Reference.of(() => schema_4.VideoFile),
        "subtitles": ts_autoguard_2.guards.Array.of(ts_autoguard_2.guards.Reference.of(() => schema_3.SubtitleFile))
    }));
    exports.ShowBase = ts_autoguard_2.guards.Object.of({
        "show_id": ts_autoguard_2.guards.String,
        "title": ts_autoguard_2.guards.String,
        "artwork": ts_autoguard_2.guards.Array.of(ts_autoguard_2.guards.Reference.of(() => schema_2.ImageFile))
    });
    exports.Show = ts_autoguard_2.guards.Intersection.of(ts_autoguard_2.guards.Reference.of(() => exports.ShowBase), ts_autoguard_2.guards.Object.of({
        "summary": ts_autoguard_2.guards.Union.of(ts_autoguard_2.guards.Undefined, ts_autoguard_2.guards.String),
        "genres": ts_autoguard_2.guards.Array.of(ts_autoguard_2.guards.Reference.of(() => exports.Genre)),
        "actors": ts_autoguard_2.guards.Array.of(ts_autoguard_2.guards.Reference.of(() => exports.Actor)),
        "seasons": ts_autoguard_2.guards.Array.of(ts_autoguard_2.guards.Reference.of(() => exports.Season))
    }));
    exports.SeasonBase = ts_autoguard_2.guards.Object.of({
        "season_id": ts_autoguard_2.guards.String,
        "number": ts_autoguard_2.guards.Number,
        "show": ts_autoguard_2.guards.Reference.of(() => exports.ShowBase)
    });
    exports.Season = ts_autoguard_2.guards.Intersection.of(ts_autoguard_2.guards.Reference.of(() => exports.SeasonBase), ts_autoguard_2.guards.Object.of({
        "episodes": ts_autoguard_2.guards.Array.of(ts_autoguard_2.guards.Reference.of(() => exports.Episode))
    }));
    exports.EpisodeBase = ts_autoguard_2.guards.Object.of({
        "episode_id": ts_autoguard_2.guards.String,
        "title": ts_autoguard_2.guards.String,
        "number": ts_autoguard_2.guards.Number,
        "season": ts_autoguard_2.guards.Reference.of(() => exports.SeasonBase)
    });
    exports.Episode = ts_autoguard_2.guards.Intersection.of(ts_autoguard_2.guards.Reference.of(() => exports.EpisodeBase), ts_autoguard_2.guards.Object.of({
        "year": ts_autoguard_2.guards.Union.of(ts_autoguard_2.guards.Undefined, ts_autoguard_2.guards.Number),
        "summary": ts_autoguard_2.guards.Union.of(ts_autoguard_2.guards.Undefined, ts_autoguard_2.guards.String),
        "last_stream_date": ts_autoguard_2.guards.Union.of(ts_autoguard_2.guards.Undefined, ts_autoguard_2.guards.Number),
        "media": ts_autoguard_2.guards.Reference.of(() => schema_4.VideoFile),
        "subtitles": ts_autoguard_2.guards.Array.of(ts_autoguard_2.guards.Reference.of(() => schema_3.SubtitleFile))
    }));
    exports.SubtitleBase = ts_autoguard_2.guards.Object.of({
        "subtitle_id": ts_autoguard_2.guards.String,
        "subtitle": ts_autoguard_2.guards.Reference.of(() => schema_3.SubtitleFile)
    });
    exports.Subtitle = ts_autoguard_2.guards.Intersection.of(ts_autoguard_2.guards.Reference.of(() => exports.SubtitleBase), ts_autoguard_2.guards.Object.of({
        "cues": ts_autoguard_2.guards.Array.of(ts_autoguard_2.guards.Reference.of(() => exports.Cue))
    }));
    exports.CueBase = ts_autoguard_2.guards.Object.of({
        "cue_id": ts_autoguard_2.guards.String,
        "subtitle": ts_autoguard_2.guards.Reference.of(() => exports.SubtitleBase),
        "start_ms": ts_autoguard_2.guards.Number,
        "duration_ms": ts_autoguard_2.guards.Number,
        "lines": ts_autoguard_2.guards.Array.of(ts_autoguard_2.guards.String)
    });
    exports.Cue = ts_autoguard_2.guards.Intersection.of(ts_autoguard_2.guards.Reference.of(() => exports.CueBase), ts_autoguard_2.guards.Object.of({
        "media": ts_autoguard_2.guards.Union.of(ts_autoguard_2.guards.Reference.of(() => exports.Episode), ts_autoguard_2.guards.Reference.of(() => exports.Movie))
    }));
    exports.YearBase = ts_autoguard_2.guards.Object.of({
        "year_id": ts_autoguard_2.guards.String,
        "year": ts_autoguard_2.guards.Number
    });
    exports.Year = ts_autoguard_2.guards.Intersection.of(ts_autoguard_2.guards.Reference.of(() => exports.YearBase), ts_autoguard_2.guards.Object.of({}));
    exports.EntityBase = ts_autoguard_2.guards.Union.of(ts_autoguard_2.guards.Reference.of(() => exports.ActorBase), ts_autoguard_2.guards.Reference.of(() => exports.AlbumBase), ts_autoguard_2.guards.Reference.of(() => exports.ArtistBase), ts_autoguard_2.guards.Reference.of(() => exports.CueBase), ts_autoguard_2.guards.Reference.of(() => exports.DiscBase), ts_autoguard_2.guards.Reference.of(() => exports.EpisodeBase), ts_autoguard_2.guards.Reference.of(() => exports.GenreBase), ts_autoguard_2.guards.Reference.of(() => exports.MovieBase), ts_autoguard_2.guards.Reference.of(() => exports.PlaylistBase), ts_autoguard_2.guards.Reference.of(() => exports.SeasonBase), ts_autoguard_2.guards.Reference.of(() => exports.ShowBase), ts_autoguard_2.guards.Reference.of(() => exports.TrackBase), ts_autoguard_2.guards.Reference.of(() => exports.UserBase), ts_autoguard_2.guards.Reference.of(() => exports.YearBase));
    exports.Entity = ts_autoguard_2.guards.Union.of(ts_autoguard_2.guards.Reference.of(() => exports.Actor), ts_autoguard_2.guards.Reference.of(() => exports.Album), ts_autoguard_2.guards.Reference.of(() => exports.Artist), ts_autoguard_2.guards.Reference.of(() => exports.Cue), ts_autoguard_2.guards.Reference.of(() => exports.Disc), ts_autoguard_2.guards.Reference.of(() => exports.Episode), ts_autoguard_2.guards.Reference.of(() => exports.Genre), ts_autoguard_2.guards.Reference.of(() => exports.Movie), ts_autoguard_2.guards.Reference.of(() => exports.Playlist), ts_autoguard_2.guards.Reference.of(() => exports.Season), ts_autoguard_2.guards.Reference.of(() => exports.Show), ts_autoguard_2.guards.Reference.of(() => exports.Track), ts_autoguard_2.guards.Reference.of(() => exports.User), ts_autoguard_2.guards.Reference.of(() => exports.Year));
    exports.Autoguard = {
        "ActorBase": exports.ActorBase,
        "Actor": exports.Actor,
        "ArtistBase": exports.ArtistBase,
        "Artist": exports.Artist,
        "AlbumBase": exports.AlbumBase,
        "Album": exports.Album,
        "DiscBase": exports.DiscBase,
        "Disc": exports.Disc,
        "TrackBase": exports.TrackBase,
        "Track": exports.Track,
        "UserBase": exports.UserBase,
        "User": exports.User,
        "PlaylistBase": exports.PlaylistBase,
        "Playlist": exports.Playlist,
        "PlaylistItemBase": exports.PlaylistItemBase,
        "PlaylistItem": exports.PlaylistItem,
        "GenreBase": exports.GenreBase,
        "Genre": exports.Genre,
        "MovieBase": exports.MovieBase,
        "Movie": exports.Movie,
        "ShowBase": exports.ShowBase,
        "Show": exports.Show,
        "SeasonBase": exports.SeasonBase,
        "Season": exports.Season,
        "EpisodeBase": exports.EpisodeBase,
        "Episode": exports.Episode,
        "SubtitleBase": exports.SubtitleBase,
        "Subtitle": exports.Subtitle,
        "CueBase": exports.CueBase,
        "Cue": exports.Cue,
        "YearBase": exports.YearBase,
        "Year": exports.Year,
        "EntityBase": exports.EntityBase,
        "Entity": exports.Entity
    };
});
define("build/player/schema/objects", ["require", "exports", "build/api/schema/objects", "build/api/schema/objects", "build/api/schema/objects", "build/api/schema/objects", "build/api/schema/objects", "build/api/schema/objects", "build/api/schema/objects", "build/api/schema/objects", "build/api/schema/objects", "node_modules/@joelek/ts-autoguard/build/autoguard-lib/index"], function (require, exports, objects_1, objects_2, objects_3, objects_4, objects_5, objects_6, objects_7, objects_8, objects_9, ts_autoguard_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.Session = exports.Device = exports.ContextItem = exports.Context = exports.ContextEpisode = exports.ContextSeason = exports.ContextShow = exports.ContextMovie = exports.ContextPlaylist = exports.ContextTrack = exports.ContextDisc = exports.ContextArtist = exports.ContextAlbum = void 0;
    exports.ContextAlbum = ts_autoguard_3.guards.Reference.of(() => objects_1.Album);
    exports.ContextArtist = ts_autoguard_3.guards.Reference.of(() => objects_2.Artist);
    exports.ContextDisc = ts_autoguard_3.guards.Reference.of(() => objects_3.Disc);
    exports.ContextTrack = ts_autoguard_3.guards.Reference.of(() => objects_9.Track);
    exports.ContextPlaylist = ts_autoguard_3.guards.Reference.of(() => objects_6.Playlist);
    exports.ContextMovie = ts_autoguard_3.guards.Reference.of(() => objects_5.Movie);
    exports.ContextShow = ts_autoguard_3.guards.Reference.of(() => objects_8.Show);
    exports.ContextSeason = ts_autoguard_3.guards.Reference.of(() => objects_7.Season);
    exports.ContextEpisode = ts_autoguard_3.guards.Reference.of(() => objects_4.Episode);
    exports.Context = ts_autoguard_3.guards.Union.of(ts_autoguard_3.guards.Reference.of(() => exports.ContextAlbum), ts_autoguard_3.guards.Reference.of(() => exports.ContextArtist), ts_autoguard_3.guards.Reference.of(() => exports.ContextDisc), ts_autoguard_3.guards.Reference.of(() => exports.ContextTrack), ts_autoguard_3.guards.Reference.of(() => exports.ContextPlaylist), ts_autoguard_3.guards.Reference.of(() => exports.ContextMovie), ts_autoguard_3.guards.Reference.of(() => exports.ContextShow), ts_autoguard_3.guards.Reference.of(() => exports.ContextSeason), ts_autoguard_3.guards.Reference.of(() => exports.ContextEpisode));
    exports.ContextItem = ts_autoguard_3.guards.Union.of(ts_autoguard_3.guards.Reference.of(() => exports.ContextTrack), ts_autoguard_3.guards.Reference.of(() => exports.ContextMovie), ts_autoguard_3.guards.Reference.of(() => exports.ContextEpisode));
    exports.Device = ts_autoguard_3.guards.Object.of({
        "id": ts_autoguard_3.guards.String,
        "protocol": ts_autoguard_3.guards.String,
        "name": ts_autoguard_3.guards.String,
        "type": ts_autoguard_3.guards.String
    });
    exports.Session = ts_autoguard_3.guards.Object.of({
        "context": ts_autoguard_3.guards.Union.of(ts_autoguard_3.guards.Undefined, ts_autoguard_3.guards.Reference.of(() => exports.Context)),
        "device": ts_autoguard_3.guards.Union.of(ts_autoguard_3.guards.Undefined, ts_autoguard_3.guards.Reference.of(() => exports.Device)),
        "index": ts_autoguard_3.guards.Union.of(ts_autoguard_3.guards.Undefined, ts_autoguard_3.guards.Number),
        "playback": ts_autoguard_3.guards.Boolean,
        "progress": ts_autoguard_3.guards.Union.of(ts_autoguard_3.guards.Undefined, ts_autoguard_3.guards.Number)
    });
    exports.Autoguard = {
        "ContextAlbum": exports.ContextAlbum,
        "ContextArtist": exports.ContextArtist,
        "ContextDisc": exports.ContextDisc,
        "ContextTrack": exports.ContextTrack,
        "ContextPlaylist": exports.ContextPlaylist,
        "ContextMovie": exports.ContextMovie,
        "ContextShow": exports.ContextShow,
        "ContextSeason": exports.ContextSeason,
        "ContextEpisode": exports.ContextEpisode,
        "Context": exports.Context,
        "ContextItem": exports.ContextItem,
        "Device": exports.Device,
        "Session": exports.Session
    };
});
define("build/player/schema/messages", ["require", "exports", "build/player/schema/objects", "build/player/schema/objects", "node_modules/@joelek/ts-autoguard/build/autoguard-lib/index"], function (require, exports, objects_10, objects_11, ts_autoguard_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.SetToken = exports.SetProgress = exports.SetPlayback = exports.SetLocalDevice = exports.SetIndex = exports.SetDevices = exports.SetDevice = exports.SetContext = void 0;
    exports.SetContext = ts_autoguard_4.guards.Object.of({
        "context": ts_autoguard_4.guards.Union.of(ts_autoguard_4.guards.Undefined, ts_autoguard_4.guards.Reference.of(() => objects_10.Context))
    });
    exports.SetDevice = ts_autoguard_4.guards.Object.of({
        "device": ts_autoguard_4.guards.Union.of(ts_autoguard_4.guards.Undefined, ts_autoguard_4.guards.Reference.of(() => objects_11.Device))
    });
    exports.SetDevices = ts_autoguard_4.guards.Object.of({
        "devices": ts_autoguard_4.guards.Array.of(ts_autoguard_4.guards.Reference.of(() => objects_11.Device))
    });
    exports.SetIndex = ts_autoguard_4.guards.Object.of({
        "index": ts_autoguard_4.guards.Union.of(ts_autoguard_4.guards.Undefined, ts_autoguard_4.guards.Number)
    });
    exports.SetLocalDevice = ts_autoguard_4.guards.Object.of({
        "device": ts_autoguard_4.guards.Reference.of(() => objects_11.Device)
    });
    exports.SetPlayback = ts_autoguard_4.guards.Object.of({
        "playback": ts_autoguard_4.guards.Boolean
    });
    exports.SetProgress = ts_autoguard_4.guards.Object.of({
        "progress": ts_autoguard_4.guards.Union.of(ts_autoguard_4.guards.Undefined, ts_autoguard_4.guards.Number)
    });
    exports.SetToken = ts_autoguard_4.guards.Object.of({
        "token": ts_autoguard_4.guards.Union.of(ts_autoguard_4.guards.Undefined, ts_autoguard_4.guards.String)
    });
    exports.Autoguard = {
        "SetContext": exports.SetContext,
        "SetDevice": exports.SetDevice,
        "SetDevices": exports.SetDevices,
        "SetIndex": exports.SetIndex,
        "SetLocalDevice": exports.SetLocalDevice,
        "SetPlayback": exports.SetPlayback,
        "SetProgress": exports.SetProgress,
        "SetToken": exports.SetToken
    };
});
define("build/player/schema/index", ["require", "exports", "build/player/schema/messages", "build/player/schema/objects"], function (require, exports, messages, objects) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.objects = exports.messages = void 0;
    exports.messages = messages;
    exports.objects = objects;
});
define("node_modules/@joelek/ts-stdlib/build/routing/index", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NamespacedMessageRouter = exports.MessageRouter = void 0;
    class MessageRouter {
        constructor() {
            this.observers = new Map();
        }
        addObserver(type, observer) {
            let observers = this.observers.get(type);
            if (observers === undefined) {
                observers = new Set();
                this.observers.set(type, observers);
            }
            observers.add(observer);
        }
        removeObserver(type, observer) {
            let observers = this.observers.get(type);
            if (observers !== undefined) {
                observers.delete(observer);
            }
        }
        route(type, message) {
            let observers = this.observers.get(type);
            if (observers !== undefined) {
                for (let observer of observers) {
                    observer(message);
                }
            }
        }
    }
    exports.MessageRouter = MessageRouter;
    ;
    class NamespacedMessageRouter {
        constructor() {
            this.routers = new Map();
        }
        addObserver(namespace, type, observer) {
            let router = this.routers.get(namespace);
            if (router === undefined) {
                router = new MessageRouter();
                this.routers.set(namespace, router);
            }
            router.addObserver(type, observer);
        }
        removeObserver(namespace, type, observer) {
            let router = this.routers.get(namespace);
            if (router !== undefined) {
                router.removeObserver(type, observer);
            }
        }
        route(namespace, type, message) {
            let router = this.routers.get(namespace);
            if (router !== undefined) {
                router.route(type, message);
            }
        }
    }
    exports.NamespacedMessageRouter = NamespacedMessageRouter;
    ;
});
define("node_modules/@joelek/ts-stdlib/build/index", ["require", "exports", "node_modules/@joelek/ts-stdlib/build/routing/index"], function (require, exports, routing) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.routing = void 0;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.routing = routing;
});
define("node_modules/@joelek/ts-sockets/build/shared", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StatusCode = exports.ReadyState = void 0;
    var ReadyState;
    (function (ReadyState) {
        ReadyState[ReadyState["CONNECTING"] = 0] = "CONNECTING";
        ReadyState[ReadyState["OPEN"] = 1] = "OPEN";
        ReadyState[ReadyState["CLOSING"] = 2] = "CLOSING";
        ReadyState[ReadyState["CLOSED"] = 3] = "CLOSED";
    })(ReadyState = exports.ReadyState || (exports.ReadyState = {}));
    ;
    var StatusCode;
    (function (StatusCode) {
        StatusCode[StatusCode["NORMAL"] = 1000] = "NORMAL";
        StatusCode[StatusCode["GOING_AWAY"] = 1001] = "GOING_AWAY";
        StatusCode[StatusCode["PROTOCOL_ERROR"] = 1002] = "PROTOCOL_ERROR";
        StatusCode[StatusCode["DATA_TYPE_NOT_ACCEPTED"] = 1003] = "DATA_TYPE_NOT_ACCEPTED";
        StatusCode[StatusCode["RESERVED_1004"] = 1004] = "RESERVED_1004";
        StatusCode[StatusCode["RESERVED_1005"] = 1005] = "RESERVED_1005";
        StatusCode[StatusCode["RESERVED_1006"] = 1006] = "RESERVED_1006";
        StatusCode[StatusCode["BAD_DATA_TYPE"] = 1007] = "BAD_DATA_TYPE";
        StatusCode[StatusCode["POLICY_VIOLATION"] = 1008] = "POLICY_VIOLATION";
        StatusCode[StatusCode["MESSAGE_TOO_BIG"] = 1009] = "MESSAGE_TOO_BIG";
        StatusCode[StatusCode["CLIENT_EXPECTED_EXTENSION"] = 1010] = "CLIENT_EXPECTED_EXTENSION";
        StatusCode[StatusCode["SERVER_UNEXPECTED_CONDITION"] = 1011] = "SERVER_UNEXPECTED_CONDITION";
        StatusCode[StatusCode["RESERVED_1015"] = 1015] = "RESERVED_1015";
    })(StatusCode = exports.StatusCode || (exports.StatusCode = {}));
    ;
});
define("build/typesockets/schema", ["require", "exports", "node_modules/@joelek/ts-autoguard/build/autoguard-lib/index"], function (require, exports, ts_autoguard_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.Envelope = void 0;
    exports.Envelope = ts_autoguard_5.guards.Object.of({
        "type": ts_autoguard_5.guards.String,
        "data": ts_autoguard_5.guards.Any,
        "id": ts_autoguard_5.guards.Union.of(ts_autoguard_5.guards.Undefined, ts_autoguard_5.guards.String)
    });
    exports.Autoguard = {
        "Envelope": exports.Envelope
    };
});
define("build/typesockets/shared", ["require", "exports", "build/typesockets/schema", "build/is"], function (require, exports, schema, is) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Serializer = void 0;
    class Serializer {
        constructor(guards) {
            this.guards = guards;
        }
        deserialize(string, cb) {
            let envelope = schema.Envelope.as(JSON.parse(string));
            let id = envelope.id;
            let type = envelope.type;
            let data = envelope.data;
            let guard = this.guards[type];
            if (is.absent(guard)) {
                throw `Unknown message type "${type}"!`;
            }
            cb(type, guard.as(data), id);
        }
        serialize(type, data, id) {
            return JSON.stringify({
                type,
                data,
                id
            });
        }
    }
    exports.Serializer = Serializer;
    ;
});
define("build/typesockets/client", ["require", "exports", "node_modules/@joelek/ts-stdlib/build/index", "node_modules/@joelek/ts-sockets/build/shared", "build/typesockets/shared", "build/is"], function (require, exports, stdlib, sockets, shared, is) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TypeSocketClient = void 0;
    ;
    class TypeSocketClient {
        constructor(url, factory, guards) {
            this.nextConnectionAttemptDelayFactor = 2.0 + Math.random();
            this.nextConnectionAttemptDelay = 2000;
            this.router = new stdlib.routing.NamespacedMessageRouter();
            this.serializer = new shared.Serializer(guards);
            this.url = url;
            this.factory = factory;
            this.socket = this.makeSocket();
            this.requests = new Map();
        }
        makeId() {
            let string = "";
            for (let i = 0; i < 32; i++) {
                let number = Math.floor(Math.random() * 16);
                string += number.toString(16);
            }
            return string;
        }
        makeSocket() {
            let socket = this.factory(this.url);
            socket.addEventListener("close", this.onClose.bind(this));
            socket.addEventListener("error", this.onError.bind(this));
            socket.addEventListener("message", this.onMessage.bind(this));
            socket.addEventListener("open", this.onOpen.bind(this));
            return socket;
        }
        onClose(event) {
            this.router.route("sys", "disconnect", {});
        }
        onError(event) {
            setTimeout(() => {
                this.socket = this.makeSocket();
            }, this.nextConnectionAttemptDelay);
            this.nextConnectionAttemptDelay = Math.round(this.nextConnectionAttemptDelay * this.nextConnectionAttemptDelayFactor);
        }
        onMessage(event) {
            try {
                this.serializer.deserialize(event.data, (type, data, id) => {
                    this.router.route("sys", "message", {
                        type,
                        data
                    });
                    if (is.present(id)) {
                        let callback = this.requests.get(id);
                        if (is.present(callback)) {
                            this.requests.delete(id);
                            callback(type, data);
                        }
                    }
                    this.router.route("app", type, data);
                });
            }
            catch (error) {
                this.socket.close();
            }
        }
        onOpen(event) {
            this.nextConnectionAttemptDelay = 2000;
            this.router.route("sys", "connect", {});
        }
        queue(payload) {
            if (this.socket.readyState === sockets.ReadyState.OPEN) {
                this.socket.send(payload);
            }
            else {
                let onopen = () => {
                    this.socket.removeEventListener("open", onopen);
                    this.socket.send(payload);
                };
                this.socket.addEventListener("open", onopen);
            }
        }
        addEventListener(namespace, type, listener) {
            this.router.addObserver(namespace, type, listener);
        }
        close() {
            this.socket.close();
        }
        reconnect() {
            if (this.socket.readyState === sockets.ReadyState.CLOSED) {
                this.socket = this.makeSocket();
            }
        }
        removeEventListener(namespace, type, listener) {
            this.router.addObserver(namespace, type, listener);
        }
        request(type, response_type, data) {
            return new Promise((resolve, reject) => {
                let id = this.makeId();
                let payload = this.serializer.serialize(type, data, id);
                this.requests.set(id, (type, data) => {
                    if (type !== response_type) {
                        reject(`Received response with type "${type}" when expecting "${response_type}"!`);
                    }
                    else {
                        resolve(data);
                    }
                });
                this.queue(payload);
            });
        }
        send(type, data) {
            let payload = this.serializer.serialize(type, data);
            this.queue(payload);
        }
    }
    exports.TypeSocketClient = TypeSocketClient;
    ;
});
define("build/player/client", ["require", "exports", "build/is", "build/observers/index", "build/player/schema/index", "build/typesockets/client"], function (require, exports, is, observers, schema, typesockets) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ContextClient = void 0;
    class ContextClient {
        constructor(url, factory = (url) => new WebSocket(url)) {
            this.estimatedProgress = new observers.ObservableClass(undefined);
            this.estimatedProgressTimestamp = new observers.ObservableClass(undefined);
            this.token = new observers.ObservableClass(undefined);
            this.localDevice = new observers.ObservableClass(undefined);
            this.devices = new observers.ArrayObservable(new Array());
            this.device = new observers.ObservableClass(undefined);
            this.isDeviceLocal = new observers.ObservableClass(false);
            this.isDeviceRemote = new observers.ObservableClass(false);
            this.context = new observers.ObservableClass(undefined);
            this.contextPath = new observers.ObservableClass(undefined);
            this.flattenedContext = new observers.ObservableClass(undefined);
            this.lastIndex = new observers.ObservableClass(undefined);
            this.lastEntry = new observers.ObservableClass(undefined);
            this.lastLocalEntry = new observers.ObservableClass(undefined);
            this.currentIndex = new observers.ObservableClass(undefined);
            this.currentEntry = new observers.ObservableClass(undefined);
            this.currentLocalEntry = new observers.ObservableClass(undefined);
            this.nextIndex = new observers.ObservableClass(undefined);
            this.nextEntry = new observers.ObservableClass(undefined);
            this.nextLocalEntry = new observers.ObservableClass(undefined);
            this.playback = new observers.ObservableClass(false);
            this.progress = new observers.ObservableClass(undefined);
            this.localPlayback = new observers.ObservableClass(false);
            this.canPlayLast = new observers.ObservableClass(false);
            this.canPlayCurrent = new observers.ObservableClass(false);
            this.canPlayNext = new observers.ObservableClass(false);
            this.isCurrentEntryVideo = new observers.ObservableClass(false);
            this.isOnline = new observers.ObservableClass(false);
            this.tsc = new typesockets.TypeSocketClient(url, factory, schema.messages.Autoguard);
            this.tsc.addEventListener("sys", "connect", () => {
                this.isOnline.updateState(true);
            });
            this.tsc.addEventListener("sys", "disconnect", () => {
                this.isOnline.updateState(false);
            });
            this.context.addObserver((context) => {
                if (is.present(context)) {
                    if (schema.objects.ContextAlbum.is(context)) {
                        let files = [];
                        let album = context;
                        for (let disc of album.discs) {
                            files.push(...disc.tracks);
                        }
                        this.flattenedContext.updateState(files);
                    }
                    else if (schema.objects.ContextArtist.is(context)) {
                        let files = [];
                        let artist = context;
                        for (let album of artist.albums) {
                            for (let disc of album.discs) {
                                files.push(...disc.tracks);
                            }
                        }
                        this.flattenedContext.updateState(files);
                    }
                    else if (schema.objects.ContextEpisode.is(context)) {
                        let files = [];
                        let episode = context;
                        files.push(episode);
                        this.flattenedContext.updateState(files);
                    }
                    else if (schema.objects.ContextMovie.is(context)) {
                        let files = [];
                        let movie = context;
                        files.push(movie);
                        this.flattenedContext.updateState(files);
                    }
                    else if (schema.objects.ContextPlaylist.is(context)) {
                        let files = [];
                        let playlist = context;
                        for (let item of playlist.items) {
                            files.push(item.track);
                        }
                        this.flattenedContext.updateState(files);
                    }
                    else if (schema.objects.ContextSeason.is(context)) {
                        let files = [];
                        let season = context;
                        files.push(...season.episodes);
                        this.flattenedContext.updateState(files);
                    }
                    else if (schema.objects.ContextShow.is(context)) {
                        let files = [];
                        let show = context;
                        for (let season of show.seasons) {
                            files.push(...season.episodes);
                        }
                        this.flattenedContext.updateState(files);
                    }
                    else if (schema.objects.ContextTrack.is(context)) {
                        let files = [];
                        let track = context;
                        files.push(track);
                        this.flattenedContext.updateState(files);
                    }
                    else {
                        throw `Expected code to be unreachable!`;
                    }
                }
            });
            {
                let computer = () => {
                    let context = this.context.getState();
                    let currentIndex = this.currentIndex.getState();
                    if (is.present(context) && is.present(currentIndex)) {
                        if (schema.objects.ContextAlbum.is(context)) {
                            let discIndex = 0;
                            let trackIndex = currentIndex;
                            let album = context;
                            let discs = album.discs;
                            for (let d = 0; d < discs.length; d++) {
                                let length = discs[d].tracks.length;
                                if (trackIndex >= length) {
                                    discIndex += 1;
                                    trackIndex -= length;
                                }
                                else {
                                    break;
                                }
                            }
                            return this.contextPath.updateState([
                                context.album_id,
                                context.discs[discIndex].disc_id,
                                context.discs[discIndex].tracks[trackIndex].track_id
                            ]);
                        }
                        else if (schema.objects.ContextArtist.is(context)) {
                            let albumIndex = 0;
                            let discIndex = 0;
                            let trackIndex = currentIndex;
                            let artist = context;
                            let albums = artist.albums;
                            outer: for (let a = 0; a < albums.length; a++) {
                                let discs = albums[a].discs;
                                for (let d = 0; d < discs.length; d++) {
                                    let length = discs[d].tracks.length;
                                    if (trackIndex >= length) {
                                        discIndex += 1;
                                        trackIndex -= length;
                                    }
                                    else {
                                        break outer;
                                    }
                                }
                                albumIndex += 1;
                                discIndex = 0;
                            }
                            return this.contextPath.updateState([
                                context.artist_id,
                                context.albums[albumIndex].album_id,
                                context.albums[albumIndex].discs[discIndex].disc_id,
                                context.albums[albumIndex].discs[discIndex].tracks[trackIndex].track_id
                            ]);
                        }
                        else if (schema.objects.ContextEpisode.is(context)) {
                            return this.contextPath.updateState([
                                context.episode_id
                            ]);
                        }
                        else if (schema.objects.ContextMovie.is(context)) {
                            return this.contextPath.updateState([
                                context.movie_id
                            ]);
                        }
                        else if (schema.objects.ContextPlaylist.is(context)) {
                            let itemIndex = currentIndex;
                            return this.contextPath.updateState([
                                context.playlist_id,
                                context.items[itemIndex].track.track_id
                            ]);
                        }
                        else if (schema.objects.ContextShow.is(context)) {
                            let seasonIndex = 0;
                            let episodeIndex = currentIndex;
                            let show = context;
                            let seasons = show.seasons;
                            for (let d = 0; d < seasons.length; d++) {
                                let length = seasons[d].episodes.length;
                                if (episodeIndex >= length) {
                                    seasonIndex += 1;
                                    episodeIndex -= length;
                                }
                                else {
                                    break;
                                }
                            }
                            return this.contextPath.updateState([
                                context.show_id,
                                context.seasons[seasonIndex].season_id,
                                context.seasons[seasonIndex].episodes[episodeIndex].episode_id
                            ]);
                        }
                        else if (schema.objects.ContextSeason.is(context)) {
                            let episodeIndex = currentIndex;
                            return this.contextPath.updateState([
                                context.season_id,
                                context.episodes[episodeIndex].episode_id
                            ]);
                        }
                        else if (schema.objects.ContextTrack.is(context)) {
                            return this.contextPath.updateState([
                                context.track_id
                            ]);
                        }
                        else {
                            throw `Expected code to be unreachable!`;
                        }
                    }
                    this.contextPath.updateState(undefined);
                };
                this.context.addObserver(computer);
                this.currentIndex.addObserver(computer);
            }
            this.lastEntry.addObserver((lastEntry) => {
                this.canPlayLast.updateState(is.present(lastEntry));
            });
            this.currentEntry.addObserver((currentEntry) => {
                this.canPlayCurrent.updateState(is.present(currentEntry));
            });
            this.nextEntry.addObserver((nextEntry) => {
                this.canPlayNext.updateState(is.present(nextEntry));
            });
            this.progress.addObserver((progress) => {
                this.estimatedProgress.updateState(progress);
                this.estimatedProgressTimestamp.updateState(Date.now());
            });
            this.playback.addObserver((playback) => {
                let estimatedProgress = this.estimatedProgress.getState();
                let estimatedProgressTimestamp = this.estimatedProgressTimestamp.getState();
                let now = Date.now();
                if (!playback) {
                    if (is.present(estimatedProgress) && is.present(estimatedProgressTimestamp)) {
                        this.estimatedProgress.updateState(estimatedProgress + (now - estimatedProgressTimestamp) / 1000);
                    }
                }
                this.estimatedProgressTimestamp.updateState(now);
            });
            this.estimatedProgress.addObserver((estimatedProgress) => {
                console.log(`Estimated progress to ${estimatedProgress ?? 0}`);
            });
            {
                let computer = () => {
                    let playback = this.playback.getState();
                    let isDeviceLocal = this.isDeviceLocal.getState();
                    this.localPlayback.updateState(isDeviceLocal && playback);
                };
                this.playback.addObserver(computer);
                this.isDeviceLocal.addObserver(computer);
            }
            {
                let computer = () => {
                    let lastEntry = this.lastEntry.getState();
                    let isDeviceLocal = this.isDeviceLocal.getState();
                    this.lastLocalEntry.updateState(isDeviceLocal ? lastEntry : undefined);
                };
                this.lastEntry.addObserver(computer);
                this.isDeviceLocal.addObserver(computer);
            }
            {
                let computer = () => {
                    let currentEntry = this.currentEntry.getState();
                    let isDeviceLocal = this.isDeviceLocal.getState();
                    this.currentLocalEntry.updateState(isDeviceLocal ? currentEntry : undefined);
                };
                this.currentEntry.addObserver(computer);
                this.isDeviceLocal.addObserver(computer);
            }
            {
                let computer = () => {
                    let nextEntry = this.nextEntry.getState();
                    let isDeviceLocal = this.isDeviceLocal.getState();
                    this.nextLocalEntry.updateState(isDeviceLocal ? nextEntry : undefined);
                };
                this.nextEntry.addObserver(computer);
                this.isDeviceLocal.addObserver(computer);
            }
            {
                let computer = () => {
                    let localDevice = this.localDevice.getState();
                    let device = this.device.getState();
                    if (is.present(localDevice) && is.present(device)) {
                        if (localDevice.id === device.id) {
                            return this.isDeviceLocal.updateState(true);
                        }
                    }
                    return this.isDeviceLocal.updateState(false);
                };
                this.localDevice.addObserver(computer);
                this.device.addObserver(computer);
            }
            {
                let computer = () => {
                    let localDevice = this.localDevice.getState();
                    let device = this.device.getState();
                    if (is.present(localDevice) && is.present(device)) {
                        if (localDevice.id !== device.id) {
                            return this.isDeviceRemote.updateState(true);
                        }
                    }
                    return this.isDeviceRemote.updateState(false);
                };
                this.localDevice.addObserver(computer);
                this.device.addObserver(computer);
            }
            {
                let computer = () => {
                    let flattenedContext = this.flattenedContext.getState();
                    let currentIndex = this.currentIndex.getState();
                    if (is.present(flattenedContext) && is.present(currentIndex)) {
                        let index = currentIndex - 1;
                        if (index >= 0 && index < flattenedContext.length) {
                            return this.lastIndex.updateState(index);
                        }
                    }
                    return this.lastIndex.updateState(undefined);
                };
                this.flattenedContext.addObserver(computer);
                this.currentIndex.addObserver(computer);
            }
            {
                let computer = () => {
                    let flattenedContext = this.flattenedContext.getState();
                    let currentIndex = this.currentIndex.getState();
                    if (is.present(flattenedContext) && is.present(currentIndex)) {
                        let index = currentIndex + 1;
                        if (index >= 0 && index < flattenedContext.length) {
                            return this.nextIndex.updateState(index);
                        }
                    }
                    return this.nextIndex.updateState(undefined);
                };
                this.flattenedContext.addObserver(computer);
                this.currentIndex.addObserver(computer);
            }
            {
                let computer = () => {
                    let flattenedContext = this.flattenedContext.getState();
                    let lastIndex = this.lastIndex.getState();
                    if (is.present(flattenedContext) && is.present(lastIndex)) {
                        return this.lastEntry.updateState(flattenedContext[lastIndex]);
                    }
                    return this.lastEntry.updateState(undefined);
                };
                this.flattenedContext.addObserver(computer);
                this.lastIndex.addObserver(computer);
            }
            {
                let computer = () => {
                    let flattenedContext = this.flattenedContext.getState();
                    let contextIndex = this.currentIndex.getState();
                    if (is.present(flattenedContext) && is.present(contextIndex)) {
                        if (contextIndex >= 0 && contextIndex + 0 < flattenedContext.length) {
                            return this.currentEntry.updateState(flattenedContext[contextIndex + 0]);
                        }
                    }
                    return this.currentEntry.updateState(undefined);
                };
                this.flattenedContext.addObserver(computer);
                this.currentIndex.addObserver(computer);
            }
            {
                let computer = () => {
                    let flattenedContext = this.flattenedContext.getState();
                    let nextIndex = this.nextIndex.getState();
                    if (is.present(flattenedContext) && is.present(nextIndex)) {
                        return this.nextEntry.updateState(flattenedContext[nextIndex]);
                    }
                    return this.nextEntry.updateState(undefined);
                };
                this.flattenedContext.addObserver(computer);
                this.nextIndex.addObserver(computer);
            }
            this.tsc.addEventListener("app", "SetLocalDevice", (message) => {
                this.localDevice.updateState(message.device);
            });
            this.tsc.addEventListener("app", "SetDevices", (message) => {
                this.devices.update(message.devices);
            });
            this.tsc.addEventListener("app", "SetContext", (message) => {
                this.context.updateState(message.context);
            });
            this.tsc.addEventListener("app", "SetDevice", (message) => {
                this.device.updateState(message.device);
            });
            this.tsc.addEventListener("app", "SetIndex", (message) => {
                this.currentIndex.updateState(message.index);
            });
            this.tsc.addEventListener("app", "SetPlayback", (message) => {
                this.playback.updateState(message.playback);
            });
            this.tsc.addEventListener("app", "SetProgress", (message) => {
                this.progress.updateState(message.progress);
            });
            this.tsc.addEventListener("app", "SetToken", (message) => {
                this.token.updateState(message.token);
            });
            this.isOnline.addObserver((isOnline) => {
                if (!isOnline) {
                    this.context.updateState(undefined);
                    this.currentIndex.updateState(undefined);
                    this.playback.updateState(false);
                    this.progress.updateState(undefined);
                }
            });
            observers.computed((isOnline, token) => {
                if (isOnline) {
                    this.tsc.send("SetToken", {
                        token
                    });
                }
            }, this.isOnline, this.token);
        }
        play(context, index) {
            this.isCurrentEntryVideo.updateState(false);
            this.tsc.send("SetContext", {
                context
            });
            this.tsc.send("SetIndex", {
                index
            });
            this.tsc.send("SetPlayback", {
                playback: true
            });
        }
        authenticate(token) {
            this.token.updateState(token);
        }
        close() {
            this.tsc.close();
        }
        last() {
            let lastIndex = this.lastIndex.getState();
            if (is.present(lastIndex)) {
                this.currentIndex.updateState(lastIndex);
                this.tsc.send("SetIndex", {
                    index: lastIndex
                });
            }
            else {
                this.pause();
            }
        }
        next() {
            let nextIndex = this.nextIndex.getState();
            if (is.present(nextIndex)) {
                this.currentIndex.updateState(nextIndex);
                this.tsc.send("SetIndex", {
                    index: nextIndex
                });
            }
            else {
                this.pause();
            }
        }
        pause() {
            this.playback.updateState(false);
            this.tsc.send("SetPlayback", {
                playback: false
            });
        }
        playAlbum(album, discIndex, trackIndex) {
            let index = 0;
            if (is.present(discIndex)) {
                let discs = album.discs;
                if (discIndex < 0 || discIndex >= discs.length) {
                    throw `Expected ${discIndex} to be a number between 0 and ${discs.length}!`;
                }
                index += discs.slice(0, discIndex).reduce((sum, disc) => sum + disc.tracks.length, 0);
                if (is.present(trackIndex)) {
                    let tracks = discs[discIndex].tracks;
                    if (trackIndex < 0 || trackIndex >= tracks.length) {
                        throw `Expected ${trackIndex} to be a number between 0 and ${tracks.length}!`;
                    }
                    index += trackIndex;
                }
            }
            return this.play(album, index);
        }
        playArtist(artist, albumIndex, discIndex, trackIndex) {
            let index = 0;
            if (is.present(albumIndex)) {
                let albums = artist.albums;
                if (albumIndex < 0 || albumIndex >= albums.length) {
                    throw `Expected ${albumIndex} to be a number between 0 and ${albums.length}!`;
                }
                index += albums.slice(0, albumIndex).reduce((sum, album) => sum + album.discs.reduce((sum, disc) => sum + disc.tracks.length, 0), 0);
                if (is.present(discIndex)) {
                    let discs = albums[albumIndex].discs;
                    if (discIndex < 0 || discIndex >= discs.length) {
                        throw `Expected ${discIndex} to be a number between 0 and ${discs.length}!`;
                    }
                    index += discs.slice(0, discIndex).reduce((sum, disc) => sum + disc.tracks.length, 0);
                    if (is.present(trackIndex)) {
                        let tracks = discs[discIndex].tracks;
                        if (trackIndex < 0 || trackIndex >= tracks.length) {
                            throw `Expected ${trackIndex} to be a number between 0 and ${tracks.length}!`;
                        }
                        index += trackIndex;
                    }
                }
            }
            return this.play(artist, index);
        }
        playDisc(disc, trackIndex) {
            let index = 0;
            if (is.present(trackIndex)) {
                let tracks = disc.tracks;
                if (trackIndex < 0 || trackIndex >= tracks.length) {
                    throw `Expected ${trackIndex} to be a number between 0 and ${tracks.length}!`;
                }
                index += trackIndex;
            }
            return this.play(disc, index);
        }
        playEpisode(episode) {
            this.play(episode, 0);
        }
        playMovie(movie) {
            this.play(movie, 0);
        }
        playPlaylist(playlist, itemIndex) {
            let index = 0;
            if (is.present(itemIndex)) {
                let items = playlist.items;
                if (itemIndex < 0 || itemIndex >= items.length) {
                    throw `Expected ${itemIndex} to be a number between 0 and ${items.length}!`;
                }
                index += itemIndex;
            }
            return this.play(playlist, index);
        }
        playSeason(season, episodeIndex) {
            let index = 0;
            if (is.present(episodeIndex)) {
                let episodes = season.episodes;
                if (episodeIndex < 0 || episodeIndex >= episodes.length) {
                    throw `Expected ${episodeIndex} to be a number between 0 and ${episodes.length}!`;
                }
                index += episodeIndex;
            }
            return this.play(season, index);
        }
        playShow(show, seasonIndex, episodeIndex) {
            let index = 0;
            if (is.present(seasonIndex)) {
                let seasons = show.seasons;
                if (seasonIndex < 0 || seasonIndex >= seasons.length) {
                    throw `Expected ${seasonIndex} to be a number between 0 and ${seasons.length}!`;
                }
                index += seasons.slice(0, seasonIndex).reduce((sum, season) => sum + season.episodes.length, 0);
                if (is.present(episodeIndex)) {
                    let episodes = seasons[seasonIndex].episodes;
                    if (episodeIndex < 0 || episodeIndex >= episodes.length) {
                        throw `Expected ${episodeIndex} to be a number between 0 and ${episodes.length}!`;
                    }
                    index += episodeIndex;
                }
            }
            return this.play(show, index);
        }
        playTrack(track) {
            this.play(track, 0);
        }
        reconnect() {
            this.tsc.reconnect();
        }
        resume() {
            if (this.canPlayCurrent.getState()) {
                this.playback.updateState(true);
                this.tsc.send("SetPlayback", {
                    playback: true
                });
            }
        }
        seek(progress) {
            this.progress.updateState(progress);
            this.tsc.send("SetProgress", {
                progress: progress
            });
        }
        toggle() {
            if (this.playback.getState()) {
                this.pause();
            }
            else {
                this.resume();
            }
        }
        transfer(device) {
            this.tsc.send("SetDevice", {
                device: device
            });
        }
    }
    exports.ContextClient = ContextClient;
});
define("build/xnode/index", ["require", "exports", "build/is", "build/observers/index"], function (require, exports, is, observers_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.joinarray = exports.text = exports.element = exports.XElement = exports.XText = void 0;
    class XText {
        constructor(content) {
            this.content = content;
        }
        render() {
            let node = document.createTextNode("");
            if (this.content instanceof observers_1.ObservableClass) {
                this.content.addObserver((content) => {
                    node.textContent = content;
                });
            }
            else {
                node.textContent = this.content;
            }
            return node;
        }
    }
    exports.XText = XText;
    class XElement {
        constructor(selector) {
            let parts = selector.split(".");
            this.tag = parts[0];
            this.attributes = new Map();
            this.children = new Array();
            this.bound = new Map();
            this.bound2 = new Map();
            this.listeners = new Map();
            this.resolve = () => { };
            this.element = new Promise((resolve, reject) => {
                this.resolve = resolve;
            });
            let classes = parts.slice(1).join(" ");
            if (classes !== "") {
                this.attributes.set("class", classes);
            }
        }
        add(...nodes) {
            // TODO: Detach node from current parent.
            for (let node of nodes) {
                if (node != null) {
                    this.children.push(node);
                }
            }
            return this;
        }
        bind(key, observable) {
            this.bound.set(key, observable);
            return this;
        }
        bind2(key, observable) {
            this.bound2.set(key, observable);
            return this;
        }
        on(kind, listener, override = true) {
            let listeners = this.listeners.get(kind);
            if (listeners == null) {
                listeners = new Array();
                this.listeners.set(kind, listeners);
            }
            listeners.push((event) => {
                if (override) {
                    event.preventDefault();
                    event.stopPropagation();
                }
                listener(event);
            });
            return this;
        }
        ref() {
            if (is.absent(this.element)) {
                throw `Expected element to be rendered!`;
            }
            return this.element;
        }
        render() {
            let ns = ["svg", "path", "circle"].indexOf(this.tag) >= 0 ? "http://www.w3.org/2000/svg" : "http://www.w3.org/1999/xhtml";
            let element = document.createElementNS(ns, this.tag);
            element.setAttribute = (() => {
                let setAttribute = element.setAttribute.bind(element);
                return (key, value) => {
                    if (key === "src") {
                        let observer = new IntersectionObserver((entries) => {
                            for (let entry of entries) {
                                if (entry.target === element && entry.isIntersecting) {
                                    observer.unobserve(element);
                                    setAttribute(key, value);
                                }
                            }
                        }, { root: document.body });
                        observer.observe(element);
                    }
                    else {
                        setAttribute(key, value);
                    }
                };
            })();
            for (let [kind, listeners] of this.listeners) {
                for (let listener of listeners) {
                    element.addEventListener(kind, listener);
                }
            }
            for (let [key, value] of this.attributes) {
                element.setAttribute(key, value);
            }
            for (let [key, observable] of this.bound) {
                observable((value) => {
                    element.setAttribute(key, `${value}`);
                });
            }
            for (let [key, observable] of this.bound2) {
                observable.addObserver((value) => {
                    element.setAttribute(key, `${value}`);
                });
                if (this.tag === "input" && key === "value") {
                    element.addEventListener("input", () => {
                        observable.updateState(element.value);
                    });
                }
            }
            for (let child of this.children) {
                element.appendChild(child.render());
            }
            if (this.array) {
                this.array.addObserver({
                    onappend: (state) => {
                        if (this.renderer) {
                            let child = this.renderer(state);
                            element.appendChild(child.render());
                        }
                    },
                    onsplice: (state, index) => {
                        let child = element.children[index];
                        if (is.present(child)) {
                            element.removeChild(child);
                        }
                    }
                });
            }
            this.resolve(element);
            return element;
        }
        repeat(array, renderer) {
            this.array = array;
            this.renderer = renderer;
            return this;
        }
        set(key, value = "") {
            this.attributes.set(key, value);
            return this;
        }
    }
    exports.XElement = XElement;
    function element(selector) {
        return new XElement(selector);
    }
    exports.element = element;
    function text(content) {
        return new XText(content);
    }
    exports.text = text;
    function joinarray(nodes, joiner = " \u00b7 ") {
        let array = [];
        for (let node of nodes) {
            array.push(node);
            array.push(text(joiner));
        }
        array.pop();
        return array;
    }
    exports.joinarray = joinarray;
});
define("build/api/schema/messages", ["require", "exports", "node_modules/@joelek/ts-autoguard/build/autoguard-lib/index"], function (require, exports, ts_autoguard_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.RegisterResponse = exports.RegisterRequest = exports.ErrorMessage = void 0;
    exports.ErrorMessage = ts_autoguard_6.guards.Object.of({
        "errors": ts_autoguard_6.guards.Array.of(ts_autoguard_6.guards.String)
    });
    exports.RegisterRequest = ts_autoguard_6.guards.Object.of({
        "username": ts_autoguard_6.guards.String,
        "password": ts_autoguard_6.guards.String,
        "name": ts_autoguard_6.guards.String,
        "key_id": ts_autoguard_6.guards.String
    });
    exports.RegisterResponse = ts_autoguard_6.guards.Object.of({
        "token": ts_autoguard_6.guards.String
    });
    exports.Autoguard = {
        "ErrorMessage": exports.ErrorMessage,
        "RegisterRequest": exports.RegisterRequest,
        "RegisterResponse": exports.RegisterResponse
    };
});
define("build/api/schema/index", ["require", "exports", "build/api/schema/messages", "build/api/schema/objects"], function (require, exports, messages, objects) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.objects = exports.messages = void 0;
    exports.messages = messages;
    exports.objects = objects;
});
define("build/ui/EntityTitleFactory", ["require", "exports", "build/api/schema/objects", "build/xnode/index"], function (require, exports, api, xnode) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EntityTitleFactory = void 0;
    const CSS = ``;
    class EntityTitleFactory {
        constructor(entityLinkFactory) {
            this.entityLinkFactory = entityLinkFactory;
        }
        make(link, title) {
            return link.add(xnode.text(title));
        }
        forEntity(entity) {
            if (api.Actor.is(entity)) {
                return this.forActor(entity);
            }
            if (api.Album.is(entity)) {
                return this.forAlbum(entity);
            }
            if (api.Artist.is(entity)) {
                return this.forArtist(entity);
            }
            if (api.Disc.is(entity)) {
                return this.forDisc(entity);
            }
            if (api.Episode.is(entity)) {
                return this.forEpisode(entity);
            }
            if (api.Genre.is(entity)) {
                return this.forGenre(entity);
            }
            if (api.Movie.is(entity)) {
                return this.forMovie(entity);
            }
            if (api.Playlist.is(entity)) {
                return this.forPlaylist(entity);
            }
            if (api.Season.is(entity)) {
                return this.forSeason(entity);
            }
            if (api.Show.is(entity)) {
                return this.forShow(entity);
            }
            if (api.Track.is(entity)) {
                return this.forTrack(entity);
            }
            if (api.User.is(entity)) {
                return this.forUser(entity);
            }
            throw `Expected code to be unreachable!`;
        }
        forActor(actor) {
            return this.make(this.entityLinkFactory.forActor(actor), actor.name);
        }
        forAlbum(album) {
            return this.make(this.entityLinkFactory.forAlbum(album), album.title);
        }
        forArtist(artist) {
            return this.make(this.entityLinkFactory.forArtist(artist), artist.title);
        }
        forDisc(disc) {
            return this.make(this.entityLinkFactory.forDisc(disc), `Disc ${disc.number}`);
        }
        forEpisode(episode) {
            return this.make(this.entityLinkFactory.forEpisode(episode), episode.title);
        }
        forGenre(genre) {
            return this.make(this.entityLinkFactory.forGenre(genre), genre.title);
        }
        forMovie(movie) {
            return this.make(this.entityLinkFactory.forMovie(movie), movie.title);
        }
        forPlaylist(playlist) {
            return this.make(this.entityLinkFactory.forPlaylist(playlist), playlist.title);
        }
        forSeason(season) {
            return this.make(this.entityLinkFactory.forSeason(season), `Season ${season.number}`);
        }
        forShow(show) {
            return this.make(this.entityLinkFactory.forShow(show), show.title);
        }
        forTrack(track) {
            return this.make(this.entityLinkFactory.forTrack(track), track.title);
        }
        forUser(user) {
            return this.make(this.entityLinkFactory.forUser(user), user.name);
        }
        forYear(year) {
            return this.make(this.entityLinkFactory.forYear(year), year.year.toString());
        }
        static makeStyle() {
            return xnode.element("style")
                .add(xnode.text(CSS));
        }
    }
    exports.EntityTitleFactory = EntityTitleFactory;
    ;
});
define("build/ui/Grid", ["require", "exports", "build/xnode/index"], function (require, exports, xnode) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GridFactory = void 0;
    const CSS = `
	.grid {
		align-items: start;
		display: grid;
		gap: 24px;
		grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
	}

	.grid--mini {
		grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
	}
`;
    class GridFactory {
        constructor() {
        }
        make(options) {
            let mini = options?.mini ?? false;
            return xnode.element(`div.grid${mini ? ".grid--mini" : ""}`);
        }
        static makeStyle() {
            return xnode.element("style")
                .add(xnode.text(CSS));
        }
    }
    exports.GridFactory = GridFactory;
    ;
});
define("build/ui/CarouselFactory", ["require", "exports", "build/observers/index", "build/xnode/index"], function (require, exports, observers, xnode) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CarouselFactory = void 0;
    const CSS = `
	.carousel {
		display: grid;
		gap: 24px;
	}

	.carousel__content {
		align-items: start;
		display: grid;
		gap: 24px;
		grid-auto-flow: column;
		grid-auto-columns: 100%;
		overflow: scroll hidden;
		scroll-behavior: smooth;
		scroll-snap-type: x mandatory;
	}

	@media (hover: hover) and (pointer: fine) {
		.carousel__content {
			overflow: hidden;
		}
	}

	.carousel__content > * {
		scroll-snap-align: start;
	}

	.carousel__controls {
		display: grid;
		gap: 8px;
		grid-auto-flow: column;
		justify-content: center;
	}
`;
    class CarouselFactory {
        constructor(iconFactory) {
            this.iconFactory = iconFactory;
        }
        make(...children) {
            let activeIndex = new observers.ObservableClass(0);
            let canScrollLast = observers.computed((activeIndex) => {
                return activeIndex > 0;
            }, activeIndex);
            let canScrollNext = observers.computed((activeIndex) => {
                return activeIndex < children.length - 1;
            }, activeIndex);
            let contentElement = xnode.element("div.carousel__content");
            contentElement.ref().then(async (contentElement) => {
                let observer = new IntersectionObserver(async (entries) => {
                    for (let entry of entries) {
                        for (let [index, child] of children.entries()) {
                            let ref = await child.ref();
                            if (entry.target === ref && entry.isIntersecting) {
                                activeIndex.updateState(index);
                                return;
                            }
                        }
                    }
                }, {
                    root: contentElement
                });
                for (let child of children) {
                    let ref = await child.ref();
                    observer.observe(ref);
                }
            });
            return xnode.element("div.carousel")
                .add(contentElement
                .add(...children))
                .add(xnode.element("div.carousel__controls")
                .add(xnode.element("div.icon-button")
                .bind("data-enabled", canScrollLast.addObserver((canScrollLast) => `${canScrollLast}`))
                .add(this.iconFactory.makeChevron({ direction: "left" }))
                .on("click", async () => {
                if (canScrollLast.getState()) {
                    let content = await contentElement.ref();
                    let child = children[activeIndex.getState() - 1];
                    let ref = await child.ref();
                    content.scrollTo({ left: ref.offsetLeft - content.offsetLeft, behavior: "smooth" });
                }
            }))
                .add(xnode.element("div.icon-button")
                .bind("data-enabled", canScrollNext.addObserver((canScrollNext) => `${canScrollNext}`))
                .add(this.iconFactory.makeChevron())
                .on("click", async () => {
                if (canScrollNext.getState()) {
                    let content = await contentElement.ref();
                    let child = children[activeIndex.getState() + 1];
                    let ref = await child.ref();
                    content.scrollTo({ left: ref.offsetLeft - content.offsetLeft, behavior: "smooth" });
                }
            })));
        }
        static makeStyle() {
            return xnode.element("style")
                .add(xnode.text(CSS));
        }
    }
    exports.CarouselFactory = CarouselFactory;
    ;
});
define("build/ui/Icon", ["require", "exports", "build/xnode/index"], function (require, exports, xnode) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IconFactory = void 0;
    const CSS = `
	.icon--right {
		transform: rotate(0deg);
	}

	.icon--down {
		transform: rotate(90deg);
	}

	.icon--left {
		transform: rotate(180deg);
	}

	.icon--up {
		transform: rotate(270deg);
	}
`;
    function getClass(direction) {
        if (direction === "right") {
            return "icon--right";
        }
        if (direction === "down") {
            return "icon--down";
        }
        if (direction === "left") {
            return "icon--left";
        }
        if (direction === "up") {
            return "icon--up";
        }
        return "";
    }
    class IconFactory {
        constructor() {
        }
        makeBroadcast(options) {
            return xnode.element("svg")
                .set("class", getClass(options?.direction))
                .set("width", "16px")
                .set("height", "16px")
                .set("viewBox", "0 0 24 24")
                .add(xnode.element("path")
                .set("d", "M2,16c-1.1,0-2,0.9-2,2s0.9,2,2,2c1.1,0,2,0.9,2,2c0,1.1,0.9,2,2,2s2-0.9,2-2C8,18.7,5.3,16,2,16z"))
                .add(xnode.element("path")
                .set("d", "M2,8c-1.1,0-2,0.9-2,2s0.9,2,2,2c5.5,0,10,4.5,10,10c0,1.1,0.9,2,2,2s2-0.9,2-2C16,14.3,9.7,8,2,8z"))
                .add(xnode.element("path")
                .set("d", "M2,0C0.9,0,0,0.9,0,2s0.9,2,2,2c9.9,0,18,8.1,18,18c0,1.1,0.9,2,2,2s2-0.9,2-2C24,9.9,14.1,0,2,0z"));
        }
        makeBulletList(options) {
            return xnode.element("svg")
                .set("class", getClass(options?.direction))
                .set("width", "16px")
                .set("height", "16px")
                .set("viewBox", "0 0 24 24")
                .add(xnode.element("path")
                .set("d", "M7,4h16c0.6,0,1-0.4,1-1s-0.4-1-1-1H7C6.4,2,6,2.4,6,3S6.4,4,7,4z"))
                .add(xnode.element("path")
                .set("d", "M23,8H7C6.4,8,6,8.4,6,9s0.4,1,1,1h16c0.6,0,1-0.4,1-1S23.6,8,23,8z"))
                .add(xnode.element("path")
                .set("d", "M23,20H7c-0.6,0-1,0.4-1,1s0.4,1,1,1h16c0.6,0,1-0.4,1-1S23.6,20,23,20z"))
                .add(xnode.element("path")
                .set("d", "M23,14H7c-0.6,0-1,0.4-1,1s0.4,1,1,1h16c0.6,0,1-0.4,1-1S23.6,14,23,14z"))
                .add(xnode.element("path")
                .set("d", "M2,1C0.9,1,0,1.9,0,3s0.9,2,2,2s2-0.9,2-2S3.1,1,2,1z"))
                .add(xnode.element("path")
                .set("d", "M2,7C0.9,7,0,7.9,0,9c0,1.1,0.9,2,2,2s2-0.9,2-2C4,7.9,3.1,7,2,7z"))
                .add(xnode.element("path")
                .set("d", "M2,13c-1.1,0-2,0.9-2,2s0.9,2,2,2s2-0.9,2-2S3.1,13,2,13z"))
                .add(xnode.element("path")
                .set("d", "M2,19c-1.1,0-2,0.9-2,2s0.9,2,2,2s2-0.9,2-2S3.1,19,2,19z"));
        }
        makeCalendar(options) {
            return xnode.element("svg")
                .set("class", getClass(options?.direction))
                .set("width", "16px")
                .set("height", "16px")
                .set("viewBox", "0 0 24 24")
                .add(xnode.element("path")
                .set("d", "M21,2h-3V1c0-0.6-0.4-1-1-1s-1,0.4-1,1v1H8V1c0-0.6-0.4-1-1-1S6,0.4,6,1v1H3C1.3,2,0,3.3,0,5v4c0,0,0,0,0,0s0,0,0,0v12c0,1.7,1.3,3,3,3h18c1.7,0,3-1.3,3-3V5C24,3.3,22.7,2,21,2z M3,4h3v1c0,0.6,0.4,1,1,1s1-0.4,1-1V4h8v1c0,0.6,0.4,1,1,1s1-0.4,1-1V4h3c0.6,0,1,0.4,1,1v3H2V5C2,4.4,2.4,4,3,4z M21,22H3c-0.6,0-1-0.4-1-1V10h20v11C22,21.6,21.6,22,21,22z"));
        }
        makeChevron(options) {
            return xnode.element("svg")
                .set("class", getClass(options?.direction))
                .set("width", "16px")
                .set("height", "16px")
                .set("viewBox", "0 0 24 24")
                .add(xnode.element("path")
                .set("d", "M19.4,10.6l-10-10c-0.8-0.8-2-0.8-2.8,0c-0.8,0.8-0.8,2,0,2.8l8.6,8.6l-8.6,8.6c-0.8,0.8-0.8,2,0,2.8C7,23.8,7.5,24,8,24s1-0.2,1.4-0.6l10-10C20.2,12.6,20.2,11.4,19.4,10.6z"));
        }
        makeCross(options) {
            return xnode.element("svg")
                .set("class", getClass(options?.direction))
                .set("width", "16px")
                .set("height", "16px")
                .set("viewBox", "0 0 24 24")
                .add(xnode.element("path")
                .set("d", "M14.8,12l6.6-6.6c0.8-0.8,0.8-2,0-2.8c-0.8-0.8-2-0.8-2.8,0L12,9.2L5.4,2.6c-0.8-0.8-2-0.8-2.8,0c-0.8,0.8-0.8,2,0,2.8L9.2,12l-6.6,6.6c-0.8,0.8-0.8,2,0,2.8C3,21.8,3.5,22,4,22s1-0.2,1.4-0.6l6.6-6.6l6.6,6.6C19,21.8,19.5,22,20,22s1-0.2,1.4-0.6c0.8-0.8,0.8-2,0-2.8L14.8,12z"));
        }
        makeDisc(options) {
            return xnode.element("svg")
                .set("class", getClass(options?.direction))
                .set("width", "16px")
                .set("height", "16px")
                .set("viewBox", "0 0 24 24")
                .add(xnode.element("path")
                .set("d", "M12,0C5.4,0,0,5.4,0,12c0,6.6,5.4,12,12,12c6.6,0,12-5.4,12-12C24,5.4,18.6,0,12,0z M12,22C6.5,22,2,17.5,2,12C2,6.5,6.5,2,12,2c5.5,0,10,4.5,10,10C22,17.5,17.5,22,12,22z"))
                .add(xnode.element("path")
                .set("d", "M12,10c-1.1,0-2,0.9-2,2s0.9,2,2,2s2-0.9,2-2S13.1,10,12,10z"));
        }
        makeMagnifyingGlass(options) {
            return xnode.element("svg")
                .set("class", getClass(options?.direction))
                .set("width", "16px")
                .set("height", "16px")
                .set("viewBox", "0 0 24 24")
                .add(xnode.element("path")
                .set("d", "M23.7,22.3l-6-6c1.4-1.7,2.3-3.9,2.3-6.3c0-5.5-4.5-10-10-10C4.5,0,0,4.5,0,10c0,5.5,4.5,10,10,10c2.4,0,4.6-0.8,6.3-2.3l6,6c0.2,0.2,0.5,0.3,0.7,0.3s0.5-0.1,0.7-0.3C24.1,23.3,24.1,22.7,23.7,22.3z M10,18c-4.4,0-8-3.6-8-8s3.6-8,8-8s8,3.6,8,8S14.4,18,10,18z"));
        }
        makeMinus(options) {
            return xnode.element("svg")
                .set("class", getClass(options?.direction))
                .set("width", "16px")
                .set("height", "16px")
                .set("viewBox", "0 0 24 24")
                .add(xnode.element("path")
                .set("d", "M22,10H2c-1.1,0-2,0.9-2,2s0.9,2,2,2h20c1.1,0,2-0.9,2-2S23.1,10,22,10z"));
        }
        makeMonitor(options) {
            return xnode.element("svg")
                .set("class", getClass(options?.direction))
                .set("width", "16px")
                .set("height", "16px")
                .set("viewBox", "0 0 24 24")
                .add(xnode.element("path")
                .set("d", "M21,2H3C1.3,2,0,3.3,0,5v12c0,1.7,1.3,3,3,3h18c1.7,0,3-1.3,3-3V5C24,3.3,22.7,2,21,2z M22,17c0,0.6-0.4,1-1,1H3c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h18c0.6,0,1,0.4,1,1V17z"))
                .add(xnode.element("path")
                .set("d", "M17,22H7c-0.6,0-1,0.4-1,1s0.4,1,1,1h10c0.6,0,1-0.4,1-1S17.6,22,17,22z"));
        }
        makePadlock(options) {
            return xnode.element("svg")
                .set("class", getClass(options?.direction))
                .set("width", "16px")
                .set("height", "16px")
                .set("viewBox", "0 0 24 24")
                .add(xnode.element("path")
                .set("d", "M19,10h-1V6c0-3.3-2.7-6-6-6C8.7,0,6,2.7,6,6v4H5c-0.6,0-1,0.4-1,1v12c0,0.6,0.4,1,1,1h14c0.6,0,1-0.4,1-1V11C20,10.4,19.6,10,19,10z M8,6c0-2.2,1.8-4,4-4c2.2,0,4,1.8,4,4v4H8V6z M18,22H6V12h12V22z"));
        }
        makePause(options) {
            return xnode.element("svg")
                .set("class", getClass(options?.direction))
                .set("width", "16px")
                .set("height", "16px")
                .set("viewBox", "0 0 24 24")
                .add(xnode.element("path")
                .set("d", "M6,0C4.9,0,4,0.9,4,2v20c0,1.1,0.9,2,2,2s2-0.9,2-2V2C8,0.9,7.1,0,6,0z"))
                .add(xnode.element("path")
                .set("d", "M18,0c-1.1,0-2,0.9-2,2v20c0,1.1,0.9,2,2,2s2-0.9,2-2V2C20,0.9,19.1,0,18,0z"));
        }
        makePerson(options) {
            return xnode.element("svg")
                .set("class", getClass(options?.direction))
                .set("width", "16px")
                .set("height", "16px")
                .set("viewBox", "0 0 24 24")
                .add(xnode.element("path")
                .set("d", "M18.9,16.2C17,15.5,16,15,16,13c0-0.5,0.2-0.7,0.5-1.3c0.6-1,1.5-2.4,1.5-5.7c0-3.5-2.5-6-6-6C8.5,0,6,2.5,6,6c0,3.4,0.9,4.7,1.5,5.7C7.8,12.3,8,12.5,8,13c0,2-1,2.5-2.9,3.2C2.9,17,0,18.1,0,23c0,0.6,0.4,1,1,1h22c0.6,0,1-0.4,1-1C24,18.1,21.1,17,18.9,16.2z M2.1,22c0.3-2.7,1.8-3.2,3.7-3.9S10,16.5,10,13c0-1.1-0.4-1.7-0.8-2.4C8.6,9.8,8,8.8,8,6c0-2.4,1.6-4,4-4s4,1.6,4,4c0,2.8-0.6,3.8-1.2,4.6C14.4,11.3,14,11.9,14,13c0,3.5,2.3,4.4,4.2,5.1c1.9,0.7,3.4,1.3,3.7,3.9H2.1z"));
        }
        makePieChart(options) {
            return xnode.element("svg")
                .set("class", getClass(options?.direction))
                .set("width", "16px")
                .set("height", "16px")
                .set("viewBox", "0 0 24 24")
                .add(xnode.element("path")
                .set("d", "M17,14h-7V7c0-0.6-0.4-1-1-1c-5,0-9,4-9,9s4,9,9,9c5,0,9-4,9-9C18,14.4,17.6,14,17,14z M9,22c-3.9,0-7-3.1-7-7c0-3.5,2.6-6.4,6-6.9V15c0,0.6,0.4,1,1,1h6.9C15.4,19.4,12.5,22,9,22z"))
                .add(xnode.element("path")
                .set("d", "M13,0c-0.6,0-1,0.4-1,1v10c0,0.6,0.4,1,1,1h10c0.6,0,1-0.4,1-1C24,4.9,19.1,0,13,0z M14,10V2.1c4.2,0.5,7.5,3.8,7.9,7.9H14z"));
        }
        makePlay(options) {
            return xnode.element("svg")
                .set("class", getClass(options?.direction))
                .set("width", "16px")
                .set("height", "16px")
                .set("viewBox", "0 0 24 24")
                .add(xnode.element("path")
                .set("d", "M21.1,11L3.7,1C2.8,0.5,2,0.9,2,2v20c0,1.1,0.8,1.5,1.7,1l17.3-10C22,12.5,22,11.5,21.1,11z"));
        }
        makePlus(options) {
            return xnode.element("svg")
                .set("class", getClass(options?.direction))
                .set("width", "16px")
                .set("height", "16px")
                .set("viewBox", "0 0 24 24")
                .add(xnode.element("path")
                .set("d", "M22,10h-8V2c0-1.1-0.9-2-2-2s-2,0.9-2,2v8H2c-1.1,0-2,0.9-2,2s0.9,2,2,2h8v8c0,1.1,0.9,2,2,2s2-0.9,2-2v-8h8c1.1,0,2-0.9,2-2S23.1,10,22,10z"));
        }
        makeReload(options) {
            return xnode.element("svg")
                .set("class", getClass(options?.direction))
                .set("width", "16px")
                .set("height", "16px")
                .set("viewBox", "0 0 24 24")
                .add(xnode.element("path")
                .set("d", "M19.1,8.9c2.2,0,4-1.8,4-4s-1.8-4-4-4c-0.6,0-1.2,0.1-1.7,0.4C12.9-1,7.3-0.2,3.5,3.5c-4.7,4.7-4.7,12.3,0,17C5.9,22.8,8.9,24,12,24c3.1,0,6.1-1.2,8.5-3.5c0.8-0.8,0.8-2,0-2.8s-2-0.8-2.8,0c-3.1,3.1-8.2,3.1-11.3,0c-3.1-3.1-3.1-8.2,0-11.3c2.4-2.4,5.9-2.9,8.8-1.7c0,0.1,0,0.2,0,0.3C15.1,7.1,16.9,8.9,19.1,8.9z"));
        }
        makeSkip(options) {
            return xnode.element("svg")
                .set("class", getClass(options?.direction))
                .set("width", "16px")
                .set("height", "16px")
                .set("viewBox", "0 0 24 24")
                .add(xnode.element("path")
                .set("d", "M19.1,11L1.7,1C0.8,0.5,0,0.9,0,2v20c0,1.1,0.8,1.5,1.7,1l17.3-10C20,12.5,20,11.5,19.1,11z")).add(xnode.element("path")
                .set("d", "M22,0c-1.1,0-2,0.9-2,2v20c0,1.1,0.9,2,2,2s2-0.9,2-2V2C24,0.9,23.1,0,22,0z"));
        }
        makeSpeaker(options) {
            return xnode.element("svg")
                .set("class", getClass(options?.direction))
                .set("width", "16px")
                .set("height", "16px")
                .set("viewBox", "0 0 24 24")
                .add(xnode.element("path")
                .set("d", "M19,0H5C3.3,0,2,1.3,2,3v18c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V3C22,1.3,20.7,0,19,0z M20,21c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V3c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V21z"))
                .add(xnode.element("path")
                .set("d", "M12,10c-2.8,0-5,2.2-5,5s2.2,5,5,5s5-2.2,5-5S14.8,10,12,10z M12,18c-1.7,0-3-1.3-3-3s1.3-3,3-3s3,1.3,3,3S13.7,18,12,18z"))
                .add(xnode.element("path")
                .set("d", "M12,8c1.1,0,2-0.9,2-2s-0.9-2-2-2s-2,0.9-2,2S10.9,8,12,8z"));
        }
        makeStar(options) {
            return xnode.element("svg")
                .set("class", getClass(options?.direction))
                .set("width", "16px")
                .set("height", "16px")
                .set("viewBox", "0 0 24 24")
                .add(xnode.element("path")
                .set("d", "M23.8,9.4c-0.2-0.7-0.9-1.2-1.6-1.4l-5.8-0.8L13.8,2c-0.3-0.7-1-1.1-1.8-1.1S10.5,1.3,10.2,2L7.6,7.2L1.9,8C1.1,8.1,0.5,8.7,0.2,9.4c-0.2,0.7,0,1.5,0.5,2l4.2,4.1l-1,5.7c-0.1,0.8,0.2,1.5,0.8,2c0.6,0.4,1.4,0.5,2.1,0.2l5.2-2.7l5.2,2.7c0.3,0.2,0.6,0.2,0.9,0.2c0.4,0,0.8-0.1,1.2-0.4c0.6-0.5,0.9-1.2,0.8-2l-1-5.7l4.2-4.1C23.8,10.9,24,10.1,23.8,9.4z M17.3,14.4C17.1,14.7,17,15,17,15.3l1.1,6.3c0,0,0,0,0,0l-5.6-3c-0.3-0.2-0.6-0.2-0.9,0l-5.6,3L7,15.3C7,15,6.9,14.7,6.7,14.4L2.1,10l6.3-0.9C8.8,9,9,8.8,9.2,8.5L12,2.8l2.8,5.7C15,8.8,15.2,9,15.6,9.1l6.3,0.9L17.3,14.4z"));
        }
        static makeStyle() {
            return xnode.element("style")
                .add(xnode.text(CSS));
        }
    }
    exports.IconFactory = IconFactory;
    ;
});
define("build/ui/theme/index", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TEXT_ACCENT = exports.TEXT_1 = exports.TEXT_0 = exports.BACKGROUND_ACCENT = exports.BACKGROUND_4 = exports.BACKGROUND_3 = exports.BACKGROUND_2 = exports.BACKGROUND_1 = exports.BACKGROUND_0 = void 0;
    exports.BACKGROUND_0 = "rgb(0, 0, 0)";
    exports.BACKGROUND_1 = "rgb(15, 15, 15)";
    exports.BACKGROUND_2 = "rgb(31, 31, 31)";
    exports.BACKGROUND_3 = "rgb(47, 47, 47)";
    exports.BACKGROUND_4 = "rgb(63, 63, 63)";
    exports.BACKGROUND_ACCENT = "rgb(223, 79, 127)";
    exports.TEXT_0 = "rgb(255, 255, 255)";
    exports.TEXT_1 = "rgb(159, 159, 159)";
    exports.TEXT_ACCENT = "rgb(255, 255, 255)";
});
define("build/ui/ImageBox", ["require", "exports", "build/observers/index", "build/xnode/index", "build/ui/theme/index", "build/is"], function (require, exports, observables, xnode, theme, is) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ImageBoxFactory = void 0;
    const CSS = `
	.image-box {
		background-color: ${theme.BACKGROUND_3};
		border-radius: 4px;
		overflow: hidden;
		position: relative;
		will-change: opacity;
	}

	.image-box--poster {
		padding-bottom: ${3 / 2 * 100}%;
	}

	.image-box--square {
		padding-bottom: ${1 / 1 * 100}%;
	}

	.image-box--video {
		padding-bottom: ${9 / 16 * 100}%;
	}

	.image-box__image {
		height: 100%;
		object-fit: contain;
		position: absolute;
		width: 100%;
	}

	[data-opaque] {
		opacity: 0;
		transition: opacity 1.000s;
	}

	[data-opaque="true"] {
		opacity: 1;
		//filter: blur(32px);
	}
`;
    class ImageBoxFactory {
        constructor(token) {
            this.token = token;
        }
        for(url, format = "square") {
            let isLoaded = new observables.ObservableClass(false);
            return xnode.element(`div.image-box.image-box--${format}`)
                .add(is.absent(url) ? undefined : xnode.element("img.image-box__image")
                .bind("data-opaque", isLoaded.addObserver((isLoaded) => isLoaded))
                .bind("src", this.token.addObserver((token) => {
                if (is.present(token) && is.present(url)) {
                    return `${url}?token=${token}`;
                }
            }))
                .on("load", () => {
                isLoaded.updateState(true);
            }));
        }
        forPoster(url) {
            return this.for(url, "poster");
        }
        forSquare(url) {
            return this.for(url, "square");
        }
        forVideo(url) {
            return this.for(url, "video");
        }
        static makeStyle() {
            return xnode.element("style")
                .add(xnode.text(CSS));
        }
    }
    exports.ImageBoxFactory = ImageBoxFactory;
    ;
});
define("build/ui/EntityLink", ["require", "exports", "build/api/schema/objects", "build/xnode/index"], function (require, exports, api, xnode) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EntityLinkFactory = void 0;
    const CSS = ``;
    class EntityLinkFactory {
        constructor(navigator, contextMenuEntity) {
            this.navigator = navigator;
            this.contextMenuEntity = contextMenuEntity;
        }
        make(url, entity) {
            let onclick = () => {
                this.navigator(url);
            };
            let oncontextmenu = () => {
                this.contextMenuEntity.updateState(undefined);
                this.contextMenuEntity.updateState(entity);
            };
            let timer;
            return xnode.element("a")
                .set("href", url)
                .on("click", onclick)
                .on("contextmenu", oncontextmenu)
                .on("touchstart", () => {
                timer = window.setTimeout(() => {
                    window.clearTimeout(timer);
                    timer = undefined;
                    oncontextmenu();
                }, 500);
            }, false)
                .on("touchcancel", () => {
                window.clearTimeout(timer);
                timer = undefined;
            }, false)
                .on("touchmove", () => {
                window.clearTimeout(timer);
                timer = undefined;
            }, false)
                .on("touchend", () => {
                window.clearTimeout(timer);
                timer = undefined;
            }, false);
        }
        forActor(actor) {
            return this.make(`actors/${actor.actor_id}/`);
        }
        forAlbum(album) {
            return this.make(`audio/albums/${album.album_id}/`);
        }
        forAlbums() {
            return this.make(`audio/albums/`);
        }
        forArtist(artist) {
            return this.make(`audio/artists/${artist.artist_id}/`);
        }
        forArtists() {
            return this.make(`audio/artists/`);
        }
        forCue(cue) {
            return this.make(`video/cues/${cue.cue_id}/`);
        }
        forDisc(disc) {
            return this.make(`audio/discs/${disc.disc_id}/`);
        }
        forDiscs() {
            return this.make(`audio/discs/`);
        }
        forEpisode(episode) {
            return this.make(`video/episodes/${episode.episode_id}/`);
        }
        forEpisodes() {
            return this.make(`video/episodes/`);
        }
        forGenre(genre) {
            return this.make(`video/genres/${genre.genre_id}/`);
        }
        forGenres() {
            return this.make(`video/genres/`);
        }
        forMovie(movie) {
            return this.make(`video/movies/${movie.movie_id}/`);
        }
        forMovies() {
            return this.make(`video/movies/`);
        }
        forActors() {
            return this.make(`actors/`);
        }
        forPlaylist(playlist) {
            return this.make(`audio/playlists/${playlist.playlist_id}/`);
        }
        forPlaylists() {
            return this.make(`audio/playlists/`);
        }
        forSeason(season) {
            return this.make(`video/seasons/${season.season_id}/`);
        }
        forSeasons() {
            return this.make(`video/seasons/`);
        }
        forShow(show) {
            return this.make(`video/shows/${show.show_id}/`);
        }
        forShows() {
            return this.make(`video/shows/`);
        }
        forTrack(track) {
            return this.make(`audio/tracks/${track.track_id}/`, track);
        }
        forTracks() {
            return this.make(`audio/tracks/`);
        }
        forUser(user) {
            return this.make(`users/${user.user_id}/`);
        }
        forUsers() {
            return this.make(`users/`);
        }
        forYear(year) {
            return this.make(`years/${year.year_id}/`);
        }
        forYears() {
            return this.make(`years/`);
        }
        forEntity(entity) {
            if (api.ActorBase.is(entity)) {
                return this.forActor(entity);
            }
            if (api.AlbumBase.is(entity)) {
                return this.forAlbum(entity);
            }
            if (api.ArtistBase.is(entity)) {
                return this.forArtist(entity);
            }
            if (api.CueBase.is(entity)) {
                return this.forCue(entity);
            }
            if (api.DiscBase.is(entity)) {
                return this.forDisc(entity);
            }
            if (api.EpisodeBase.is(entity)) {
                return this.forEpisode(entity);
            }
            if (api.GenreBase.is(entity)) {
                return this.forGenre(entity);
            }
            if (api.PlaylistBase.is(entity)) {
                return this.forPlaylist(entity);
            }
            if (api.MovieBase.is(entity)) {
                return this.forMovie(entity);
            }
            if (api.SeasonBase.is(entity)) {
                return this.forSeason(entity);
            }
            if (api.ShowBase.is(entity)) {
                return this.forShow(entity);
            }
            if (api.TrackBase.is(entity)) {
                return this.forTrack(entity);
            }
            if (api.UserBase.is(entity)) {
                return this.forUser(entity);
            }
            if (api.YearBase.is(entity)) {
                return this.forYear(entity);
            }
            throw `Expected code to be unreachable!`;
        }
        static makeStyle() {
            return xnode.element("style")
                .add(xnode.text(CSS));
        }
    }
    exports.EntityLinkFactory = EntityLinkFactory;
    ;
});
define("build/ui/metadata/index", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatDuration = exports.computeDuration = void 0;
    function computeDuration(ms) {
        let s = Math.floor(ms / 1000);
        ms -= s * 1000;
        let m = Math.floor(s / 60);
        s -= m * 60;
        let h = Math.floor(m / 60);
        m -= h * 60;
        let d = Math.floor(h / 24);
        h -= d * 24;
        return {
            ms,
            s,
            m,
            h,
            d
        };
    }
    exports.computeDuration = computeDuration;
    ;
    function formatDuration(ms) {
        let duration = computeDuration(ms);
        if (duration.d >= 10) {
            return `${duration.d}d`;
        }
        else if (duration.d >= 1) {
            return `${duration.d}d ${duration.h}h`;
        }
        else if (duration.h >= 10) {
            return `${duration.h}h`;
        }
        else if (duration.h >= 1) {
            return `${duration.h}h ${duration.m}m`;
        }
        else if (duration.m >= 10) {
            return `${duration.m}m`;
        }
        else if (duration.m >= 1) {
            return `${duration.m}m ${duration.s}s`;
        }
        else {
            return `${duration.s}s`;
        }
    }
    exports.formatDuration = formatDuration;
    ;
});
define("build/ui/EntityCard", ["require", "exports", "build/api/schema/objects", "build/xnode/index", "build/ui/theme/index", "build/ui/metadata/index", "build/is"], function (require, exports, api, xnode, theme, metadata, is) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EntityCardFactory = void 0;
    const CSS = `
	.entity-card {
		align-items: start;
		display: grid;
		gap: 24px;
		grid-auto-rows: min-content;
		grid-template-columns: repeat(auto-fit, minmax(240px, auto));
	}

	.entity-card__artwork {
		position: relative;
	}

	.entity-card__playback {
		position: absolute;
			bottom: 16px;
			right: 16px;
	}

	.entity-card__content {

	}

	.entity-card__pusher {
		width: 100vw;
	}

	.entity-card__metadata {
		display: grid;
		gap: 16px;
	}

	.entity-card__titles {
		display: grid;
		gap: 8px;
	}

	.entity-card__title {
		color: ${theme.TEXT_0};
		font-size: 20px;
		overflow: hidden;
		text-overflow: ellipsis;
		white-space: nowrap;
	}

	.entity-card__subtitle {
		color: ${theme.TEXT_1};
		font-size: 16px;
		overflow: hidden;
		text-overflow: ellipsis;
		white-space: nowrap;
	}

	.entity-card__tags {
		display: grid;
		gap: 8px;
		grid-auto-columns: minmax(auto, max-content);
		grid-auto-flow: column;
	}

	.entity-card__tag {
		background-color: ${theme.BACKGROUND_3};
		border-radius: 2px;
		color: ${theme.TEXT_1};
		font-size: 12px;
		padding: 4px 8px;
		overflow: hidden;
		text-overflow: ellipsis;
		white-space: nowrap;
	}

	.entity-card__tag--accent {
		background-color: ${theme.BACKGROUND_ACCENT};
		color: ${theme.TEXT_ACCENT};
	}

	.entity-card__description {
		color: ${theme.TEXT_1};
		font-size: 16px;
		line-height: 1.25;
		word-break: break-word;
	}

	.entity-card__description--compact {
		display: -webkit-box;
			-webkit-box-orient: vertical;
			-webkit-line-clamp: 3;
		max-height: 60px;
		overflow: hidden;
	}
`;
    function isHighDefinition(width, height) {
        let is_ultrawide = width * 9 > 16 * height;
        if (is_ultrawide) {
            return width >= 1280;
        }
        else {
            return height >= 720;
        }
    }
    class EntityCardFactory {
        constructor(entityTitleFactory, entityLinkFactory, ImageBox, PlaybackButton) {
            this.entityTitleFactory = entityTitleFactory;
            this.entityLinkFactory = entityLinkFactory;
            this.ImageBox = ImageBox;
            this.PlaybackButton = PlaybackButton;
        }
        make(link, image, titles, subtitles, tags, description, options = {}) {
            return link.add(xnode.element("div.entity-card")
                .add(xnode.element("div.entity-card__artwork")
                .add(options.image ?? image)
                .add(xnode.element("div.entity-card__playback")
                .add(options.playbackButton)))
                .add(xnode.element("div.entity-card__content")
                .add(xnode.element("div.entity-card__pusher"))
                .add(xnode.element("div.entity-card__metadata")
                .add(xnode.element("div.entity-card__titles")
                .add(titles.length === 0 ? undefined : xnode.element("div.entity-card__title")
                .add(...xnode.joinarray(titles)))
                .add(subtitles.length === 0 ? undefined : xnode.element("div.entity-card__subtitle")
                .add(...xnode.joinarray(subtitles))))
                .add(tags.length === 0 ? undefined : xnode.element("div.entity-card__tags")
                .add(...tags))
                .add(is.absent(description) ? undefined : xnode.element(options.compactDescription === false ? "div.entity-card__description" : "div.entity-card__description.entity-card__description--compact")
                .add(xnode.text(description))))));
        }
        forEntity(entity, options = {}) {
            if (api.Actor.is(entity)) {
                return this.forActor(entity, options);
            }
            if (api.Album.is(entity)) {
                return this.forAlbum(entity, options);
            }
            if (api.Artist.is(entity)) {
                return this.forArtist(entity, options);
            }
            if (api.Cue.is(entity)) {
                return this.forCue(entity, options);
            }
            if (api.Disc.is(entity)) {
                return this.forDisc(entity, options);
            }
            if (api.Episode.is(entity)) {
                return this.forEpisode(entity, options);
            }
            if (api.Genre.is(entity)) {
                return this.forGenre(entity, options);
            }
            if (api.Playlist.is(entity)) {
                return this.forPlaylist(entity, options);
            }
            if (api.Movie.is(entity)) {
                return this.forMovie(entity, options);
            }
            if (api.Season.is(entity)) {
                return this.forSeason(entity, options);
            }
            if (api.Show.is(entity)) {
                return this.forShow(entity, options);
            }
            if (api.Track.is(entity)) {
                return this.forTrack(entity, options);
            }
            if (api.User.is(entity)) {
                return this.forUser(entity, options);
            }
            if (api.Year.is(entity)) {
                return this.forYear(entity, options);
            }
            throw `Expected code to be unreachable!`;
        }
        forActor(actor, options = {}) {
            let link = this.entityLinkFactory.forActor(actor);
            let image = this.ImageBox.forSquare();
            let titles = [
                this.entityTitleFactory.forActor(actor)
            ];
            let subtitles = [];
            let tags = [
                "Actor"
            ].filter(is.present).map((tag) => xnode.element("div.entity-card__tag").add(xnode.text(tag)));
            return this.make(link, image, titles, subtitles, tags, undefined, options);
        }
        forAlbum(album, options = {}) {
            options.playbackButton = options.playbackButton ?? this.PlaybackButton.forAlbum(album);
            let duration_ms = 0;
            for (let disc of album.discs) {
                for (let track of disc.tracks) {
                    duration_ms += track.media.duration_ms;
                }
            }
            let link = this.entityLinkFactory.forAlbum(album);
            let image = this.ImageBox.forSquare(album.artwork.map((image) => `/files/${image.file_id}/`).shift());
            let titles = [
                this.entityTitleFactory.forAlbum(album)
            ];
            let subtitles = album.artists.map((artist) => this.entityTitleFactory.forArtist(artist));
            let tags = [
                "Album",
                is.present(album.year) ? `${album.year}` : undefined,
                metadata.formatDuration(duration_ms)
            ].filter(is.present).map((tag) => xnode.element("div.entity-card__tag").add(xnode.text(tag)));
            return this.make(link, image, titles, subtitles, tags, undefined, options);
        }
        forArtist(artist, options = {}) {
            options.playbackButton = options.playbackButton ?? this.PlaybackButton.forArtist(artist);
            let duration_ms = 0;
            for (let album of artist.albums) {
                for (let disc of album.discs) {
                    for (let track of disc.tracks) {
                        duration_ms += track.media.duration_ms;
                    }
                }
            }
            let link = this.entityLinkFactory.forArtist(artist);
            let image = this.ImageBox.forSquare(artist.albums[0]?.artwork.map((image) => `/files/${image.file_id}/`).shift());
            let titles = [
                this.entityTitleFactory.forArtist(artist)
            ];
            let subtitles = new Array();
            let tags = [
                "Artist",
                metadata.formatDuration(duration_ms)
            ].filter(is.present).map((tag) => xnode.element("div.entity-card__tag").add(xnode.text(tag)));
            return this.make(link, image, titles, subtitles, tags, undefined, options);
        }
        forCue(cue, options = {}) {
            options.playbackButton = options.playbackButton ?? this.PlaybackButton.forCue(cue);
            options.image = this.ImageBox.forVideo(`/media/gifs/${cue.cue_id}/`);
            if (false) {
            }
            else if (api.Episode.is(cue.media)) {
                return this.forEpisode(cue.media, options);
            }
            else if (api.Movie.is(cue.media)) {
                return this.forMovie(cue.media, options);
            }
            else {
                throw `Expected code to be unreachable!`;
            }
        }
        forDisc(disc, options = {}) {
            options.playbackButton = options.playbackButton ?? this.PlaybackButton.forDisc(disc);
            let duration_ms = 0;
            for (let track of disc.tracks) {
                duration_ms += track.media.duration_ms;
            }
            let link = this.entityLinkFactory.forDisc(disc);
            let image = this.ImageBox.forSquare(disc.album.artwork.map((image) => `/files/${image.file_id}/`).shift());
            let titles = [
                this.entityTitleFactory.forDisc(disc)
            ];
            let subtitles = [
                this.entityTitleFactory.forAlbum(disc.album)
            ];
            let tags = [
                "Disc",
                metadata.formatDuration(duration_ms)
            ].filter(is.present).map((tag) => xnode.element("div.entity-card__tag").add(xnode.text(tag)));
            return this.make(link, image, titles, subtitles, tags, undefined, options);
        }
        forEpisode(episode, options = {}) {
            options.playbackButton = options.playbackButton ?? this.PlaybackButton.forEpisode(episode);
            let duration_ms = 0;
            duration_ms += episode.media.duration_ms;
            let link = this.entityLinkFactory.forEpisode(episode);
            let image = this.ImageBox.forVideo(`/media/stills/${episode.media.file_id}/`);
            let titles = [
                this.entityTitleFactory.forEpisode(episode)
            ];
            let subtitles = [
                this.entityTitleFactory.forShow(episode.season.show),
                this.entityTitleFactory.forSeason(episode.season)
            ];
            let tags = [
                "Episode",
                is.present(episode.year) ? `${episode.year}` : undefined,
                metadata.formatDuration(duration_ms)
            ].filter(is.present).map((tag) => xnode.element("div.entity-card__tag").add(xnode.text(tag)));
            if (isHighDefinition(episode.media.width, episode.media.height)) {
                tags.unshift(xnode.element("div.entity-card__tag.entity-card__tag--accent").add(xnode.text("HD")));
            }
            if (is.present(episode.last_stream_date)) {
                tags.unshift(xnode.element("div.entity-card__tag.entity-card__tag--accent").add(xnode.text("\u2713")));
            }
            return this.make(link, image, titles, subtitles, tags, episode.summary, options);
        }
        forGenre(genre, options = {}) {
            let link = this.entityLinkFactory.forGenre(genre);
            let image = this.ImageBox.forSquare();
            let titles = [
                this.entityTitleFactory.forGenre(genre)
            ];
            let subtitles = [];
            let tags = [
                "Genre"
            ].filter(is.present).map((tag) => xnode.element("div.entity-card__tag").add(xnode.text(tag)));
            return this.make(link, image, titles, subtitles, tags, undefined, options);
        }
        forMovie(movie, options = {}) {
            options.playbackButton = options.playbackButton ?? this.PlaybackButton.forMovie(movie);
            let duration_ms = 0;
            duration_ms += movie.media.duration_ms;
            let link = this.entityLinkFactory.forMovie(movie);
            let image = this.ImageBox.forPoster(movie.artwork.map((image) => `/files/${image.file_id}/`).shift());
            let titles = [
                this.entityTitleFactory.forMovie(movie)
            ];
            let subtitles = movie.genres.map((genre) => this.entityTitleFactory.forGenre(genre));
            let tags = [
                "Movie",
                is.present(movie.year) ? `${movie.year}` : undefined,
                metadata.formatDuration(duration_ms)
            ].filter(is.present).map((tag) => xnode.element("div.entity-card__tag").add(xnode.text(tag)));
            if (isHighDefinition(movie.media.width, movie.media.height)) {
                tags.unshift(xnode.element("div.entity-card__tag.entity-card__tag--accent").add(xnode.text("HD")));
            }
            if (is.present(movie.last_stream_date)) {
                tags.unshift(xnode.element("div.entity-card__tag.entity-card__tag--accent").add(xnode.text("\u2713")));
            }
            return this.make(link, image, titles, subtitles, tags, movie.summary, options);
        }
        forPlaylist(playlist, options = {}) {
            options.playbackButton = options.playbackButton ?? this.PlaybackButton.forPlaylist(playlist);
            let duration_ms = 0;
            for (let item of playlist.items) {
                duration_ms += item.track.media.duration_ms;
            }
            let link = this.entityLinkFactory.forPlaylist(playlist);
            let image = this.ImageBox.forSquare(playlist.items[0]?.track.disc.album.artwork.map((image) => `/files/${image.file_id}/`).shift());
            let titles = [
                this.entityTitleFactory.forPlaylist(playlist)
            ];
            let subtitles = [
                this.entityTitleFactory.forUser(playlist.user)
            ];
            let tags = [
                "Playlist",
                metadata.formatDuration(duration_ms)
            ].filter(is.present).map((tag) => xnode.element("div.entity-card__tag").add(xnode.text(tag)));
            return this.make(link, image, titles, subtitles, tags, playlist.description, options);
        }
        forSeason(season, options = {}) {
            options.playbackButton = options.playbackButton ?? this.PlaybackButton.forSeason(season);
            let duration_ms = 0;
            for (let episode of season.episodes) {
                duration_ms += episode.media.duration_ms;
            }
            let link = this.entityLinkFactory.forSeason(season);
            let image = this.ImageBox.forPoster(season.show.artwork.map((image) => `/files/${image.file_id}/`).shift());
            let titles = [
                this.entityTitleFactory.forSeason(season)
            ];
            let subtitles = [
                this.entityTitleFactory.forShow(season.show)
            ];
            let tags = [
                "Season",
                metadata.formatDuration(duration_ms)
            ].filter(is.present).map((tag) => xnode.element("div.entity-card__tag").add(xnode.text(tag)));
            return this.make(link, image, titles, subtitles, tags, undefined, options);
        }
        forShow(show, options = {}) {
            options.playbackButton = options.playbackButton ?? this.PlaybackButton.forShow(show);
            let duration_ms = 0;
            for (let season of show.seasons) {
                for (let episode of season.episodes) {
                    duration_ms += episode.media.duration_ms;
                }
            }
            let link = this.entityLinkFactory.forShow(show);
            let image = this.ImageBox.forPoster(show.artwork.map((image) => `/files/${image.file_id}/`).shift());
            let titles = [
                this.entityTitleFactory.forShow(show)
            ];
            let subtitles = show.genres.map((genre) => this.entityTitleFactory.forGenre(genre));
            let tags = [
                "Show",
                metadata.formatDuration(duration_ms)
            ].filter(is.present).map((tag) => xnode.element("div.entity-card__tag").add(xnode.text(tag)));
            return this.make(link, image, titles, subtitles, tags, show.summary, options);
        }
        forTrack(track, options = {}) {
            options.playbackButton = options.playbackButton ?? this.PlaybackButton.forTrack(track);
            let duration_ms = 0;
            duration_ms += track.media.duration_ms;
            let link = this.entityLinkFactory.forTrack(track);
            let image = this.ImageBox.forSquare(track.disc.album.artwork.map((image) => `/files/${image.file_id}/`).shift());
            let titles = [
                this.entityTitleFactory.forTrack(track)
            ];
            let subtitles = [
                ...track.artists.map((artist) => this.entityTitleFactory.forArtist(artist)),
                this.entityTitleFactory.forAlbum(track.disc.album)
            ];
            let tags = [
                "Track",
                metadata.formatDuration(duration_ms)
            ].filter(is.present).map((tag) => xnode.element("div.entity-card__tag").add(xnode.text(tag)));
            return this.make(link, image, titles, subtitles, tags, undefined, options);
        }
        forUser(user, options = {}) {
            let link = this.entityLinkFactory.forUser(user);
            let image = this.ImageBox.forSquare();
            let titles = [
                this.entityTitleFactory.forUser(user)
            ];
            let subtitles = [
                xnode.element("span").add(xnode.text(user.username))
            ];
            let tags = [
                "User"
            ].filter(is.present).map((tag) => xnode.element("div.entity-card__tag").add(xnode.text(tag)));
            return this.make(link, image, titles, subtitles, tags, undefined, options);
        }
        forYear(year, options = {}) {
            let link = this.entityLinkFactory.forYear(year);
            let image = this.ImageBox.forSquare();
            let titles = [
                this.entityTitleFactory.forYear(year)
            ];
            let subtitles = [];
            let tags = [
                "Year"
            ].filter(is.present).map((tag) => xnode.element("div.entity-card__tag").add(xnode.text(tag)));
            return this.make(link, image, titles, subtitles, tags, undefined, options);
        }
        static makeStyle() {
            return xnode.element("style")
                .add(xnode.text(CSS));
        }
    }
    exports.EntityCardFactory = EntityCardFactory;
    ;
});
define("build/ui/EntityRow", ["require", "exports", "build/api/schema/objects", "build/xnode/index", "build/ui/theme/index"], function (require, exports, api, xnode, theme) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EntityRowFactory = void 0;
    const CSS = `
	.entity-row {
		align-items: center;
		display: grid;
		gap: 16px;
		grid-template-columns: 60px 1fr;
	}

	.entity-row__artwork {
		position: relative;
	}

	.entity-row__playback {
		position: absolute;
			top: 50%; left: 50%;
		transform: translate(-50%, -50%);
	}

	.entity-row__content {

	}

	.entity-row__metadata {
		display: grid;
		gap: 16px;
	}

	.entity-row__titles {
		display: grid;
		gap: 8px;
	}

	.entity-row__title {
		color: ${theme.TEXT_0};
		font-size: 16px;
		overflow: hidden;
		text-overflow: ellipsis;
		white-space: nowrap;
	}

	.entity-row__subtitle {
		color: ${theme.TEXT_1};
		font-size: 16px;
		overflow: hidden;
		text-overflow: ellipsis;
		white-space: nowrap;
	}
`;
    class EntityRowFactory {
        constructor(entityTitleFactory, entityLinkFactory, ImageBox, PlaybackButton) {
            this.entityTitleFactory = entityTitleFactory;
            this.entityLinkFactory = entityLinkFactory;
            this.ImageBox = ImageBox;
            this.PlaybackButton = PlaybackButton;
        }
        make(link, image, playbackButton, titles, subtitles) {
            return link.add(xnode.element("div.entity-row")
                .add(xnode.element("div.entity-row__artwork")
                .add(image)
                .add(xnode.element("div.entity-row__playback")
                .add(playbackButton)))
                .add(xnode.element("div.entity-row__content")
                .add(xnode.element("div.entity-row__metadata")
                .add(xnode.element("div.entity-row__titles")
                .add(titles.length === 0 ? undefined : xnode.element("div.entity-row__title")
                .add(...xnode.joinarray(titles)))
                .add(subtitles.length === 0 ? undefined : xnode.element("div.entity-row__subtitle")
                .add(...xnode.joinarray(subtitles)))))));
        }
        forEntity(entity) {
            if (api.Actor.is(entity)) {
                return this.forActor(entity);
            }
            if (api.Album.is(entity)) {
                return this.forAlbum(entity);
            }
            if (api.Artist.is(entity)) {
                return this.forArtist(entity);
            }
            if (api.Cue.is(entity)) {
                return this.forCue(entity);
            }
            if (api.Disc.is(entity)) {
                return this.forDisc(entity);
            }
            if (api.Episode.is(entity)) {
                return this.forEpisode(entity);
            }
            if (api.Genre.is(entity)) {
                return this.forGenre(entity);
            }
            if (api.Playlist.is(entity)) {
                return this.forPlaylist(entity);
            }
            if (api.Movie.is(entity)) {
                return this.forMovie(entity);
            }
            if (api.Season.is(entity)) {
                return this.forSeason(entity);
            }
            if (api.Show.is(entity)) {
                return this.forShow(entity);
            }
            if (api.Track.is(entity)) {
                return this.forTrack(entity);
            }
            if (api.User.is(entity)) {
                return this.forUser(entity);
            }
            if (api.Year.is(entity)) {
                return this.forYear(entity);
            }
            throw `Expected code to be unreachable!`;
        }
        forActor(actor) {
            let link = this.entityLinkFactory.forActor(actor);
            let image = this.ImageBox.forSquare();
            let titles = [
                this.entityTitleFactory.forActor(actor)
            ];
            let subtitles = [];
            return this.make(link, image, undefined, titles, subtitles);
        }
        forAlbum(album, playbackButton = this.PlaybackButton.forAlbum(album)) {
            let link = this.entityLinkFactory.forAlbum(album);
            let image = this.ImageBox.forSquare(album.artwork.map((image) => `/files/${image.file_id}/`).shift());
            let titles = [
                this.entityTitleFactory.forAlbum(album)
            ];
            let subtitles = album.artists.map((artist) => this.entityTitleFactory.forArtist(artist));
            return this.make(link, image, playbackButton, titles, subtitles);
        }
        forArtist(artist, playbackButton = this.PlaybackButton.forArtist(artist)) {
            let link = this.entityLinkFactory.forArtist(artist);
            let image = this.ImageBox.forSquare(artist.albums[0]?.artwork.map((image) => `/files/${image.file_id}/`).shift());
            let titles = [
                this.entityTitleFactory.forArtist(artist)
            ];
            let subtitles = new Array();
            return this.make(link, image, playbackButton, titles, subtitles);
        }
        forCue(cue, playbackButton = this.PlaybackButton.forCue(cue)) {
            if (false) {
            }
            else if (api.Episode.is(cue.media)) {
                return this.forEpisode(cue.media, playbackButton);
            }
            else if (api.Movie.is(cue.media)) {
                return this.forMovie(cue.media, playbackButton);
            }
            else {
                throw `Expected code to be unreachable!`;
            }
        }
        forDisc(disc, playbackButton = this.PlaybackButton.forDisc(disc)) {
            let link = this.entityLinkFactory.forDisc(disc);
            let image = this.ImageBox.forSquare(disc.album.artwork.map((image) => `/files/${image.file_id}/`).shift());
            let titles = [
                this.entityTitleFactory.forDisc(disc)
            ];
            let subtitles = [
                this.entityTitleFactory.forAlbum(disc.album)
            ];
            return this.make(link, image, playbackButton, titles, subtitles);
        }
        forEpisode(episode, playbackButton = this.PlaybackButton.forEpisode(episode)) {
            let link = this.entityLinkFactory.forEpisode(episode);
            let image = this.ImageBox.forSquare(`/media/stills/${episode.media.file_id}/`);
            let titles = [
                this.entityTitleFactory.forEpisode(episode)
            ];
            let subtitles = [
                this.entityTitleFactory.forShow(episode.season.show),
                this.entityTitleFactory.forSeason(episode.season)
            ];
            return this.make(link, image, playbackButton, titles, subtitles);
        }
        forGenre(genre) {
            let link = this.entityLinkFactory.forGenre(genre);
            let image = this.ImageBox.forSquare();
            let titles = [
                this.entityTitleFactory.forGenre(genre)
            ];
            let subtitles = [];
            return this.make(link, image, undefined, titles, subtitles);
        }
        forMovie(movie, playbackButton = this.PlaybackButton.forMovie(movie)) {
            let link = this.entityLinkFactory.forMovie(movie);
            let image = this.ImageBox.forSquare(movie.artwork.map((image) => `/files/${image.file_id}/`).shift());
            let titles = [
                this.entityTitleFactory.forMovie(movie)
            ];
            let subtitles = movie.genres.map((genre) => this.entityTitleFactory.forGenre(genre));
            return this.make(link, image, playbackButton, titles, subtitles);
        }
        forPlaylist(playlist, playbackButton = this.PlaybackButton.forPlaylist(playlist)) {
            let link = this.entityLinkFactory.forPlaylist(playlist);
            let image = this.ImageBox.forSquare(playlist.items[0]?.track.disc.album.artwork.map((image) => `/files/${image.file_id}/`).shift());
            let titles = [
                this.entityTitleFactory.forPlaylist(playlist)
            ];
            let subtitles = [
                this.entityTitleFactory.forUser(playlist.user)
            ];
            return this.make(link, image, playbackButton, titles, subtitles);
        }
        forSeason(season, playbackButton = this.PlaybackButton.forSeason(season)) {
            let link = this.entityLinkFactory.forSeason(season);
            let image = this.ImageBox.forSquare(season.show.artwork.map((image) => `/files/${image.file_id}/`).shift());
            let titles = [
                this.entityTitleFactory.forSeason(season)
            ];
            let subtitles = [
                this.entityTitleFactory.forShow(season.show)
            ];
            return this.make(link, image, playbackButton, titles, subtitles);
        }
        forShow(show, playbackButton = this.PlaybackButton.forShow(show)) {
            let link = this.entityLinkFactory.forShow(show);
            let image = this.ImageBox.forSquare(show.artwork.map((image) => `/files/${image.file_id}/`).shift());
            let titles = [
                this.entityTitleFactory.forShow(show)
            ];
            let subtitles = show.genres.map((genre) => this.entityTitleFactory.forGenre(genre));
            return this.make(link, image, playbackButton, titles, subtitles);
        }
        forTrack(track, playbackButton = this.PlaybackButton.forTrack(track)) {
            let link = this.entityLinkFactory.forTrack(track);
            let image = this.ImageBox.forSquare(track.disc.album.artwork.map((image) => `/files/${image.file_id}/`).shift());
            let titles = [
                this.entityTitleFactory.forTrack(track)
            ];
            let subtitles = [
                ...track.artists.map((artist) => this.entityTitleFactory.forArtist(artist)),
                this.entityTitleFactory.forAlbum(track.disc.album)
            ];
            return this.make(link, image, playbackButton, titles, subtitles);
        }
        forUser(user) {
            let link = this.entityLinkFactory.forUser(user);
            let image = this.ImageBox.forSquare();
            let titles = [
                this.entityTitleFactory.forUser(user)
            ];
            let subtitles = [
                xnode.element("span").add(xnode.text(user.username))
            ];
            return this.make(link, image, undefined, titles, subtitles);
        }
        forYear(year) {
            let link = this.entityLinkFactory.forYear(year);
            let image = this.ImageBox.forSquare();
            let titles = [
                this.entityTitleFactory.forYear(year)
            ];
            let subtitles = [];
            return this.make(link, image, undefined, titles, subtitles);
        }
        static makeStyle() {
            return xnode.element("style")
                .add(xnode.text(CSS));
        }
    }
    exports.EntityRowFactory = EntityRowFactory;
    ;
});
define("build/ui/PlaybackButton", ["require", "exports", "build/api/schema/objects", "build/observers/index", "build/xnode/index", "build/ui/theme/index", "build/is"], function (require, exports, api, observables, xnode, theme, is) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PlaybackButtonFactory = void 0;
    const CSS = `
	.playback-button {
		background-color: ${theme.TEXT_0};
		border-radius: 50%;
		box-shadow: 0px 0px 8px 4px rgba(0, 0, 0, 0.25);
		cursor: pointer;
		fill: ${theme.BACKGROUND_2};
		padding: 8px;
		transition: transform 0.125s;
	}

	@media (hover: hover) and (pointer: fine) {
		.playback-button:not([data-enabled="false"]):hover {
			transform: scale(1.50);
		}

		.playback-button:active {
			transform: none;
		}
	}
`;
    class PlaybackButtonFactory {
        constructor(player, iconFactory) {
            this.player = player;
            this.iconFactory = iconFactory;
        }
        make(isContext, controller) {
            let isPlaying = observables.computed((isContext, playback) => {
                return isContext && playback;
            }, isContext, this.player.playback);
            return xnode.element("div.playback-button")
                .add(this.iconFactory.makePlay()
                .bind("data-hide", isPlaying.addObserver((isPlaying) => isPlaying)))
                .add(this.iconFactory.makePause()
                .bind("data-hide", isPlaying.addObserver((isPlaying) => !isPlaying)))
                .on("click", () => {
                if (isPlaying.getState()) {
                    this.player.pause();
                }
                else {
                    if (isContext.getState()) {
                        this.player.resume();
                    }
                    else {
                        controller();
                    }
                }
            });
        }
        forEntity(entity) {
            if (api.Album.is(entity)) {
                return this.forAlbum(entity);
            }
            if (api.Artist.is(entity)) {
                return this.forArtist(entity);
            }
            if (api.Cue.is(entity)) {
                return this.forCue(entity);
            }
            if (api.Disc.is(entity)) {
                return this.forDisc(entity);
            }
            if (api.Episode.is(entity)) {
                return this.forEpisode(entity);
            }
            if (api.Movie.is(entity)) {
                return this.forMovie(entity);
            }
            if (api.Playlist.is(entity)) {
                return this.forPlaylist(entity);
            }
            if (api.Season.is(entity)) {
                return this.forSeason(entity);
            }
            if (api.Show.is(entity)) {
                return this.forShow(entity);
            }
            if (api.Track.is(entity)) {
                return this.forTrack(entity);
            }
            throw `Expected code to be unreachable!`;
        }
        forAlbum(album, discIndex, trackIndex) {
            let isContext = observables.computed((contextPath) => {
                if (!is.present(contextPath)) {
                    return false;
                }
                if (is.present(discIndex)) {
                    let disc = album.discs[discIndex];
                    if (contextPath[contextPath.length - 2] !== disc.disc_id) {
                        return false;
                    }
                    if (is.present(trackIndex)) {
                        let track = disc.tracks[trackIndex];
                        if (contextPath[contextPath.length - 1] !== track.track_id) {
                            return false;
                        }
                    }
                }
                else {
                    if (contextPath[contextPath.length - 3] !== album.album_id) {
                        return false;
                    }
                }
                return true;
            }, this.player.contextPath);
            return this.make(isContext, () => this.player.playAlbum(album, discIndex, trackIndex));
        }
        forArtist(artist, albumIndex, discIndex, trackIndex) {
            let isContext = observables.computed((contextPath) => {
                if (!is.present(contextPath)) {
                    return false;
                }
                if (is.present(albumIndex)) {
                    let album = artist.albums[albumIndex];
                    if (contextPath[contextPath.length - 3] !== album.album_id) {
                        return false;
                    }
                    if (is.present(discIndex)) {
                        let disc = album.discs[discIndex];
                        if (contextPath[contextPath.length - 2] !== disc.disc_id) {
                            return false;
                        }
                        if (is.present(trackIndex)) {
                            let track = disc.tracks[trackIndex];
                            if (contextPath[contextPath.length - 1] !== track.track_id) {
                                return false;
                            }
                        }
                    }
                }
                else {
                    if (contextPath[contextPath.length - 4] !== artist.artist_id) {
                        return false;
                    }
                }
                return true;
            }, this.player.contextPath);
            return this.make(isContext, () => this.player.playArtist(artist, albumIndex, discIndex, trackIndex));
        }
        forCue(cue) {
            if (false) {
            }
            else if (api.Episode.is(cue.media)) {
                let episode = cue.media;
                let isContext = observables.computed((contextPath) => {
                    if (!is.present(contextPath)) {
                        return false;
                    }
                    if (contextPath[contextPath.length - 1] !== episode.episode_id) {
                        return false;
                    }
                    return true;
                }, this.player.contextPath);
                return this.make(isContext, () => {
                    this.player.playEpisode(episode);
                    this.player.seek(cue.start_ms / 1000);
                });
            }
            else if (api.Movie.is(cue.media)) {
                let movie = cue.media;
                let isContext = observables.computed((contextPath) => {
                    if (!is.present(contextPath)) {
                        return false;
                    }
                    if (contextPath[contextPath.length - 1] !== movie.movie_id) {
                        return false;
                    }
                    return true;
                }, this.player.contextPath);
                return this.make(isContext, () => {
                    this.player.playMovie(movie);
                    this.player.seek(cue.start_ms / 1000);
                });
            }
            throw `Expected code to be unreachable!`;
        }
        forDisc(disc, trackIndex) {
            let isContext = observables.computed((contextPath) => {
                if (!is.present(contextPath)) {
                    return false;
                }
                if (is.present(trackIndex)) {
                    let track = disc.tracks[trackIndex];
                    if (contextPath[contextPath.length - 1] !== track.track_id) {
                        return false;
                    }
                }
                else {
                    if (contextPath[contextPath.length - 2] !== disc.disc_id) {
                        return false;
                    }
                }
                return true;
            }, this.player.contextPath);
            return this.make(isContext, () => this.player.playDisc(disc, trackIndex));
        }
        forEpisode(episode) {
            let isContext = observables.computed((contextPath) => {
                if (!is.present(contextPath)) {
                    return false;
                }
                if (contextPath[contextPath.length - 1] !== episode.episode_id) {
                    return false;
                }
                return true;
            }, this.player.contextPath);
            return this.make(isContext, () => this.player.playEpisode(episode));
        }
        forMovie(movie) {
            let isContext = observables.computed((contextPath) => {
                if (!is.present(contextPath)) {
                    return false;
                }
                if (contextPath[contextPath.length - 1] !== movie.movie_id) {
                    return false;
                }
                return true;
            }, this.player.contextPath);
            return this.make(isContext, () => this.player.playMovie(movie));
        }
        forPlaylist(playlist, trackIndex) {
            let isContext = observables.computed((contextPath) => {
                if (!is.present(contextPath)) {
                    return false;
                }
                if (is.present(trackIndex)) {
                    let track = playlist.items[trackIndex].track;
                    if (contextPath[contextPath.length - 1] !== track.track_id) {
                        return false;
                    }
                }
                else {
                    if (contextPath[contextPath.length - 2] !== playlist.playlist_id) {
                        return false;
                    }
                }
                return true;
            }, this.player.contextPath);
            return this.make(isContext, () => this.player.playPlaylist(playlist, trackIndex));
        }
        forSeason(season, episodeIndex) {
            let isContext = observables.computed((contextPath) => {
                if (!is.present(contextPath)) {
                    return false;
                }
                if (is.present(episodeIndex)) {
                    let episode = season.episodes[episodeIndex];
                    if (contextPath[contextPath.length - 1] !== episode.episode_id) {
                        return false;
                    }
                }
                else {
                    if (contextPath[contextPath.length - 2] !== season.season_id) {
                        return false;
                    }
                }
                return true;
            }, this.player.contextPath);
            return this.make(isContext, () => this.player.playSeason(season, episodeIndex));
        }
        forShow(show, seasonIndex, episodeIndex) {
            let isContext = observables.computed((contextPath) => {
                if (!is.present(contextPath)) {
                    return false;
                }
                if (is.present(seasonIndex)) {
                    let season = show.seasons[seasonIndex];
                    if (contextPath[contextPath.length - 2] !== season.season_id) {
                        return false;
                    }
                    if (is.present(episodeIndex)) {
                        let episode = season.episodes[episodeIndex];
                        if (contextPath[contextPath.length - 1] !== episode.episode_id) {
                            return false;
                        }
                    }
                }
                else {
                    if (contextPath[contextPath.length - 3] !== show.show_id) {
                        return false;
                    }
                }
                return true;
            }, this.player.contextPath);
            return this.make(isContext, () => this.player.playShow(show, seasonIndex, episodeIndex));
        }
        forTrack(track) {
            let isContext = observables.computed((contextPath) => {
                if (!is.present(contextPath)) {
                    return false;
                }
                if (contextPath[contextPath.length - 1] !== track.track_id) {
                    return false;
                }
                return true;
            }, this.player.contextPath);
            return this.make(isContext, () => this.player.playTrack(track));
        }
        static makeStyle() {
            return xnode.element("style")
                .add(xnode.text(CSS));
        }
    }
    exports.PlaybackButtonFactory = PlaybackButtonFactory;
    ;
});
define("build/ui/EntityNavLinkFactory", ["require", "exports", "build/is", "build/ui/theme/index", "build/xnode/index"], function (require, exports, is, theme, xnode) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EntityNavLinkFactory = void 0;
    const CSS = `
	.entity-nav-link {
		display: grid;
		gap: 16px;
		grid-template-columns: max-content max-content;
		justify-content: center;
	}

	.entity-nav-link__last,
	.entity-nav-link__next {
		display: grid;
		gap: 8px;
		justify-items: center;
	}

	.entity-nav-link__title {
		color: ${theme.TEXT_1};
		font-size: 16px;
		overflow: hidden;
		text-overflow: ellipsis;
		white-space: nowrap;
	}
`;
    class EntityNavLinkFactory {
        constructor(iconFactory, entityLinkFactory) {
            this.iconFactory = iconFactory;
            this.entityLinkFactory = entityLinkFactory;
        }
        make(type, last, next) {
            let lastLink = is.absent(last) ? xnode.element("span") : this.entityLinkFactory.forEntity(last);
            let nextLink = is.absent(next) ? xnode.element("span") : this.entityLinkFactory.forEntity(next);
            return xnode.element("div.entity-nav-link")
                .add(lastLink.add(xnode.element("div.entity-nav-link__last")
                .add(xnode.element("div.icon-button")
                .set("data-enabled", `${is.present(last)}`)
                .add(this.iconFactory.makeChevron({ direction: "left" })))
                .add(xnode.element("div.entity-nav-link__title")
                .add(xnode.text(`Last ${type}`)))))
                .add(nextLink.add(xnode.element("div.entity-nav-link__next")
                .add(xnode.element("div.icon-button")
                .set("data-enabled", `${is.present(next)}`)
                .add(this.iconFactory.makeChevron()))
                .add(xnode.element("div.entity-nav-link__title")
                .add(xnode.text(`Next ${type}`)))));
        }
        forDisc(last, next) {
            return this.make("disc", last, next);
        }
        forEpisode(last, next) {
            return this.make("episode", last, next);
        }
        forSeason(last, next) {
            return this.make("season", last, next);
        }
        forTrack(last, next) {
            return this.make("track", last, next);
        }
        static makeStyle() {
            return xnode.element("style")
                .add(xnode.text(CSS));
        }
    }
    exports.EntityNavLinkFactory = EntityNavLinkFactory;
    ;
});
define("build/jsondb/sorters", ["require", "exports", "build/is"], function (require, exports, is) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NumericSort = exports.LexicalSort = exports.CustomSort = exports.CombinedSort = void 0;
    exports.CombinedSort = {
        of(...rankers) {
            return (one, two) => {
                for (let ranker of rankers) {
                    let rank = ranker(one, two);
                    if (rank !== 0) {
                        return rank;
                    }
                }
                return 0;
            };
        }
    };
    exports.CustomSort = {
        decreasing(getField) {
            return (one, two) => {
                let o = getField(one);
                let t = getField(two);
                if (is.absent(o)) {
                    if (is.absent(t)) {
                        return 0;
                    }
                    else {
                        return -1;
                    }
                }
                if (is.absent(t)) {
                    if (is.absent(o)) {
                        return 0;
                    }
                    else {
                        return 1;
                    }
                }
                return (t ? 1 : 0) - (o ? 1 : 0);
            };
        },
        increasing(getField) {
            return (one, two) => {
                let o = getField(one);
                let t = getField(two);
                if (is.absent(o)) {
                    if (is.absent(t)) {
                        return 0;
                    }
                    else {
                        return 1;
                    }
                }
                if (is.absent(t)) {
                    if (is.absent(o)) {
                        return 0;
                    }
                    else {
                        return -1;
                    }
                }
                return (o ? 1 : 0) - (t ? 1 : 0);
            };
        }
    };
    exports.LexicalSort = {
        decreasing(getField) {
            return (one, two) => {
                let o = getField(one);
                let t = getField(two);
                if (is.absent(o)) {
                    if (is.absent(t)) {
                        return 0;
                    }
                    else {
                        return -1;
                    }
                }
                if (is.absent(t)) {
                    if (is.absent(o)) {
                        return 0;
                    }
                    else {
                        return 1;
                    }
                }
                return t.localeCompare(o);
            };
        },
        increasing(getField) {
            return (one, two) => {
                let o = getField(one);
                let t = getField(two);
                if (is.absent(o)) {
                    if (is.absent(t)) {
                        return 0;
                    }
                    else {
                        return 1;
                    }
                }
                if (is.absent(t)) {
                    if (is.absent(o)) {
                        return 0;
                    }
                    else {
                        return -1;
                    }
                }
                return o.localeCompare(t);
            };
        }
    };
    exports.NumericSort = {
        decreasing(getField) {
            return (one, two) => {
                let o = getField(one);
                let t = getField(two);
                if (is.absent(o)) {
                    if (is.absent(t)) {
                        return 0;
                    }
                    else {
                        return -1;
                    }
                }
                if (is.absent(t)) {
                    if (is.absent(o)) {
                        return 0;
                    }
                    else {
                        return 1;
                    }
                }
                return t - o;
            };
        },
        increasing(getField) {
            return (one, two) => {
                let o = getField(one);
                let t = getField(two);
                if (is.absent(o)) {
                    if (is.absent(t)) {
                        return 0;
                    }
                    else {
                        return 1;
                    }
                }
                if (is.absent(t)) {
                    if (is.absent(o)) {
                        return 0;
                    }
                    else {
                        return -1;
                    }
                }
                return o - t;
            };
        }
    };
});
define("build/jsondb/indices", ["require", "exports", "node_modules/@joelek/ts-stdlib/build/index", "build/is", "build/jsondb/sorters"], function (require, exports, stdlib, is, sorters) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SearchIndex = exports.getTokens = exports.RecordIndex = exports.CollectionIndex = void 0;
    class CollectionIndex {
        constructor(lookupRecord, getPrimaryKey, getIndexedValue) {
            this.getPrimaryKeysFromIndexedValue = new Map();
            this.lookupRecord = lookupRecord;
            this.getPrimaryKey = getPrimaryKey;
            this.getIndexedValue = getIndexedValue;
        }
        insert(record) {
            let indexedValue = this.getIndexedValue(record);
            let primaryKeys = this.getPrimaryKeysFromIndexedValue.get(indexedValue);
            if (is.absent(primaryKeys)) {
                primaryKeys = new Set();
                this.getPrimaryKeysFromIndexedValue.set(indexedValue, primaryKeys);
            }
            let primaryKey = this.getPrimaryKey(record);
            primaryKeys.add(primaryKey);
        }
        lookup(key) {
            let primaryKeys = this.getPrimaryKeysFromIndexedValue.get(key);
            if (is.present(primaryKeys)) {
                return Array.from(primaryKeys).map(this.lookupRecord);
            }
            return new Array();
        }
        remove(record) {
            let indexedValue = this.getIndexedValue(record);
            let primaryKeys = this.getPrimaryKeysFromIndexedValue.get(indexedValue);
            if (is.present(primaryKeys)) {
                let primaryKey = this.getPrimaryKey(record);
                primaryKeys.delete(primaryKey);
                if (primaryKeys.size === 0) {
                    this.getPrimaryKeysFromIndexedValue.delete(indexedValue);
                }
            }
        }
        update(last, next) {
            this.remove(last);
            this.insert(next);
        }
        static fromIndex(parent, child, getIndexedValue) {
            let index = new CollectionIndex((key) => child.lookup(key), (record) => child.keyof(record), getIndexedValue);
            child.on("insert", (event) => {
                index.insert(event.next);
            });
            child.on("remove", (event) => {
                index.remove(event.last);
            });
            child.on("update", (event) => {
                index.update(event.last, event.next);
            });
            parent.on("remove", (event) => {
                let key = parent.keyof(event.last);
                for (let record of index.lookup(key)) {
                    child.remove(record);
                }
            });
            return index;
        }
        static fromTable(parent, child, getIndexedValue) {
            let index = new CollectionIndex((key) => child.lookup(key), (record) => child.keyof(record), getIndexedValue);
            child.on("insert", (event) => {
                index.insert(event.next);
            });
            child.on("remove", (event) => {
                index.remove(event.last);
            });
            child.on("update", (event) => {
                index.update(event.last, event.next);
            });
            parent.on("remove", (event) => {
                let key = parent.keyof(event.last);
                for (let record of index.lookup(key)) {
                    child.remove(record);
                }
            });
            return index;
        }
    }
    exports.CollectionIndex = CollectionIndex;
    ;
    class RecordIndex {
        constructor(getKey) {
            this.getRecordFromKey = new Map();
            this.getKey = getKey;
            this.router = new stdlib.routing.MessageRouter();
        }
        insertOrUpdate(next, action = "replace") {
            let key = this.getKey(next);
            let last = this.getRecordFromKey.get(key);
            if (is.present(last)) {
                if (action === "combine") {
                    for (let key in last) {
                        let lastValue = last[key];
                        let nextValue = next[key];
                        if (is.present(lastValue) && is.absent(nextValue)) {
                            next[key] = last[key];
                        }
                    }
                }
                this.getRecordFromKey.set(key, next);
                this.router.route("update", { last, next });
                this.router.route("*", {});
            }
            else {
                this.getRecordFromKey.set(key, next);
                this.router.route("insert", { next });
                this.router.route("*", {});
            }
        }
        [Symbol.iterator]() {
            return this.getRecordFromKey.values();
        }
        insert(record, action = "replace") {
            this.insertOrUpdate(record, action);
        }
        keyof(record) {
            return this.getKey(record);
        }
        length() {
            return this.getRecordFromKey.size;
        }
        lookup(key) {
            let record = this.getRecordFromKey.get(key);
            if (is.absent(record)) {
                throw `Expected "${key}" to match a record!`;
            }
            return record;
        }
        on(type, listener) {
            this.router.addObserver(type, listener);
            if (type === "insert") {
                for (let record of this.getRecordFromKey.values()) {
                    listener({ next: record });
                }
            }
        }
        off(type, listener) {
            this.router.addObserver(type, listener);
        }
        remove(record) {
            let key = this.getKey(record);
            if (this.getRecordFromKey.has(key)) {
                this.getRecordFromKey.delete(key);
                this.router.route("remove", { last: record });
                this.router.route("*", {});
            }
        }
        update(record, action = "replace") {
            this.insertOrUpdate(record, action);
        }
        static from(records, getKey) {
            let index = new RecordIndex(getKey);
            for (let record of records) {
                index.insert(record);
            }
            return index;
        }
    }
    exports.RecordIndex = RecordIndex;
    ;
    function getTokens(query) {
        let normalized = query;
        normalized = normalized.toLowerCase();
        normalized = normalized.normalize("NFKD");
        normalized = normalized.replace(/[\p{M}]/gu, "");
        return Array.from(normalized.match(/(\p{L}+|\p{N}+)/gu) ?? []);
    }
    exports.getTokens = getTokens;
    ;
    class SearchIndex {
        constructor(lookupRecord, getPrimaryKey, getIndexedValues, minTokenLength) {
            this.getPrimaryKeysFromToken = new Map();
            this.lookupRecord = lookupRecord;
            this.getPrimaryKey = getPrimaryKey;
            this.getIndexedValues = getIndexedValues;
            this.minTokenLength = minTokenLength;
        }
        insert(record) {
            for (let value of this.getIndexedValues(record)) {
                let tokens = getTokens(value).filter((token) => token.length >= this.minTokenLength);
                for (let token of tokens) {
                    let primaryKeys = this.getPrimaryKeysFromToken.get(token);
                    if (is.absent(primaryKeys)) {
                        primaryKeys = new Set();
                        this.getPrimaryKeysFromToken.set(token, primaryKeys);
                    }
                    let primaryKey = this.getPrimaryKey(record);
                    primaryKeys.add(primaryKey);
                }
            }
        }
        lookup(query) {
            let tokens = getTokens(query).filter((token) => token.length >= this.minTokenLength);
            let primaryKeySets = tokens.map((token) => {
                return this.getPrimaryKeysFromToken.get(token);
            }).filter(is.present);
            let map = new Map();
            for (let primaryKeys of primaryKeySets) {
                for (let primaryKey of primaryKeys) {
                    let rank = map.get(primaryKey) ?? (0 - tokens.length);
                    map.set(primaryKey, rank + 2);
                }
            }
            return Array.from(map.entries())
                .filter((entry) => entry[1] >= 0)
                .sort(sorters.NumericSort.decreasing((entry) => entry[1]))
                .map((entry) => ({
                id: entry[0],
                rank: entry[1]
            }));
        }
        remove(record) {
            for (let value of this.getIndexedValues(record)) {
                let tokens = getTokens(value);
                for (let token of tokens) {
                    let primaryKeys = this.getPrimaryKeysFromToken.get(token);
                    if (is.present(primaryKeys)) {
                        let primaryKey = this.getPrimaryKey(record);
                        primaryKeys.delete(primaryKey);
                        if (primaryKeys.size === 0) {
                            this.getPrimaryKeysFromToken.delete(token);
                        }
                    }
                }
            }
        }
        update(last, next) {
            this.remove(last);
            this.insert(next);
        }
        static fromIndex(records, getIndexedValues, minTokenLength = 0) {
            let index = new SearchIndex((key) => records.lookup(key), (record) => records.keyof(record), getIndexedValues, minTokenLength);
            records.on("insert", (event) => {
                index.insert(event.next);
            });
            records.on("remove", (event) => {
                index.remove(event.last);
            });
            records.on("update", (event) => {
                index.update(event.last, event.next);
            });
            return index;
        }
        static fromTable(records, getIndexedValues, minTokenLength = 0) {
            let index = new SearchIndex((key) => records.lookup(key), (record) => records.keyof(record), getIndexedValues, minTokenLength);
            records.on("insert", (event) => {
                index.insert(event.next);
            });
            records.on("remove", (event) => {
                index.remove(event.last);
            });
            records.on("update", (event) => {
                index.update(event.last, event.next);
            });
            return index;
        }
    }
    exports.SearchIndex = SearchIndex;
    ;
});
define("build/jsondb/index", ["require", "exports", "build/jsondb/indices", "build/jsondb/sorters", "build/jsondb/indices", "build/jsondb/indices", "build/jsondb/indices", "build/jsondb/sorters", "build/jsondb/sorters", "build/jsondb/sorters", "build/jsondb/sorters"], function (require, exports, indices, sorters, indices_1, indices_2, indices_3, sorters_1, sorters_2, sorters_3, sorters_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NumericSort = exports.LexicalSort = exports.CustomSort = exports.CombinedSort = exports.SearchIndex = exports.RecordIndex = exports.CollectionIndex = exports.sorters = exports.indices = void 0;
    exports.indices = indices;
    exports.sorters = sorters;
    Object.defineProperty(exports, "CollectionIndex", { enumerable: true, get: function () { return indices_1.CollectionIndex; } });
    Object.defineProperty(exports, "RecordIndex", { enumerable: true, get: function () { return indices_2.RecordIndex; } });
    Object.defineProperty(exports, "SearchIndex", { enumerable: true, get: function () { return indices_3.SearchIndex; } });
    Object.defineProperty(exports, "CombinedSort", { enumerable: true, get: function () { return sorters_1.CombinedSort; } });
    Object.defineProperty(exports, "CustomSort", { enumerable: true, get: function () { return sorters_2.CustomSort; } });
    Object.defineProperty(exports, "LexicalSort", { enumerable: true, get: function () { return sorters_3.LexicalSort; } });
    Object.defineProperty(exports, "NumericSort", { enumerable: true, get: function () { return sorters_4.NumericSort; } });
});
define("build/playlists/schema/messages", ["require", "exports", "build/api/schema/objects", "build/api/schema/objects", "node_modules/@joelek/ts-autoguard/build/autoguard-lib/index"], function (require, exports, objects_12, objects_13, ts_autoguard_7) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Autoguard = exports.UpdatePlaylistItem = exports.UpdatePlaylistItemResponse = exports.UpdatePlaylistItemRequest = exports.DeletePlaylistItem = exports.DeletePlaylistItemResponse = exports.DeletePlaylistItemRequest = exports.CreatePlaylistItem = exports.CreatePlaylistItemResponse = exports.CreatePlaylistItemRequest = exports.UpdatePlaylist = exports.UpdatePlaylistResponse = exports.UpdatePlaylistRequest = exports.DeletePlaylist = exports.DeletePlaylistResponse = exports.DeletePlaylistRequest = exports.CreatePlaylist = exports.CreatePlaylistResponse = exports.CreatePlaylistRequest = exports.PermissionsResponse = exports.PermissionsRequest = exports.SetToken = void 0;
    exports.SetToken = ts_autoguard_7.guards.Object.of({
        "token": ts_autoguard_7.guards.Union.of(ts_autoguard_7.guards.Undefined, ts_autoguard_7.guards.String)
    });
    exports.PermissionsRequest = ts_autoguard_7.guards.Object.of({
        "playlist": ts_autoguard_7.guards.Object.of({
            "playlist_id": ts_autoguard_7.guards.String
        })
    });
    exports.PermissionsResponse = ts_autoguard_7.guards.Object.of({
        "permissions": ts_autoguard_7.guards.Union.of(ts_autoguard_7.guards.StringLiteral.of("read"), ts_autoguard_7.guards.StringLiteral.of("write"))
    });
    exports.CreatePlaylistRequest = ts_autoguard_7.guards.Object.of({
        "playlist": ts_autoguard_7.guards.Object.of({
            "title": ts_autoguard_7.guards.String,
            "description": ts_autoguard_7.guards.String
        })
    });
    exports.CreatePlaylistResponse = ts_autoguard_7.guards.Object.of({
        "errors": ts_autoguard_7.guards.Array.of(ts_autoguard_7.guards.String),
        "playlist_id": ts_autoguard_7.guards.String
    });
    exports.CreatePlaylist = ts_autoguard_7.guards.Object.of({
        "playlist": ts_autoguard_7.guards.Reference.of(() => objects_12.PlaylistBase)
    });
    exports.DeletePlaylistRequest = ts_autoguard_7.guards.Object.of({
        "playlist": ts_autoguard_7.guards.Object.of({
            "playlist_id": ts_autoguard_7.guards.String
        })
    });
    exports.DeletePlaylistResponse = ts_autoguard_7.guards.Object.of({
        "errors": ts_autoguard_7.guards.Array.of(ts_autoguard_7.guards.String)
    });
    exports.DeletePlaylist = ts_autoguard_7.guards.Object.of({
        "playlist": ts_autoguard_7.guards.Reference.of(() => objects_12.PlaylistBase)
    });
    exports.UpdatePlaylistRequest = ts_autoguard_7.guards.Object.of({
        "playlist": ts_autoguard_7.guards.Object.of({
            "playlist_id": ts_autoguard_7.guards.String,
            "title": ts_autoguard_7.guards.String,
            "description": ts_autoguard_7.guards.String
        })
    });
    exports.UpdatePlaylistResponse = ts_autoguard_7.guards.Object.of({
        "errors": ts_autoguard_7.guards.Array.of(ts_autoguard_7.guards.String)
    });
    exports.UpdatePlaylist = ts_autoguard_7.guards.Object.of({
        "playlist": ts_autoguard_7.guards.Reference.of(() => objects_12.PlaylistBase)
    });
    exports.CreatePlaylistItemRequest = ts_autoguard_7.guards.Object.of({
        "playlist_item": ts_autoguard_7.guards.Object.of({
            "playlist_id": ts_autoguard_7.guards.String,
            "track_id": ts_autoguard_7.guards.String
        })
    });
    exports.CreatePlaylistItemResponse = ts_autoguard_7.guards.Object.of({
        "errors": ts_autoguard_7.guards.Array.of(ts_autoguard_7.guards.String),
        "playlist_item_id": ts_autoguard_7.guards.String
    });
    exports.CreatePlaylistItem = ts_autoguard_7.guards.Object.of({
        "playlist_item": ts_autoguard_7.guards.Reference.of(() => objects_13.PlaylistItemBase)
    });
    exports.DeletePlaylistItemRequest = ts_autoguard_7.guards.Object.of({
        "playlist_item": ts_autoguard_7.guards.Object.of({
            "playlist_item_id": ts_autoguard_7.guards.String
        })
    });
    exports.DeletePlaylistItemResponse = ts_autoguard_7.guards.Object.of({
        "errors": ts_autoguard_7.guards.Array.of(ts_autoguard_7.guards.String)
    });
    exports.DeletePlaylistItem = ts_autoguard_7.guards.Object.of({
        "playlist_item": ts_autoguard_7.guards.Reference.of(() => objects_13.PlaylistItemBase)
    });
    exports.UpdatePlaylistItemRequest = ts_autoguard_7.guards.Object.of({
        "playlist_item": ts_autoguard_7.guards.Object.of({
            "playlist_item_id": ts_autoguard_7.guards.String,
            "number": ts_autoguard_7.guards.Number
        })
    });
    exports.UpdatePlaylistItemResponse = ts_autoguard_7.guards.Object.of({
        "errors": ts_autoguard_7.guards.Array.of(ts_autoguard_7.guards.String)
    });
    exports.UpdatePlaylistItem = ts_autoguard_7.guards.Object.of({
        "playlist_item": ts_autoguard_7.guards.Reference.of(() => objects_13.PlaylistItemBase)
    });
    exports.Autoguard = {
        "SetToken": exports.SetToken,
        "PermissionsRequest": exports.PermissionsRequest,
        "PermissionsResponse": exports.PermissionsResponse,
        "CreatePlaylistRequest": exports.CreatePlaylistRequest,
        "CreatePlaylistResponse": exports.CreatePlaylistResponse,
        "CreatePlaylist": exports.CreatePlaylist,
        "DeletePlaylistRequest": exports.DeletePlaylistRequest,
        "DeletePlaylistResponse": exports.DeletePlaylistResponse,
        "DeletePlaylist": exports.DeletePlaylist,
        "UpdatePlaylistRequest": exports.UpdatePlaylistRequest,
        "UpdatePlaylistResponse": exports.UpdatePlaylistResponse,
        "UpdatePlaylist": exports.UpdatePlaylist,
        "CreatePlaylistItemRequest": exports.CreatePlaylistItemRequest,
        "CreatePlaylistItemResponse": exports.CreatePlaylistItemResponse,
        "CreatePlaylistItem": exports.CreatePlaylistItem,
        "DeletePlaylistItemRequest": exports.DeletePlaylistItemRequest,
        "DeletePlaylistItemResponse": exports.DeletePlaylistItemResponse,
        "DeletePlaylistItem": exports.DeletePlaylistItem,
        "UpdatePlaylistItemRequest": exports.UpdatePlaylistItemRequest,
        "UpdatePlaylistItemResponse": exports.UpdatePlaylistItemResponse,
        "UpdatePlaylistItem": exports.UpdatePlaylistItem
    };
});
define("build/playlists/client", ["require", "exports", "build/observers/index", "build/jsondb/index", "build/playlists/schema/messages", "build/typesockets/client"], function (require, exports, observers, jsondb, messages, typesockets) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PlaylistsClient = void 0;
    class PlaylistsClient {
        constructor(url, factory = (url) => new WebSocket(url)) {
            this.token = new observers.ObservableClass(undefined);
            this.online = new observers.ObservableClass(false);
            this.playlists = new observers.ArrayObservable(new Array());
            this.tsc = new typesockets.TypeSocketClient(url, factory, messages.Autoguard);
            this.tsc.addEventListener("sys", "connect", () => {
                this.online.updateState(true);
            });
            this.tsc.addEventListener("sys", "disconnect", () => {
                this.online.updateState(false);
            });
            observers.computed((isOnline, token) => {
                if (isOnline) {
                    this.tsc.send("SetToken", {
                        token
                    });
                }
            }, this.online, this.token);
            this.tsc.addEventListener("app", "CreatePlaylist", (message) => {
                let deletions = 0;
                for (let [index, playlist] of this.playlists.getState().entries()) {
                    let state = playlist.getState();
                    if (state.playlist_id === message.playlist.playlist_id) {
                        this.playlists.splice(index - deletions);
                    }
                }
                let playlist = {
                    ...message.playlist,
                    items: new Array()
                };
                this.playlists.append(new observers.ObservableClass(playlist));
            });
            this.tsc.addEventListener("app", "DeletePlaylist", (message) => {
                let deletions = 0;
                for (let [index, playlist] of this.playlists.getState().entries()) {
                    let state = playlist.getState();
                    if (state.playlist_id === message.playlist.playlist_id) {
                        this.playlists.splice(index - deletions);
                    }
                }
            });
            this.tsc.addEventListener("app", "UpdatePlaylist", (message) => {
                for (let [index, playlist] of this.playlists.getState().entries()) {
                    let state = playlist.getState();
                    if (state.playlist_id === message.playlist.playlist_id) {
                        playlist.updateState({
                            ...state,
                            ...message.playlist
                        });
                    }
                }
            });
            this.tsc.addEventListener("app", "CreatePlaylistItem", (message) => {
                for (let [index, playlist] of this.playlists.getState().entries()) {
                    let state = playlist.getState();
                    if (state.playlist_id === message.playlist_item.playlist.playlist_id) {
                        let items = state.items.filter((item) => item.playlist_item_id !== message.playlist_item.playlist_item_id);
                        let deletions = state.items.length - items.length;
                        items.push(message.playlist_item);
                        let additions = 1;
                        items = items
                            .map((item) => ({
                            ...item,
                            number: item.number + (item.number > message.playlist_item.number ? additions - deletions : 0)
                        }))
                            .sort(jsondb.NumericSort.increasing((record) => record.number));
                        state = {
                            ...state,
                            items: items
                        };
                        playlist.updateState(state);
                    }
                }
            });
            this.tsc.addEventListener("app", "DeletePlaylistItem", (message) => {
                for (let [index, playlist] of this.playlists.getState().entries()) {
                    let state = playlist.getState();
                    if (state.playlist_id === message.playlist_item.playlist.playlist_id) {
                        let items = state.items.filter((item) => item.playlist_item_id !== message.playlist_item.playlist_item_id);
                        let deletions = state.items.length - items.length;
                        let additions = 0;
                        items = items
                            .map((item) => ({
                            ...item,
                            number: item.number + (item.number > message.playlist_item.number ? additions - deletions : 0)
                        }))
                            .sort(jsondb.NumericSort.increasing((record) => record.number));
                        state = {
                            ...state,
                            items: items
                        };
                        playlist.updateState(state);
                    }
                }
            });
            this.tsc.addEventListener("app", "UpdatePlaylistItem", (message) => {
                for (let [index, playlist] of this.playlists.getState().entries()) {
                    let state = playlist.getState();
                    if (state.playlist_id === message.playlist_item.playlist.playlist_id) {
                        let old_index = state.items.findIndex((item) => item.playlist_item_id === message.playlist_item.playlist_item_id);
                        if (old_index >= 0) {
                            let new_index = message.playlist_item.number - 1;
                            if (new_index > old_index) {
                                for (let i = old_index + 1; i < new_index; i++) {
                                    state.items[i].number -= 1;
                                }
                                state.items.splice(new_index, 0, ...state.items.splice(old_index, 1));
                            }
                            else if (new_index < old_index) {
                                for (let i = new_index; i < old_index; i++) {
                                    state.items[i].number += 1;
                                }
                                state.items.splice(new_index, 0, ...state.items.splice(old_index, 1));
                            }
                            state.items[new_index] = {
                                ...state.items[new_index],
                                ...message.playlist_item
                            };
                            playlist.updateState({
                                ...state
                            });
                        }
                    }
                }
            });
        }
        authenticate(token) {
            this.token.updateState(token);
        }
        isOnline() {
            return this.online.getState();
        }
        getPermissions(request) {
            return this.tsc.request("PermissionsRequest", "PermissionsResponse", request);
        }
        createPlaylist(request) {
            return this.tsc.request("CreatePlaylistRequest", "CreatePlaylistResponse", request);
        }
        deletePlaylist(request) {
            return this.tsc.request("DeletePlaylistRequest", "DeletePlaylistResponse", request);
        }
        updatePlaylist(request) {
            return this.tsc.request("UpdatePlaylistRequest", "UpdatePlaylistResponse", request);
        }
        createPlaylistItem(request) {
            return this.tsc.request("CreatePlaylistItemRequest", "CreatePlaylistItemResponse", request);
        }
        deletePlaylistItem(request) {
            return this.tsc.request("DeletePlaylistItemRequest", "DeletePlaylistItemResponse", request);
        }
        updatePlaylistItem(request) {
            return this.tsc.request("UpdatePlaylistItemRequest", "UpdatePlaylistItemResponse", request);
        }
        close() {
            this.tsc.close();
        }
        reconnect() {
            this.tsc.reconnect();
        }
    }
    exports.PlaylistsClient = PlaylistsClient;
    ;
});
define("build/client/client", ["require", "exports", "build/languages", "build/client/browserMediaSession", "build/observers/index", "build/player/client", "build/is", "build/api/schema/objects", "build/xnode/index", "build/api/schema/index", "build/ui/EntityTitleFactory", "build/ui/Grid", "build/ui/CarouselFactory", "build/ui/Icon", "build/ui/ImageBox", "build/ui/EntityLink", "build/ui/EntityCard", "build/ui/EntityRow", "build/ui/PlaybackButton", "build/ui/EntityNavLinkFactory", "build/playlists/client"], function (require, exports, languages, session, observers_2, client, is, objects_14, xml, apischema, EntityTitleFactory_1, Grid_1, CarouselFactory_1, Icon_1, ImageBox_1, EntityLink_1, EntityCard_1, EntityRow_1, PlaybackButton_1, EntityNavLinkFactory_1, client_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function makeUrl(tail) {
        let path = `/sockets/${tail}`;
        let protocol = window.location.protocol === "https:" ? "wss:" : "ws:";
        let host = window.location.host;
        return `${protocol}//${host}${path}`;
    }
    let player = new client.ContextClient(makeUrl(`context/?type=browser&name=Client`));
    let playlists = new client_1.PlaylistsClient(makeUrl(`playlists/`));
    window.addEventListener("focus", () => {
        if (!player.isOnline.getState()) {
            player.reconnect();
        }
        if (!playlists.isOnline()) {
            playlists.reconnect();
        }
        req("/discover", {}, () => { });
    });
    window.addEventListener("keydown", (event) => {
        if (event.code === "Space") {
            if (event.target instanceof HTMLInputElement) {
                return;
            }
            event.preventDefault();
            event.stopPropagation();
            player.toggle();
        }
        else if (event.code === "Escape") {
            event.preventDefault();
            event.stopPropagation();
            showDevices.updateState(false);
            showContextMenu.updateState(false);
        }
    });
    let lastVideo = document.createElement("video");
    let currentVideo = document.createElement("video");
    let nextVideo = document.createElement("video");
    currentVideo.addEventListener("ended", () => {
        player.next();
    });
    let isLoading = new observers_2.ObservableClass(true);
    currentVideo.addEventListener("loadeddata", () => {
        isLoading.updateState(false);
    });
    currentVideo.addEventListener("playing", () => {
        player.isCurrentEntryVideo.updateState(currentVideo.videoWidth > 0 && currentVideo.videoHeight > 0);
    });
    {
        let computer = async () => {
            if (!isLoading.getState()) {
                currentVideo.currentTime = player.progress.getState() ?? 0;
            }
        };
        player.progress.addObserver(computer);
        isLoading.addObserver(computer);
    }
    {
        let computer = async () => {
            if (!isLoading.getState()) {
                if (player.playback.getState()) {
                    try {
                        await currentVideo.play();
                    }
                    catch (error) { }
                }
                else {
                    currentVideo.pause();
                }
            }
        };
        player.playback.addObserver(computer);
        isLoading.addObserver(computer);
    }
    {
        let computer = () => {
            let canPlayLast = player.canPlayLast.getState();
            let canPlayCurrent = player.canPlayCurrent.getState();
            let canPlayNext = player.canPlayNext.getState();
            session.setHandlers({
                play: canPlayCurrent ? player.resume.bind(player) : undefined,
                pause: canPlayCurrent ? player.pause.bind(player) : undefined,
                previoustrack: canPlayLast ? player.last.bind(player) : undefined,
                nexttrack: canPlayNext ? player.next.bind(player) : undefined
            });
        };
        player.canPlayLast.addObserver(computer);
        player.canPlayCurrent.addObserver(computer);
        player.canPlayNext.addObserver(computer);
    }
    let mediaPlayerTitle = new observers_2.ObservableClass("");
    let mediaPlayerSubtitle = new observers_2.ObservableClass("");
    player.currentEntry.addObserver((currentEntry) => {
        if (is.present(currentEntry)) {
            if (objects_14.Episode.is(currentEntry)) {
                let episode = currentEntry;
                let season = episode.season;
                let show = season.show;
                mediaPlayerTitle.updateState(episode.title);
                mediaPlayerSubtitle.updateState([show.title, `Season ${episode.season.number}`].join(" \u00b7 "));
                session.setMetadata({
                    title: episode.title
                });
            }
            else if (objects_14.Movie.is(currentEntry)) {
                let movie = currentEntry;
                mediaPlayerTitle.updateState(movie.title);
                mediaPlayerSubtitle.updateState(movie.genres.map((genre) => genre.title).join(" \u00b7 "));
                session.setMetadata({
                    title: movie.title,
                    artwork: movie.artwork.map((image) => ({
                        src: `/files/${image.file_id}/?token=${token}`,
                        sizes: `${image.width}x${image.height}`,
                        type: image.mime
                    }))
                });
            }
            else if (objects_14.Track.is(currentEntry)) {
                let track = currentEntry;
                let disc = track.disc;
                let album = disc.album;
                mediaPlayerTitle.updateState(track.title);
                mediaPlayerSubtitle.updateState([...track.artists.map((artist) => artist.title), track.disc.album.title].join(" \u00b7 "));
                session.setMetadata({
                    title: track.title,
                    artist: track.artists.map((artist) => artist.title).join(" \u00b7 "),
                    album: album.title,
                    artwork: album.artwork.map((image) => ({
                        src: `/files/${image.file_id}/?token=${token}`,
                        sizes: `${image.width}x${image.height}`,
                        type: image.mime
                    }))
                });
            }
            else {
                throw `Expected code to be unreachable!`;
            }
        }
        else {
            mediaPlayerTitle.updateState("");
            mediaPlayerSubtitle.updateState("");
            session.setMetadata({});
        }
    });
    {
        let computer = () => {
            let lastLocalEntry = player.lastLocalEntry.getState();
            let token = player.token.getState();
            if (is.absent(lastLocalEntry) || is.absent(token)) {
                lastVideo.src = ``;
                return;
            }
            else {
                lastVideo.src = `/files/${lastLocalEntry.media.file_id}/?token=${token}`;
            }
        };
        player.lastLocalEntry.addObserver(computer);
        player.token.addObserver(computer);
    }
    {
        let computer = () => {
            isLoading.updateState(true);
            let currentLocalEntry = player.currentLocalEntry.getState();
            let token = player.token.getState();
            if (is.absent(currentLocalEntry) || is.absent(token)) {
                currentVideo.src = ``;
                return;
            }
            else {
                currentVideo.src = `/files/${currentLocalEntry.media.file_id}/?token=${token}`;
                currentVideo.load();
            }
            while (currentVideo.lastChild != null) {
                currentVideo.removeChild(currentVideo.lastChild);
            }
            if (objects_14.Movie.is(currentLocalEntry) || objects_14.Episode.is(currentLocalEntry)) {
                let subtitles = currentLocalEntry.subtitles;
                let defaultSubtitle = subtitles.find((subtitle) => subtitle.language === "swe") ?? subtitles.find((subtitle) => subtitle.language === "eng") ?? subtitles.find((subtitle) => true);
                for (let subtitle of subtitles) {
                    let element = document.createElement("track");
                    element.src = `/files/${subtitle.file_id}/?token=${token}`;
                    if (is.present(subtitle.language)) {
                        let language = languages.db[subtitle.language];
                        if (is.present(language)) {
                            element.label = language.title;
                            element.srclang = language.iso639_1;
                            element.kind = "subtitles";
                        }
                    }
                    if (subtitle === defaultSubtitle) {
                        element.setAttribute("default", "");
                    }
                    currentVideo.appendChild(element);
                }
            }
        };
        player.currentLocalEntry.addObserver(computer);
        player.token.addObserver(computer);
    }
    {
        let computer = () => {
            let nextLocalEntry = player.nextLocalEntry.getState();
            let token = player.token.getState();
            if (is.absent(nextLocalEntry) || is.absent(token)) {
                lastVideo.src = ``;
                return;
            }
            else {
                lastVideo.src = `/files/${nextLocalEntry.media.file_id}/?token=${token}`;
            }
        };
        player.nextLocalEntry.addObserver(computer);
        player.token.addObserver(computer);
    }
    const tokenobs = new observers_2.ObservableClass(localStorage.getItem("token") ?? undefined);
    const contextMenuEntity = new observers_2.ObservableClass(undefined);
    const showContextMenu = new observers_2.ObservableClass(false);
    const contextMenuItems = new observers_2.ArrayObservable(new Array());
    contextMenuEntity.addObserver((contextMenuEntity) => {
        if (apischema.objects.Track.is(contextMenuEntity)) {
            let title = new observers_2.ObservableClass("");
            let canCreate = observers_2.computed((title) => {
                if (title === "") {
                    return false;
                }
                return true;
            }, title);
            let doCreate = async () => {
                if (canCreate.getState()) {
                    let playlist = await playlists.createPlaylist({
                        playlist: {
                            title: title.getState(),
                            description: ""
                        }
                    });
                    if (playlist.errors.length > 0) {
                        return;
                    }
                    let playlist_item = await playlists.createPlaylistItem({
                        playlist_item: {
                            playlist_id: playlist.playlist_id,
                            track_id: contextMenuEntity.track_id
                        }
                    });
                    if (playlist_item.errors.length > 0) {
                        return;
                    }
                    showContextMenu.updateState(false);
                }
            };
            contextMenuItems.update([
                xml.element("div")
                    .set("style", "align-items: center; display: grid; gap: 16px; grid-template-columns: 1fr min-content;")
                    .add(renderTextHeader(xml.text("Add to playlist")))
                    .add(makeButton()
                    .on("click", () => {
                    showContextMenu.updateState(false);
                })
                    .add(Icon.makeCross())),
                EntityRow.forTrack(contextMenuEntity),
                xml.element("div")
                    .set("style", "display: grid; gap: 16px;")
                    .add(xml.element("div")
                    .set("style", "position: relative;")
                    .add(xml.element("input")
                    .bind2("value", title)
                    .set("type", "text")
                    .set("spellcheck", "false")
                    .set("placeholder", "Playlist title")
                    .on("keyup", async (event) => {
                    if (event.code === "Enter") {
                        await doCreate();
                    }
                }))
                    .add(Icon.makeStar()
                    .set("style", "fill: rgb(255, 255, 255); position: absolute; left: 0px; top: 50%; transform: translate(100%, -50%);")))
                    .add(xml.element("button")
                    .bind2("data-enabled", observers_2.computed((canCreate) => "" + canCreate, canCreate))
                    .add(xml.text("New playlist"))
                    .on("click", async () => {
                    await doCreate();
                })),
                xml.element("div")
                    .set("style", "display: grid; gap: 16px;")
                    .bind("data-hide", playlists.playlists.compute((playlists) => playlists.length === 0))
                    .repeat(playlists.playlists, (playlist) => xml.element("div")
                    .set("style", "align-items: center; cursor: pointer; display: grid; fill: rgb(255, 255, 255); gap: 16px; grid-template-columns: min-content 1fr;")
                    .on("click", async () => {
                    let playlist_item = await playlists.createPlaylistItem({
                        playlist_item: {
                            playlist_id: playlist.getState().playlist_id,
                            track_id: contextMenuEntity.track_id
                        }
                    });
                    if (playlist_item.errors.length > 0) {
                        return;
                    }
                    showContextMenu.updateState(false);
                })
                    .add(Icon.makeChevron())
                    .add(renderTextHeader(xml.text(playlist.getState().title))))
            ]);
            showContextMenu.updateState(true);
        }
        else {
            showContextMenu.updateState(false);
        }
    });
    const Grid = new Grid_1.GridFactory();
    document.head.appendChild(Grid_1.GridFactory.makeStyle().render());
    const Icon = new Icon_1.IconFactory();
    document.head.appendChild(Icon_1.IconFactory.makeStyle().render());
    const carouselFactory = new CarouselFactory_1.CarouselFactory(Icon);
    document.head.appendChild(CarouselFactory_1.CarouselFactory.makeStyle().render());
    const PlaybackButton = new PlaybackButton_1.PlaybackButtonFactory(player, Icon);
    document.head.appendChild(PlaybackButton_1.PlaybackButtonFactory.makeStyle().render());
    const ImageBox = new ImageBox_1.ImageBoxFactory(tokenobs);
    document.head.appendChild(ImageBox_1.ImageBoxFactory.makeStyle().render());
    const EntityLink = new EntityLink_1.EntityLinkFactory(navigate, contextMenuEntity);
    document.head.appendChild(EntityLink_1.EntityLinkFactory.makeStyle().render());
    const entityTitleFactory = new EntityTitleFactory_1.EntityTitleFactory(EntityLink);
    document.head.appendChild(EntityTitleFactory_1.EntityTitleFactory.makeStyle().render());
    const EntityCard = new EntityCard_1.EntityCardFactory(entityTitleFactory, EntityLink, ImageBox, PlaybackButton);
    document.head.appendChild(EntityCard_1.EntityCardFactory.makeStyle().render());
    const EntityRow = new EntityRow_1.EntityRowFactory(entityTitleFactory, EntityLink, ImageBox, PlaybackButton);
    document.head.appendChild(EntityRow_1.EntityRowFactory.makeStyle().render());
    const entityNavLinkFactory = new EntityNavLinkFactory_1.EntityNavLinkFactory(Icon, EntityLink);
    document.head.appendChild(EntityNavLinkFactory_1.EntityNavLinkFactory.makeStyle().render());
    const ACCENT_COLOR = "rgb(223, 79, 127)";
    let style = document.createElement('style');
    style.innerText = `
	::-webkit-scrollbar {
		background-color: transparent;
		height: 8px;
		width: 8px;
	}

	::-webkit-scrollbar-corner {
		background-color: transparent;
	}

	::-webkit-scrollbar-thumb {
		background-color: rgba(255, 255, 255, 0.125);
		border-radius: 4px;
	}

	* {
		border: none;
		font-size: 0px;
		margin: 0px;
		line-height: 1;
		outline: none;
		padding: 0px;
	}

	a,
	span {
		color: inherit;
		font-size: inherit;
	}

	a {
		text-decoration: none;
		transition: color 0.125s;
	}

	@media (hover: hover) and (pointer: fine) {
		a:hover {
			color: rgb(255, 255, 255);
		}
	}

	html {
		height: 100%;
	}

	body {
		height: 100%;
	}

	.page-header {
		align-items: center;
		display: grid;
		gap: 16px;
		grid-template-columns: 1fr auto;
	}

	.page-header__title {
		color: rgb(255, 255, 255);
		cursor: pointer;
		font-family: "Pacifico", cursive;
		font-size: 32px;
		transform-origin: left;
		transition: transform 0.125s;
		white-space: nowrap;
	}

	.page-header__controls {
		display: grid;
		gap: 8px;
		grid-auto-columns: minmax(auto, min-content);
		grid-auto-flow: column;
	}

	@media (hover: hover) and (pointer: fine) {
		.page-header__title:hover {
			transform: scale(1.25);
		}
	}

	[data-hide="true"] {
		display: none !important;
	}

	body {
		background-color: ${ACCENT_COLOR};
		color: rgb(255, 255, 255);
		font-family: "Nunito", sans-serif;
		overflow: hidden;
		touch-callout: none;
			-webkit-touch-callout: none;
			-moz-touch-callout: none;
			-ms-touch-callout: none;
			-o-touch-callout: none;
		user-select: none;
			-webkit-user-select: none;
			-moz-user-select: none;
			-ms-user-select: none;
			-o-user-select: none;
	}

	body ::selection {
		background-color: ${ACCENT_COLOR};
		color: rgb(255, 255, 255);
	}

	button {
		background-color: ${ACCENT_COLOR};
		border-radius: 64px;
		color: rgb(255, 255, 255);
		cursor: pointer;
		font-size: 16px;
		padding: 8px 16px;
		transition: background-color 0.125s, color 0.125s;
	}

	button[data-enabled="false"] {
		background-color: rgb(79, 79, 79);
		color: rgb(159, 159, 159);
		cursor: default;
	}

	@media (hover: hover) and (pointer: fine) {
		button:not([data-enabled="false"]):hover {
			background-color: rgb(255, 255, 255);
			color: rgb(31, 31, 31);
		}

		button:active {
			transform: none;
		}
	}

	input {
		background-color: rgb(47, 47, 47);
		border-radius: 64px;
		box-sizing: border-box;
		color: rgb(255, 255, 255);
		font-size: 16px;
		padding: 8px 16px 8px 40px;
		width: 100%;
	}















	.slider-widget {
		padding: 4px;
	}

	.slider-widget__indicator {
		padding: 4px;
		border-radius: 4px;
		background-color: rgb(31, 31, 31);
	}

	.slider-widget__knob-wrapper {
		position: relative;
	}

	.slider-widget__knob {
		box-shadow: 0px 0px 8px 0px rgba(0, 0, 0, 0.5);
		width: 16px;
		height: 16px;
		border-radius: 50%;
		background-color: rgb(255, 255, 255);
		position: absolute;
		top: 0%;
		left: 0%;
		margin-top: -8px;
		margin-left: -8px;
	}



























	.content {
		box-sizing: border-box;
		display: grid;
		gap: 48px;
		margin: 0px auto;
		max-width: 1080px;
		padding: 24px;
	}

	.content--narrow {
		max-width: 480px;
	}












	.text-header {
		color: rgb(255, 255, 255);
		font-size: 20px;
		overflow: hidden;
		text-overflow: ellipsis;
		white-space: nowrap;
	}

	.text-paragraph {
		color: rgb(159, 159, 159);
		font-size: 16px;
		line-height: 1.25;
		word-break: break-word;
	}












































	.login-modal {
		display: grid;
		gap: 64px;
	}

	.login-modal__form {
		display: grid;
		gap: 16px;
	}








	.modal-container {
		background-color: rgb(31, 31, 31);
		height: 100%;
		position: absolute;
		width: 100%;
		z-index: 1;
	}

	.modal-container[data-hide] {
		display: initial!important;
	}

	.modal-container[data-hide=false] {
		transform: translate(0%, -100%);
		transition: transform 0.5s;
	}

	.modal-container[data-hide=true] {
		transform: none;
		transition: none;
	}









	.device-selector {
		display: grid;
		gap: 64px;
	}

	.device-selector__devices {
		display: grid;
		gap: 16px;
	}

	.device-selector__device {
		align-items: center;
		cursor: pointer;
		display: grid;
		gap: 16px;
		grid-template-columns: min-content 1fr;
	}

	.device-selector__device-info {
		display: grid;
		gap: 8px;
	}

	.device-selector__device-name {
		color: rgb(255, 255, 255);
		font-size: 16px;
		overflow: hidden;
		text-overflow: ellipsis;
		white-space: nowrap;
	}

	.device-selector__device-type {
		color: rgb(159, 159, 159);
		font-size: 16px;
		overflow: hidden;
		text-overflow: ellipsis;
		white-space: nowrap;
	}














	.media-player {
		display: grid;
		gap: 16px;
	}

	.media-player__top {
		align-items: center;
		display: grid;
		gap: 16px;
		grid-template-columns: 1fr min-content;
	}

	.media-player__metadata {
		cursor: pointer;
		display: grid;
		gap: 8px;
	}

	.media-player__title {
		color: rgb(255, 255, 255);
		font-size: 16px;
		height: 16px;
		overflow: hidden;
		text-overflow: ellipsis;
		white-space: nowrap;
	}

	.media-player__subtitle {
		color: rgb(159, 159, 159);
		font-size: 16px;
		height: 16px;
		overflow: hidden;
		text-overflow: ellipsis;
		white-space: nowrap;
	}

	.media-player__controls {
		display: grid;
		gap: 8px;
		grid-auto-columns: minmax(auto, min-content);
		grid-auto-flow: column;
	}

	.media-player__bottom {

	}

	.media-player__progress {
		cursor: pointer;
		padding: 8px 0px;
	}

	.media-player__progress-container {
		background-color: rgb(31, 31, 31);
		border-radius: 4px;
		height: 8px;
		overflow: hidden;
		position: relative;
		z-index: 1;
	}

	@keyframes progress {
		0% {
			transform: translate(-100%, 0%);
		}
		100% {
			transform: translate(0%, 0%);
		}
	}

	.media-player__progress-track {
		animation-delay: 0s;
		animation-duration: 0s;
		animation-name: progress;
		animation-play-state: paused;
		animation-timing-function: linear;
		background-color: ${ACCENT_COLOR};
		height: 100%;
		width: 100%;
		transform: translate(-100%, 0%);
		position: absolute;
		z-index: 0;
	}






	.icon-button {
		cursor: pointer;
		fill: rgb(255, 255, 255);
		padding: 4px;
		transition: fill 0.125s, transform 0.125s;
	}

	.icon-button[data-enabled="false"] {
		cursor: default;
		fill: rgb(31, 31, 31);
	}

	.icon-button[data-active="true"] {
		fill: ${ACCENT_COLOR};
	}

	@media (hover: hover) and (pointer: fine) {
		.icon-button:not([data-enabled="false"]):hover {
			transform: scale(1.50);
		}

		.icon-button:active {
			transform: none;
		}
	}











	.app {
		display: grid;
		height: 100%;
		position: relative;
	}

	.app__header {
		background-color: ${ACCENT_COLOR};
		box-shadow: 0px 0px 8px 4px rgba(0, 0, 0, 0.25);
		position: absolute;
			top: 0px;
			left: 0px;
			right: 0px;
		transition: transform 0.25s;
		z-index: 1;
	}

	.app__header[data-hide=true] {
		display: initial!important;
		transform: translate(0%, -100%);
	}

	.app__content {
		background-color: rgb(31, 31, 31);
		overflow: hidden;
		padding: 64px 0px 112px 0px;
		position: relative;
		z-index: 0;
	}

	.app__navigation {
		background-color: rgb(47, 47, 47);
		box-shadow: 0px 0px 8px 4px rgba(0, 0, 0, 0.25);
		position: absolute;
			bottom: 0px;
			left: 0px;
			right: 0px;
		transition: transform 0.25s;
		z-index: 1;
	}

	.app__navigation[data-hide=true] {
		display: initial!important;
		transform: translate(0%, 100%);
	}

	.app__message-bar {
		background-color: ${ACCENT_COLOR};
	}

	.app__video {
		background-color: rgb(0, 0, 0);
		height: 100%;
		position: absolute;
		width: 100%;
	}

	.offline-indicator {
		margin: 0px auto;
		max-width: 1080px;
		padding: 8px;
	}

	.offline-indicator__content {
		font-size: 16px;
		overflow: hidden;
		text-overflow: ellipsis;
		white-space: nowrap;
	}





	.scroll-container {
		height: 100%;
		overflow-y: scroll;
		overflow-x: auto;
		width: 100%;
	}








	.access-token {
		display: grid;
		gap: 8px;
	}

	.access-token__title {
		color: rgb(255, 255, 255);
		font-family: "Space Mono", monospace;
		font-size: 16px;
		overflow: hidden;
		text-overflow: ellipsis;
		white-space: nowrap;
	}

	.access-token__subtitle {
		color: rgb(159, 159, 159);
		font-size: 12px;
		overflow: hidden;
		text-overflow: ellipsis;
		white-space: nowrap;
	}







	.icon-link {
		background-color: rgb(47, 47, 47);
		border-radius: 4px;
		cursor: pointer;
		padding-bottom: 100%;
		position: relative;
	}

	.icon-link__content {
		height: 100%;
		position: absolute;
			top: 0%;
			left: 0%;
		width: 100%;
		display: grid;
		gap: 12px;
		align-items: center;
		justify-content: center;
		justify-items: center;
		align-content: center;
	}

	.icon-link__icon {
		fill: rgb(255, 255, 255);
		transition: fill 0.125s;
	}

	.icon-link__title {
		color: rgb(159, 159, 159);
		font-size: 16px;
		overflow: hidden;
		text-overflow: ellipsis;
		transition: color 0.125s;
		white-space: nowrap;
	}

	@media (hover: hover) and (pointer: fine) {
		.icon-link:hover .icon-link__title {
			color: rgb(255, 255, 255)
		}
	}
`;
    document.head.appendChild(style);
    function makeIconLink(icon, title, url) {
        return xml.element("div.icon-link")
            .add(xml.element("div.icon-link__content")
            .add(icon
            .set("class", "icon-link__icon")
            .set("width", "24px")
            .set("height", "24px"))
            .add(xml.element("div.icon-link__title")
            .add(xml.text(title))))
            .on("click", () => navigate(url));
    }
    const makeButton = () => xml.element("div.icon-button");
    let req = (uri, body, cb) => {
        let xhr = new XMLHttpRequest();
        xhr.addEventListener('readystatechange', () => {
            if (xhr.readyState === XMLHttpRequest.DONE) {
                cb(xhr.status, JSON.parse(xhr.responseText));
            }
        });
        xhr.open('POST', uri, true);
        xhr.send(JSON.stringify(body));
    };
    function preq(uri, body) {
        return new Promise((resolve, reject) => {
            req(uri, body, (status, response) => {
                if (status >= 200 && status < 300) {
                    return resolve(response);
                }
                return reject();
            });
        });
    }
    const showDevices = new observers_2.ObservableClass(false);
    player.devices.addObserver({
        onappend: () => {
            if (player.devices.getState().length < 2) {
                showDevices.updateState(false);
            }
        },
        onsplice: () => {
            if (player.devices.getState().length < 2) {
                showDevices.updateState(false);
            }
        }
    });
    const showVideo = new observers_2.ObservableClass(false);
    {
        let computer = () => {
            let isDeviceLocal = player.isDeviceLocal.getState();
            let isCurrentEntryVideo = player.isCurrentEntryVideo.getState();
            let localPlayback = player.localPlayback.getState();
            showVideo.updateState(isDeviceLocal && isCurrentEntryVideo && localPlayback);
        };
        player.isDeviceLocal.addObserver(computer);
        player.isCurrentEntryVideo.addObserver(computer);
        player.localPlayback.addObserver(computer);
    }
    const showModal = observers_2.computed((token, showContextMenu, showDevices) => {
        if (is.absent(token)) {
            return "login";
        }
        if (showContextMenu) {
            return "context";
        }
        if (showDevices) {
            return "devices";
        }
    }, tokenobs, showContextMenu, showDevices);
    let token;
    tokenobs.addObserver((token2) => {
        if (is.present(token2)) {
            localStorage.setItem("token", token2);
        }
        else {
            localStorage.removeItem("token");
        }
        token = token2;
        player.authenticate(token);
        playlists.authenticate(token);
    });
    async function getToken() {
        return new Promise((resolve, reject) => {
            req(`/api/auth/?token=${token}`, {}, (status, response) => {
                tokenobs.updateState(response.token);
                resolve(token);
            });
        });
    }
    getToken().catch(() => { });
    async function getNewToken(username, password) {
        return new Promise((resolve, reject) => {
            req(`/api/auth/`, { username, password }, (status, response) => {
                tokenobs.updateState(response.token);
                resolve(token);
            });
        });
    }
    let mountwrapper = document.createElement('div');
    let showUserInterface = new observers_2.ObservableClass(true);
    let appcontainer = xml.element("div.app")
        .render();
    document.body.appendChild(appcontainer);
    let historyLength = new observers_2.ObservableClass(window.history.length);
    let historyIndex = new observers_2.ObservableClass(window.history.length - 1);
    let lastHistoryIndex = observers_2.computed((historyLength, historyIndex) => {
        if (historyLength === 0) {
            return;
        }
        if (historyIndex - 1 < 0) {
            return;
        }
        return historyIndex - 1;
    }, historyLength, historyIndex);
    let nextHistoryIndex = observers_2.computed((historyLength, historyIndex) => {
        if (historyLength === 0) {
            return;
        }
        if (historyIndex + 1 >= historyLength) {
            return;
        }
        return historyIndex + 1;
    }, historyLength, historyIndex);
    let appheader = xml.element("div.app__header")
        .bind("data-hide", showUserInterface.addObserver((showUserInterface) => !showUserInterface))
        .add(xml.element("div.content")
        .set("style", "padding: 16px")
        .add(xml.element("div.page-header")
        .add(xml.element("div.page-header__title")
        .add(xml.text(document.title))
        .on("click", () => {
        navigate("");
    }))
        .add(xml.element("div.page-header__controls")
        .add(makeButton()
        .add(Icon.makeReload())
        .on("click", () => {
        window.location.reload();
    }))
        .add(makeButton()
        .bind("data-enabled", lastHistoryIndex.addObserver(is.present))
        .add(Icon.makeChevron({ direction: "left" }))
        .on("click", () => {
        if (is.present(lastHistoryIndex)) {
            window.history.back();
        }
    }))
        .add(makeButton()
        .bind("data-enabled", nextHistoryIndex.addObserver(is.present))
        .add(Icon.makeChevron())
        .on("click", () => {
        if (is.present(nextHistoryIndex)) {
            window.history.forward();
        }
    })))))
        .render();
    appcontainer.appendChild(appheader);
    mountwrapper.setAttribute("class", "app__content");
    appcontainer.appendChild(mountwrapper);
    let maincontent = document.createElement('div');
    maincontent.setAttribute("style", "position: relative; width: 100%; height: 100%;");
    mountwrapper.appendChild(maincontent);
    let devicelist = new observers_2.ArrayObservable([]);
    {
        let computer = () => {
            let devices = player.devices.getState();
            let activeDevice = player.device.getState();
            let localDevice = player.localDevice.getState();
            devicelist.update(devices.map((device) => {
                return {
                    ...device,
                    active: activeDevice?.id === device.id,
                    local: localDevice?.id === device.id
                };
            }));
        };
        player.devices.addObserver({
            onappend: computer,
            onsplice: computer
        });
        player.device.addObserver(computer);
        player.localDevice.addObserver(computer);
    }
    let username = new observers_2.ObservableClass("");
    let password = new observers_2.ObservableClass("");
    let canLogin = observers_2.computed((username, password) => {
        if (username === "") {
            return false;
        }
        if (password === "") {
            return false;
        }
        return true;
    }, username, password);
    let repeat_password = new observers_2.ObservableClass("");
    let display_name = new observers_2.ObservableClass("");
    let registration_key = new observers_2.ObservableClass("");
    let loginErrors = new observers_2.ArrayObservable(new Array());
    let canRegister = observers_2.computed((username, password, repeat_password, display_name, registration_key) => {
        if (username === "") {
            return false;
        }
        if (password === "") {
            return false;
        }
        if (repeat_password === "") {
            return false;
        }
        if (display_name === "") {
            return false;
        }
        if (registration_key === "") {
            return false;
        }
        if (password !== repeat_password) {
            return false;
        }
        return true;
    }, username, password, repeat_password, display_name, registration_key);
    async function doLogin() {
        if (canLogin.getState()) {
            loginErrors.update([]);
            let token = await getNewToken(username.getState(), password.getState());
            if (is.present(token)) {
                loginErrors.update([]);
            }
            else {
                loginErrors.update(["The login was unsuccessful! Please check your credentials and try again."]);
            }
        }
    }
    async function doRegister() {
        if (canRegister.getState()) {
            loginErrors.update([]);
            req(`/api/register/`, {
                username: username.getState(),
                password: password.getState(),
                name: display_name.getState(),
                key_id: registration_key.getState()
            }, (_, response) => {
                if (apischema.messages.ErrorMessage.is(response)) {
                    loginErrors.update(response.errors);
                }
                else {
                    loginErrors.update([]);
                    tokenobs.updateState(response.token);
                }
            });
        }
    }
    let modals = xml.element("div.modal-container")
        .bind("data-hide", showModal.addObserver(is.absent))
        .add(xml.element("div.scroll-container")
        .bind("data-hide", showModal.addObserver((showModal) => showModal !== "devices"))
        .add(xml.element("div.content.content--narrow")
        .add(xml.element("div.device-selector")
        .add(xml.element("div")
        .set("style", "align-items: center; display: grid; gap: 16px; grid-template-columns: 1fr min-content;")
        .add(renderTextHeader(xml.text("Select playback device")))
        .add(makeButton()
        .on("click", () => {
        showDevices.updateState(false);
    })
        .add(Icon.makeCross())))
        .add(xml.element("div.device-selector__devices")
        .repeat(devicelist, (device) => xml.element("div.device-selector__device")
        .add(makeButton()
        .set("data-active", "" + device.active)
        .add(Icon.makeBroadcast()))
        .add(xml.element("div.device-selector__device-info")
        .add(xml.element("div.device-selector__device-name")
        .add(xml.text(device.name)))
        .add(xml.element("div.device-selector__device-type")
        .add(xml.text(device.local ? "Local device" : "Remote device"))))
        .on("click", () => {
        player.transfer({
            id: device.id,
            protocol: device.protocol,
            name: device.name,
            type: device.type
        });
        showDevices.updateState(false);
    }))))))
        .add(xml.element("div.scroll-container")
        .bind("data-hide", showModal.addObserver((showModal) => showModal !== "login"))
        .add(xml.element("div.content.content--narrow")
        .add(xml.element("div.login-modal")
        .add(xml.element("div")
        .set("style", "display: grid; gap: 16px;")
        .add(xml.element("div")
        .set("style", "position: relative;")
        .add(xml.element("input.login-modal__username")
        .bind2("value", username)
        .set("type", "text")
        .set("spellcheck", "false")
        .set("placeholder", "Username"))
        .add(Icon.makePerson()
        .set("style", "fill: rgb(255, 255, 255); position: absolute; left: 0px; top: 50%; transform: translate(100%, -50%);")))
        .add(xml.element("div")
        .set("style", "position: relative;")
        .add(xml.element("input.login-modal__password")
        .bind2("value", password)
        .set("type", "password")
        .set("spellcheck", "false")
        .set("placeholder", "Password")
        .on("keyup", async (event) => {
        if (event.code === "Enter") {
            await doLogin();
        }
    }))
        .add(Icon.makePadlock()
        .set("style", "fill: rgb(255, 255, 255); position: absolute; left: 0px; top: 50%; transform: translate(100%, -50%);")))
        .add(xml.element("div")
        .set("style", "position: relative;")
        .add(xml.element("input.login-modal__password")
        .bind2("value", repeat_password)
        .set("type", "password")
        .set("spellcheck", "false")
        .set("placeholder", "Repeat password"))
        .add(Icon.makePadlock()
        .set("style", "fill: rgb(255, 255, 255); position: absolute; left: 0px; top: 50%; transform: translate(100%, -50%);")))
        .add(xml.element("div")
        .set("style", "position: relative;")
        .add(xml.element("input.login-modal__name")
        .bind2("value", display_name)
        .set("type", "text")
        .set("spellcheck", "false")
        .set("placeholder", "Display name"))
        .add(Icon.makePerson()
        .set("style", "fill: rgb(255, 255, 255); position: absolute; left: 0px; top: 50%; transform: translate(100%, -50%);")))
        .add(xml.element("div")
        .set("style", "position: relative;")
        .add(xml.element("input.login-modal__key")
        .bind2("value", registration_key)
        .set("type", "text")
        .set("spellcheck", "false")
        .set("placeholder", "Registration key")
        .on("keyup", async (event) => {
        if (event.code === "Enter") {
            await doRegister();
        }
    }))
        .add(Icon.makePadlock()
        .set("style", "fill: rgb(255, 255, 255); position: absolute; left: 0px; top: 50%; transform: translate(100%, -50%);"))))
        .add(xml.element("div")
        .set("style", "display: grid; gap: 16px;")
        .bind("data-hide", loginErrors.compute((loginErrors) => loginErrors.length === 0))
        .repeat(loginErrors, (loginError) => renderTextParagraph(xml.text(loginError))))
        .add(xml.element("div")
        .set("style", "display: grid; gap: 16px;")
        .add(xml.element("button")
        .bind2("data-enabled", observers_2.computed((canRegister) => "" + canRegister, canRegister))
        .add(xml.text("Register"))
        .on("click", async () => {
        await doRegister();
    }))
        .add(xml.element("button")
        .bind2("data-enabled", observers_2.computed((canLogin) => "" + canLogin, canLogin))
        .add(xml.text("Login"))
        .on("click", async () => {
        await doLogin();
    }))))))
        .add(xml.element("div.scroll-container")
        .bind("data-hide", showModal.addObserver((showModal) => showModal !== "context"))
        .add(xml.element("div.content.content--narrow")
        .repeat(contextMenuItems, (contextMenuItem) => contextMenuItem)));
    let mount = xml.element("div.scroll-container")
        .bind("data-hide", showVideo.addObserver((showVideo) => showVideo))
        .render();
    maincontent.appendChild(mount);
    maincontent.appendChild(modals.render());
    let mpw = xml.element("div.app__navigation")
        .bind("data-hide", showUserInterface.addObserver((showUserInterface) => !showUserInterface))
        .add(xml.element("div.app__message-bar")
        .bind("data-hide", player.isOnline.addObserver((isOnline) => isOnline))
        .add(xml.element("div.offline-indicator")
        .add(xml.element("div.offline-indicator__content")
        .add(xml.text("The application is currently offline.")))))
        .render();
    let progress = xml.element("div.media-player__progress");
    let progresscontainer = xml.element("div.media-player__progress-container");
    let progresstrack = xml.element("div.media-player__progress-track");
    player.progress.addObserver(async (progress) => {
        let ref = await progresstrack.ref();
        ref.style.setProperty("animation-name", "none");
        window.requestAnimationFrame(() => {
            window.requestAnimationFrame(() => {
                ref.style.setProperty("animation-delay", `-${progress ?? 0}s`);
                ref.style.setProperty("animation-name", "progress");
            });
        });
    });
    player.playback.addObserver(async (playback) => {
        let ref = await progresstrack.ref();
        let state = playback ? "running" : "paused";
        ref.style.setProperty("animation-play-state", state);
    });
    player.currentEntry.addObserver(async (currentEntry) => {
        let ref = await progresstrack.ref();
        let duration = currentEntry?.media.duration_ms ?? 1;
        ref.style.setProperty("animation-name", "none");
        window.requestAnimationFrame(() => {
            window.requestAnimationFrame(() => {
                ref.style.setProperty("animation-duration", `${duration}ms`);
                ref.style.setProperty("animation-name", "progress");
            });
        });
    });
    async function progressupdate(page_x) {
        let ref = await progresscontainer.ref();
        let x = page_x - ref.offsetLeft;
        let w = ref.offsetWidth;
        let factor = Math.max(0.0, Math.min(x / w, 1.0));
        let currentEntry = player.currentEntry.getState();
        if (is.present(currentEntry)) {
            let progress = factor * currentEntry.media.duration_ms / 1000;
            player.seek(progress);
        }
    }
    let progressactive = false;
    document.body.addEventListener("pointermove", async (event) => {
        if (progressactive) {
            await progressupdate(event.pageX);
        }
    });
    document.body.addEventListener("pointerup", async (event) => {
        progressactive = false;
    });
    document.body.addEventListener("pointerleave", async (event) => {
        progressactive = false;
    });
    progress
        .on("pointerdown", async (event) => {
        progressactive = true;
        await progressupdate(event.pageX);
    })
        .add(progresscontainer
        .add(progresstrack));
    let mp = xml.element("div.content")
        .set("style", "padding: 16px;")
        .add(xml.element("div.media-player")
        .add(xml.element("div.media-player__top")
        .add(xml.element("div.media-player__metadata")
        .add(xml.element("div.media-player__title")
        .add(xml.text(mediaPlayerTitle)))
        .add(xml.element("div.media-player__subtitle")
        .add(xml.text(mediaPlayerSubtitle)))
        .on("click", () => {
        let context = player.context.getState();
        if (is.present(context)) {
            if (objects_14.Album.is(context)) {
                navigate(`audio/albums/${context.album_id}/`);
            }
            else if (objects_14.Artist.is(context)) {
                navigate(`audio/artists/${context.artist_id}/`);
            }
            else if (objects_14.Disc.is(context)) {
                navigate(`audio/discs/${context.disc_id}/`);
            }
            else if (objects_14.Episode.is(context)) {
                navigate(`video/episodes/${context.episode_id}/`);
            }
            else if (objects_14.Movie.is(context)) {
                navigate(`video/movies/${context.movie_id}/`);
            }
            else if (objects_14.Playlist.is(context)) {
                navigate(`audio/playlists/${context.playlist_id}/`);
            }
            else if (objects_14.Season.is(context)) {
                navigate(`video/seasons/${context.season_id}/`);
            }
            else if (objects_14.Show.is(context)) {
                navigate(`video/shows/${context.show_id}/`);
            }
            else if (objects_14.Track.is(context)) {
                navigate(`audio/tracks/${context.track_id}/`);
            }
            else {
                throw `Expected code to be unreachable!`;
            }
        }
    }))
        .add(xml.element("div.media-player__controls")
        .add(makeButton()
        .bind("data-hide", player.devices.compute((devices) => {
        return devices.length < 2;
    }))
        .add(Icon.makeBroadcast())
        .on("click", () => {
        showDevices.updateState(!showDevices.getState());
    }))
        .add(makeButton()
        .bind("data-enabled", player.canPlayLast.addObserver(a => a))
        .add(Icon.makeSkip({ direction: "left" }))
        .on("click", () => {
        player.last();
    }))
        .add(makeButton()
        .bind("data-enabled", player.canPlayCurrent.addObserver(a => a))
        .add(Icon.makePlay()
        .bind("data-hide", player.playback.addObserver((playback) => {
        return playback === true;
    })))
        .add(Icon.makePause()
        .bind("data-hide", player.playback.addObserver((playback) => {
        return playback === false;
    })))
        .on("click", () => {
        player.toggle();
    }))
        .add(makeButton()
        .bind("data-enabled", player.canPlayNext.addObserver(a => a))
        .add(Icon.makeSkip())
        .on("click", () => {
        player.next();
    }))))
        .add(xml.element("div.media-player__bottom")
        .add(progress)))
        .render();
    appcontainer.appendChild(mpw);
    mpw.appendChild(mp);
    currentVideo.setAttribute('playsinline', '');
    currentVideo.setAttribute("preload", "auto");
    currentVideo.style.setProperty('height', '100%');
    currentVideo.style.setProperty('width', '100%');
    lastVideo.setAttribute("preload", "auto");
    lastVideo.style.setProperty("display", "none");
    nextVideo.setAttribute("preload", "auto");
    nextVideo.style.setProperty("display", "none");
    currentVideo.addEventListener("click", () => {
        player.pause();
    });
    showVideo.addObserver((showVideo) => {
        if (showVideo) {
            showUserInterface.updateState(false);
        }
        else {
            showUserInterface.updateState(true);
        }
    });
    let videowrapper = xml.element("div.app__video")
        .bind("data-hide", showVideo.addObserver((showVideo) => {
        return !showVideo;
    }))
        .render();
    appcontainer.appendChild(videowrapper);
    videowrapper.appendChild(currentVideo);
    videowrapper.appendChild(lastVideo);
    videowrapper.appendChild(nextVideo);
    /*
    let slider_wrapper = document.createElement("div");
    slider_wrapper.classList.add("slider-widget");
    let slider_indicator = document.createElement("div");
    slider_indicator.classList.add("slider-widget__indicator");
    let slider_knob_wrapper = document.createElement("div");
    slider_knob_wrapper.classList.add("slider-widget__knob-wrapper");
    let slider_knob = document.createElement("div");
    slider_knob.classList.add("slider-widget__knob");
    
    slider_knob_wrapper.appendChild(slider_knob);
    slider_indicator.appendChild(slider_knob_wrapper);
    slider_wrapper.appendChild(slider_indicator);
    chromecast.appendChild(slider_wrapper);
    {
        let percentage = 0.0;
        function update(event: MouseEvent): void {
            let rect = slider_knob_wrapper.getBoundingClientRect();
            let x = event.pageX;
            let factor = Math.max(0.0, Math.min((x - rect.x) / rect.width, 1.0));
            percentage = factor * 100.0;
            slider_knob.style.setProperty("left", `${percentage}%`);
        }
        function detach(event: MouseEvent) {
            window.removeEventListener("mousemove", update);
            window.removeEventListener("mouseup", detach);
            req(`/api/cc/seek/`, { percentage: percentage, token: token }, () => {});
        }
        function attach(event: MouseEvent) {
            window.addEventListener("mousemove", update);
            window.addEventListener("mouseup", detach);
            update(event);
        }
        slider_wrapper.addEventListener("mousedown", attach);
    }
    */
    function renderTextHeader(content) {
        return xml.element("div.text-header")
            .add(content);
    }
    function renderTextParagraph(content) {
        return xml.element("div.text-paragraph")
            .add(content);
    }
    function observe(element, handler) {
        element.ref().then((element) => {
            let observer = new IntersectionObserver(async (entries) => {
                for (let entry of entries) {
                    if (entry.target === element && entry.isIntersecting) {
                        await handler();
                    }
                }
            });
            observer.observe(element);
        });
        return element;
    }
    let updateviewforuri = (uri) => {
        let parts;
        if (false) {
        }
        else if ((parts = /^audio[/]tracks[/]([0-9a-f]{16})[/]/.exec(uri)) !== null) {
            let track_id = parts[1];
            let offset = 0;
            let reachedEnd = new observers_2.ObservableClass(false);
            let isLoading = new observers_2.ObservableClass(false);
            let playlists = new observers_2.ArrayObservable([]);
            async function load() {
                if (!reachedEnd.getState() && !isLoading.getState()) {
                    isLoading.updateState(true);
                    let response = await preq(`/api/audio/tracks/${track_id}/playlists/?offset=${offset}&token=${token}`, {});
                    for (let playlist of response.playlists) {
                        playlists.append(playlist);
                    }
                    offset += response.playlists.length;
                    if (response.playlists.length === 0) {
                        reachedEnd.updateState(true);
                    }
                    isLoading.updateState(false);
                }
            }
            req(`/api/audio/tracks/${parts[1]}/?token=${token}`, {}, (_, response) => {
                let track = response.track;
                let last = response.last;
                let next = response.next;
                mount.appendChild(xml.element("div")
                    .add(xml.element("div.content")
                    .add(EntityCard.forTrack(track, { compactDescription: false })))
                    .add(xml.element("div.content")
                    .add(entityNavLinkFactory.forTrack(last, next)))
                    .add(xml.element("div.content")
                    .set("style", "display: grid; gap: 24px;")
                    .add(renderTextHeader(xml.text("Appearances")))
                    .bind("data-hide", playlists.compute((playlists) => playlists.length === 0))
                    .add(Grid.make()
                    .repeat(playlists, (playlist) => EntityCard.forPlaylist(playlist))))
                    .add(observe(xml.element("div").set("style", "height: 1px;"), load))
                    .render());
            });
        }
        else if ((parts = /^audio[/]tracks[/]([^/?]*)/.exec(uri)) !== null) {
            let encodedQuery = parts[1];
            let offset = 0;
            let reachedEnd = new observers_2.ObservableClass(false);
            let isLoading = new observers_2.ObservableClass(false);
            let tracks = new observers_2.ArrayObservable([]);
            async function load() {
                if (!reachedEnd.getState() && !isLoading.getState()) {
                    isLoading.updateState(true);
                    let response = await preq(`/api/audio/tracks/${encodedQuery}?offset=${offset}&token=${token}`, {});
                    for (let track of response.tracks) {
                        tracks.append(track);
                    }
                    offset += response.tracks.length;
                    if (response.tracks.length === 0) {
                        reachedEnd.updateState(true);
                    }
                    isLoading.updateState(false);
                }
            }
            ;
            mount.appendChild(xml.element("div")
                .add(xml.element("div.content")
                .add(renderTextHeader(xml.text("Tracks"))))
                .add(xml.element("div.content")
                .add(Grid.make()
                .repeat(tracks, (track) => EntityCard.forTrack(track))))
                .add(observe(xml.element("div").set("style", "height: 1px;"), load))
                .render());
        }
        else if ((parts = /^video[/]seasons[/]([0-9a-f]{16})[/]/.exec(uri)) !== null) {
            req(`/api/video/seasons/${parts[1]}/?token=${token}`, {}, (_, response) => {
                let season = response.season;
                let last = response.last;
                let next = response.next;
                mount.appendChild(xml.element("div")
                    .add(xml.element("div.content")
                    .add(EntityCard.forSeason(season, { compactDescription: false })))
                    .add(xml.element("div.content")
                    .set("style", "display: grid; gap: 24px;")
                    .add(...season.episodes.map((episode, episodeIndex) => {
                    return EntityCard.forEpisode(episode, {
                        playbackButton: PlaybackButton.forSeason(season, episodeIndex)
                    });
                })))
                    .add(xml.element("div.content")
                    .add(entityNavLinkFactory.forSeason(last, next)))
                    .render());
            });
        }
        else if ((parts = /^video[/]seasons[/]([^/?]*)/.exec(uri)) !== null) {
            let encodedQuery = parts[1];
            let offset = 0;
            let reachedEnd = new observers_2.ObservableClass(false);
            let isLoading = new observers_2.ObservableClass(false);
            let seasons = new observers_2.ArrayObservable([]);
            async function load() {
                if (!reachedEnd.getState() && !isLoading.getState()) {
                    isLoading.updateState(true);
                    let response = await preq(`/api/video/seasons/${encodedQuery}?offset=${offset}&token=${token}`, {});
                    for (let season of response.seasons) {
                        seasons.append(season);
                    }
                    offset += response.seasons.length;
                    if (response.seasons.length === 0) {
                        reachedEnd.updateState(true);
                    }
                    isLoading.updateState(false);
                }
            }
            ;
            mount.appendChild(xml.element("div")
                .add(xml.element("div.content")
                .add(renderTextHeader(xml.text("Seasons"))))
                .add(xml.element("div.content")
                .add(Grid.make()
                .repeat(seasons, (season) => EntityCard.forSeason(season))))
                .add(observe(xml.element("div").set("style", "height: 1px;"), load))
                .render());
        }
        else if ((parts = /^audio[/]discs[/]([0-9a-f]{16})[/]/.exec(uri)) !== null) {
            req(`/api/audio/discs/${parts[1]}/?token=${token}`, {}, (_, response) => {
                let disc = response.disc;
                let last = response.last;
                let next = response.next;
                mount.appendChild(xml.element("div")
                    .add(xml.element("div.content")
                    .add(EntityCard.forDisc(disc, { compactDescription: false })))
                    .add(xml.element("div.content")
                    .set("style", "display: grid; gap: 16px;")
                    .add(...disc.tracks.map((track, trackIndex) => {
                    return EntityRow.forTrack(track, PlaybackButton.forDisc(disc, trackIndex));
                })))
                    .add(xml.element("div.content")
                    .add(entityNavLinkFactory.forDisc(last, next)))
                    .render());
            });
        }
        else if ((parts = /^audio[/]discs[/]([^/?]*)/.exec(uri)) !== null) {
            let encodedQuery = parts[1];
            let offset = 0;
            let reachedEnd = new observers_2.ObservableClass(false);
            let isLoading = new observers_2.ObservableClass(false);
            let discs = new observers_2.ArrayObservable([]);
            async function load() {
                if (!reachedEnd.getState() && !isLoading.getState()) {
                    isLoading.updateState(true);
                    let response = await preq(`/api/audio/discs/${encodedQuery}?offset=${offset}&token=${token}`, {});
                    for (let disc of response.discs) {
                        discs.append(disc);
                    }
                    offset += response.discs.length;
                    if (response.discs.length === 0) {
                        reachedEnd.updateState(true);
                    }
                    isLoading.updateState(false);
                }
            }
            ;
            mount.appendChild(xml.element("div")
                .add(xml.element("div.content")
                .add(renderTextHeader(xml.text("Discs"))))
                .add(xml.element("div.content")
                .add(Grid.make()
                .repeat(discs, (disc) => EntityCard.forDisc(disc))))
                .add(observe(xml.element("div").set("style", "height: 1px;"), load))
                .render());
        }
        else if ((parts = /^users[/]([0-9a-f]{16})[/]/.exec(uri)) !== null) {
            req(`/api/users/${parts[1]}/?token=${token}`, {}, (_, response) => {
                let user = response.user;
                let playlists = response.playlists;
                mount.appendChild(xml.element("div.content")
                    .set("style", "display: grid; gap: 64px;")
                    .add(renderTextHeader(xml.text(user.name)))
                    .add(xml.element("div")
                    .set("data-hide", `${playlists.length === 0}`)
                    .set("style", "display: grid; gap: 24px;")
                    .add(Grid.make()
                    .add(...playlists.map((playlist) => EntityCard.forPlaylist(playlist)))))
                    .render());
            });
        }
        else if ((parts = /^users[/]([^/?]*)/.exec(uri)) !== null) {
            let encodedQuery = parts[1];
            let offset = 0;
            let reachedEnd = new observers_2.ObservableClass(false);
            let isLoading = new observers_2.ObservableClass(false);
            let users = new observers_2.ArrayObservable([]);
            async function load() {
                if (!reachedEnd.getState() && !isLoading.getState()) {
                    isLoading.updateState(true);
                    let response = await preq(`/api/users/${encodedQuery}?offset=${offset}&token=${token}`, {});
                    for (let user of response.users) {
                        users.append(user);
                    }
                    offset += response.users.length;
                    if (response.users.length === 0) {
                        reachedEnd.updateState(true);
                    }
                    isLoading.updateState(false);
                }
            }
            ;
            mount.appendChild(xml.element("div")
                .add(xml.element("div.content")
                .add(renderTextHeader(xml.text("Users"))))
                .add(xml.element("div.content")
                .add(Grid.make()
                .repeat(users, (user) => EntityCard.forUser(user))))
                .add(observe(xml.element("div").set("style", "height: 1px;"), load))
                .render());
        }
        else if ((parts = /^actors[/]([0-9a-f]{16})[/]/.exec(uri)) !== null) {
            let actor_id = parts[1];
            req(`/api/actors/${actor_id}/?token=${token}`, {}, (_, response) => {
                let actor = response.actor;
                req(`/api/actors/${actor_id}/shows/?token=${token}`, {}, (_, response) => {
                    let shows = response.shows;
                    req(`/api/actors/${actor_id}/movies/?token=${token}`, {}, (_, response) => {
                        let movies = response.movies;
                        mount.appendChild(xml.element("div.content")
                            .set("style", "display: grid; gap: 64px;")
                            .add(renderTextHeader(xml.text(actor.name)))
                            .add(xml.element("div")
                            .set("style", "display: grid; gap: 24px;")
                            .set("data-hide", `${shows.length === 0}`)
                            .add(renderTextHeader(xml.text("Shows")))
                            .add(carouselFactory.make(...shows.map((show) => EntityCard.forShow(show)))))
                            .add(xml.element("div")
                            .set("style", "display: grid; gap: 24px;")
                            .set("data-hide", `${movies.length === 0}`)
                            .add(renderTextHeader(xml.text("Movies")))
                            .add(Grid.make()
                            .add(...movies.map((movie) => EntityCard.forMovie(movie)))))
                            .render());
                    });
                });
            });
        }
        else if ((parts = /^actors[/]([^/?]*)/.exec(uri)) !== null) {
            let encodedQuery = parts[1];
            let offset = 0;
            let reachedEnd = new observers_2.ObservableClass(false);
            let isLoading = new observers_2.ObservableClass(false);
            let actors = new observers_2.ArrayObservable([]);
            async function load() {
                if (!reachedEnd.getState() && !isLoading.getState()) {
                    isLoading.updateState(true);
                    let response = await preq(`/api/actors/${encodedQuery}?offset=${offset}&token=${token}`, {});
                    for (let actor of response.actors) {
                        actors.append(actor);
                    }
                    offset += response.actors.length;
                    if (response.actors.length === 0) {
                        reachedEnd.updateState(true);
                    }
                    isLoading.updateState(false);
                }
            }
            ;
            mount.appendChild(xml.element("div")
                .add(xml.element("div.content")
                .add(renderTextHeader(xml.text("Actors"))))
                .add(xml.element("div.content")
                .add(Grid.make()
                .repeat(actors, (actor) => EntityCard.forActor(actor))))
                .add(observe(xml.element("div").set("style", "height: 1px;"), load))
                .render());
        }
        else if ((parts = /^audio[/]albums[/]([0-9a-f]{16})[/]/.exec(uri)) !== null) {
            req(`/api/audio/albums/${parts[1]}/?token=${token}`, {}, (status, response) => {
                let album = response.album;
                mount.appendChild(xml.element("div")
                    .add(xml.element("div.content")
                    .add(EntityCard.forAlbum(album, { compactDescription: false })))
                    .add(...album.discs.map((disc, discIndex) => xml.element("div.content")
                    .set("style", "display: grid; gap: 16px;")
                    .add(renderTextHeader(xml.text(`Disc ${disc.number}`)))
                    .add(...disc.tracks.map((track, trackIndex) => {
                    return EntityRow.forTrack(track, PlaybackButton.forAlbum(album, discIndex, trackIndex));
                }))))
                    .render());
            });
        }
        else if ((parts = /^audio[/]albums[/]([^/?]*)/.exec(uri)) !== null) {
            let encodedQuery = parts[1];
            let offset = 0;
            let reachedEnd = new observers_2.ObservableClass(false);
            let isLoading = new observers_2.ObservableClass(false);
            let albums = new observers_2.ArrayObservable([]);
            async function load() {
                if (!reachedEnd.getState() && !isLoading.getState()) {
                    isLoading.updateState(true);
                    let response = await preq(`/api/audio/albums/${encodedQuery}?offset=${offset}&token=${token}`, {});
                    for (let album of response.albums) {
                        albums.append(album);
                    }
                    offset += response.albums.length;
                    if (response.albums.length === 0) {
                        reachedEnd.updateState(true);
                    }
                    isLoading.updateState(false);
                }
            }
            ;
            mount.appendChild(xml.element("div")
                .add(xml.element("div.content")
                .add(renderTextHeader(xml.text("Albums"))))
                .add(xml.element("div.content")
                .add(Grid.make()
                .repeat(albums, (album) => EntityCard.forAlbum(album))))
                .add(observe(xml.element("div").set("style", "height: 1px;"), load))
                .render());
        }
        else if ((parts = /^audio[/]artists[/]([0-9a-f]{16})[/]/.exec(uri)) !== null) {
            req(`/api/audio/artists/${parts[1]}/?token=${token}`, {}, (status, response) => {
                let artist = response.artist;
                let tracks = response.tracks;
                let appearances = response.appearances;
                mount.appendChild(xml.element("div")
                    .add(xml.element("div.content")
                    .add(EntityCard.forArtist(artist, { compactDescription: false })))
                    .add(tracks.length === 0 ? undefined : xml.element("div.content")
                    .set("style", "display: grid; gap: 24px;")
                    .add(renderTextHeader(xml.text("Popular tracks")))
                    .add(xml.element("div")
                    .set("style", "display: grid; gap: 16px;")
                    .add(...tracks.map((track) => {
                    return EntityRow.forTrack(track);
                }))))
                    .add(artist.albums.length === 0 ? undefined : xml.element("div.content")
                    .set("style", "display: grid; gap: 24px;")
                    .add(renderTextHeader(xml.text("Discography")))
                    .add(Grid.make()
                    .add(...artist.albums.map((album, albumIndex) => {
                    return EntityCard.forAlbum(album, {
                        playbackButton: PlaybackButton.forArtist(artist, albumIndex)
                    });
                }))))
                    .add(appearances.length === 0 ? undefined : xml.element("div.content")
                    .set("style", "display: grid; gap: 24px;")
                    .add(renderTextHeader(xml.text("Appearances")))
                    .add(Grid.make()
                    .add(...appearances.map((album) => {
                    return EntityCard.forAlbum(album);
                }))))
                    .render());
            });
        }
        else if ((parts = /^audio[/]artists[/]([^/?]*)/.exec(uri)) !== null) {
            let encodedQuery = parts[1];
            let offset = 0;
            let reachedEnd = new observers_2.ObservableClass(false);
            let isLoading = new observers_2.ObservableClass(false);
            let artists = new observers_2.ArrayObservable([]);
            async function load() {
                if (!reachedEnd.getState() && !isLoading.getState()) {
                    isLoading.updateState(true);
                    let response = await preq(`/api/audio/artists/${encodedQuery}?offset=${offset}&token=${token}`, {});
                    for (let artist of response.artists) {
                        artists.append(artist);
                    }
                    offset += response.artists.length;
                    if (response.artists.length === 0) {
                        reachedEnd.updateState(true);
                    }
                    isLoading.updateState(false);
                }
            }
            mount.appendChild(xml.element("div")
                .add(xml.element("div.content")
                .add(renderTextHeader(xml.text("Artists"))))
                .add(xml.element("div.content")
                .add(Grid.make()
                .repeat(artists, (artist) => EntityCard.forArtist(artist))))
                .add(observe(xml.element("div").set("style", "height: 1px;"), load))
                .render());
        }
        else if ((parts = /^audio[/]playlists[/]([0-9a-f]{16})[/]/.exec(uri)) !== null) {
            let playlist_id = parts[1];
            req(`/api/audio/playlists/${playlist_id}/?token=${token}`, {}, async (status, response) => {
                let playlist = response.playlist;
                let canEdit = (await playlists.getPermissions({
                    playlist: {
                        playlist_id
                    }
                })).permissions === "write";
                let title = new observers_2.ObservableClass(playlist.title);
                let description = new observers_2.ObservableClass(playlist.description);
                let canModify = observers_2.computed((title) => {
                    if (title === "") {
                        return false;
                    }
                    return true;
                }, title);
                let doUpdate = async () => {
                    if (canModify.getState()) {
                        let response = await playlists.updatePlaylist({
                            playlist: {
                                playlist_id: playlist_id,
                                title: title.getState(),
                                description: description.getState()
                            }
                        });
                        if (response.errors.length > 0) {
                            return;
                        }
                        navigate(uri);
                    }
                };
                mount.appendChild(xml.element("div")
                    .add(xml.element("div.content")
                    .add(EntityCard.forPlaylist(playlist, { compactDescription: false })))
                    .add(xml.element("div.content.content--compact")
                    .set("style", "display: grid; gap: 16px;")
                    .set("data-hide", `${!canEdit}`)
                    .add(xml.element("div")
                    .set("style", "position: relative;")
                    .add(xml.element("input")
                    .bind2("value", title)
                    .set("type", "text")
                    .set("spellcheck", "false")
                    .set("placeholder", "Playlist title"))
                    .add(Icon.makeStar()
                    .set("style", "fill: rgb(255, 255, 255); position: absolute; left: 0px; top: 50%; transform: translate(100%, -50%);")))
                    .add(xml.element("div")
                    .set("style", "position: relative;")
                    .add(xml.element("input")
                    .bind2("value", description)
                    .set("type", "text")
                    .set("spellcheck", "false")
                    .set("placeholder", "Playlist description"))
                    .add(Icon.makeStar()
                    .set("style", "fill: rgb(255, 255, 255); position: absolute; left: 0px; top: 50%; transform: translate(100%, -50%);")))
                    .add(xml.element("button")
                    .bind2("data-enabled", observers_2.computed((canUpdate) => "" + canUpdate, canModify))
                    .add(xml.text("Update playlist"))
                    .on("click", async () => {
                    await doUpdate();
                })))
                    .add(playlist.items.length === 0 ? undefined : xml.element("div.content")
                    .set("style", "display: grid; gap: 16px;")
                    .add(...playlist.items.map((item, itemIndex) => xml.element("div")
                    .set("style", "align-items: center; display: grid; grid-template-columns: 1fr min-content; gap: 16px;")
                    .add(EntityRow.forTrack(item.track, PlaybackButton.forPlaylist(playlist, itemIndex)))
                    .add(makeButton()
                    .set("data-hide", `${!canEdit}`)
                    .on("click", async () => {
                    if (canModify.getState()) {
                        let response = await playlists.deletePlaylistItem({
                            playlist_item: {
                                playlist_item_id: item.playlist_item_id
                            }
                        });
                        if (response.errors.length > 0) {
                            return;
                        }
                        navigate(uri);
                    }
                })
                    .add(Icon.makeMinus())))))
                    .add(xml.element("div.content.content--compact")
                    .set("style", "display: grid; gap: 16px;")
                    .set("data-hide", `${!canEdit}`)
                    .add(xml.element("button")
                    .bind2("data-enabled", observers_2.computed((canUpdate) => "" + canUpdate, canModify))
                    .add(xml.text("Delete playlist"))
                    .on("click", async () => {
                    if (canModify.getState()) {
                        let response = await playlists.deletePlaylist({
                            playlist: {
                                playlist_id
                            }
                        });
                        if (response.errors.length > 0) {
                            return;
                        }
                        navigate("");
                    }
                })))
                    .render());
            });
        }
        else if ((parts = /^audio[/]playlists[/]([^/?]*)/.exec(uri)) !== null) {
            let encodedQuery = parts[1];
            req(`/api/audio/playlists/${encodedQuery}?token=${token}`, {}, (status, response) => {
                let playlists = response.playlists;
                mount.appendChild(xml.element("div")
                    .add(xml.element("div.content")
                    .add(renderTextHeader(xml.text("Playlists"))))
                    .add(xml.element("div.content")
                    .add(Grid.make()
                    .add(...playlists.map((playlist) => EntityCard.forPlaylist(playlist)))))
                    .render());
            });
        }
        else if ((parts = /^audio[/]/.exec(uri)) !== null) {
            mount.appendChild(xml.element("div")
                .add(xml.element("div.content")
                .add(Grid.make({ mini: true })
                .add(makeIconLink(Icon.makeDisc(), "Albums", "audio/albums/"))
                .add(makeIconLink(Icon.makePerson(), "Artists", "audio/artists/"))
                .add(makeIconLink(Icon.makeBulletList(), "Playlists", "audio/playlists/"))))
                .render());
        }
        else if ((parts = /^video[/]shows[/]([0-9a-f]{16})[/]/.exec(uri)) !== null) {
            function getNextEpisode(show) {
                let indices;
                show.seasons.forEach((season, seasonIndex) => {
                    season.episodes.forEach((episode, episodeIndex) => {
                        if (is.present(episode.last_stream_date)) {
                            if (is.present(indices)) {
                                if (episode.last_stream_date < (show.seasons[indices.seasonIndex].episodes[indices.episodeIndex].last_stream_date ?? 0)) {
                                    return;
                                }
                            }
                            indices = {
                                seasonIndex,
                                episodeIndex
                            };
                        }
                    });
                });
                if (is.present(indices)) {
                    indices.episodeIndex += 1;
                    if (indices.episodeIndex === show.seasons[indices.seasonIndex].episodes.length) {
                        indices.episodeIndex = 0;
                        indices.seasonIndex += 1;
                        if (indices.seasonIndex === show.seasons.length) {
                            indices.seasonIndex = 0;
                        }
                    }
                }
                else {
                    if (show.seasons.length > 0 && show.seasons[0].episodes.length > 0) {
                        indices = {
                            seasonIndex: 0,
                            episodeIndex: 0
                        };
                    }
                }
                return indices;
            }
            let show_id = parts[1];
            req(`/api/video/shows/${show_id}/?token=${token}`, {}, (_, response) => {
                const show = response.show;
                const indices = getNextEpisode(show);
                mount.appendChild(xml.element("div")
                    .add(xml.element("div.content")
                    .add(EntityCard.forShow(show, { compactDescription: false })))
                    .add(xml.element("div.content")
                    .set("data-hide", `${show.actors.length === 0}`)
                    .set("style", "display: grid; gap: 16px;")
                    .add(...show.actors.map((actor) => EntityRow.forActor(actor))))
                    .add(is.absent(indices) ? undefined : xml.element("div.content")
                    .set("style", "display: grid; gap: 24px;")
                    .add(renderTextHeader(xml.text("Suggested episode")))
                    .add(EntityCard.forEpisode(show.seasons[indices.seasonIndex].episodes[indices.episodeIndex], {
                    playbackButton: PlaybackButton.forShow(show, indices.seasonIndex, indices.episodeIndex)
                })))
                    .add(xml.element("div.content")
                    .add(Grid.make()
                    .add(...show.seasons.map((season, seasonIndex) => EntityCard.forSeason(season, {
                    playbackButton: PlaybackButton.forShow(show, seasonIndex)
                })))))
                    .render());
            });
        }
        else if ((parts = /^video[/]shows[/]([^/?]*)/.exec(uri)) !== null) {
            let encodedQuery = parts[1];
            req(`/api/video/shows/${encodedQuery}?token=${token}`, {}, (status, response) => {
                let shows = response.shows;
                mount.appendChild(xml.element("div")
                    .add(xml.element("div.content")
                    .add(renderTextHeader(xml.text("Shows"))))
                    .add(xml.element("div.content")
                    .add(Grid.make()
                    .add(...shows.map((show) => EntityCard.forShow(show)))))
                    .render());
            });
        }
        else if ((parts = /^video[/]episodes[/]([0-9a-f]{16})[/]/.exec(uri)) !== null) {
            let episode_id = parts[1];
            req(`/api/video/episodes/${episode_id}/?token=${token}`, {}, (status, response) => {
                let episode = response.episode;
                let last = response.last;
                let next = response.next;
                mount.appendChild(xml.element("div")
                    .add(xml.element("div.content")
                    .add(EntityCard.forEpisode(episode, { compactDescription: false })))
                    .add(xml.element("div.content")
                    .add(entityNavLinkFactory.forEpisode(last, next)))
                    .render());
            });
        }
        else if ((parts = /^video[/]episodes[/]([^/?]*)/.exec(uri)) !== null) {
            let encodedQuery = parts[1];
            let offset = 0;
            let reachedEnd = new observers_2.ObservableClass(false);
            let isLoading = new observers_2.ObservableClass(false);
            let episodes = new observers_2.ArrayObservable([]);
            async function load() {
                if (!reachedEnd.getState() && !isLoading.getState()) {
                    isLoading.updateState(true);
                    let response = await preq(`/api/video/episodes/${encodedQuery}?offset=${offset}&token=${token}`, {});
                    for (let episode of response.episodes) {
                        episodes.append(episode);
                    }
                    offset += response.episodes.length;
                    if (response.episodes.length === 0) {
                        reachedEnd.updateState(true);
                    }
                    isLoading.updateState(false);
                }
            }
            ;
            mount.appendChild(xml.element("div")
                .add(xml.element("div.content")
                .add(renderTextHeader(xml.text("Episodes"))))
                .add(xml.element("div.content")
                .add(Grid.make()
                .repeat(episodes, (episode) => EntityCard.forEpisode(episode))))
                .add(observe(xml.element("div").set("style", "height: 1px;"), load))
                .render());
        }
        else if ((parts = /^video[/]movies[/]([0-9a-f]{16})[/]/.exec(uri)) !== null) {
            let movie_id = parts[1];
            req(`/api/video/movies/${movie_id}/?token=${token}`, {}, (status, response) => {
                let offset = 0;
                let reachedEnd = new observers_2.ObservableClass(false);
                let isLoading = new observers_2.ObservableClass(false);
                let movies = new observers_2.ArrayObservable([]);
                async function load() {
                    if (!reachedEnd.getState() && !isLoading.getState()) {
                        isLoading.updateState(true);
                        let response = await preq(`/api/video/movies/${movie_id}/suggestions/movies/?offset=${offset}&token=${token}`, {});
                        for (let movie of response.movies) {
                            movies.append(movie);
                        }
                        offset += response.movies.length;
                        if (response.movies.length === 0) {
                            reachedEnd.updateState(true);
                        }
                        isLoading.updateState(false);
                    }
                }
                ;
                let movie = response.movie;
                mount.appendChild(xml.element("div")
                    .add(xml.element("div.content")
                    .add(EntityCard.forMovie(movie, { compactDescription: false })))
                    .add(xml.element("div.content")
                    .set("data-hide", `${movie.actors.length === 0}`)
                    .set("style", "display: grid; gap: 16px;")
                    .add(...movie.actors.map((actor) => EntityRow.forActor(actor))))
                    .add(xml.element("div.content")
                    .bind("data-hide", movies.compute((movies) => movies.length === 0))
                    .set("style", "display: grid; gap: 16px;")
                    .add(renderTextHeader(xml.text("Suggested movies")))
                    .add(Grid.make()
                    .repeat(movies, (movie) => EntityCard.forMovie(movie))))
                    .add(observe(xml.element("div").set("style", "height: 1px;"), load))
                    .render());
            });
        }
        else if ((parts = /^video[/]movies[/]([^/?]*)/.exec(uri)) !== null) {
            let encodedQuery = parts[1];
            let offset = 0;
            let reachedEnd = new observers_2.ObservableClass(false);
            let isLoading = new observers_2.ObservableClass(false);
            let movies = new observers_2.ArrayObservable([]);
            async function load() {
                if (!reachedEnd.getState() && !isLoading.getState()) {
                    isLoading.updateState(true);
                    let response = await preq(`/api/video/movies/${encodedQuery}?offset=${offset}&token=${token}`, {});
                    for (let movie of response.movies) {
                        movies.append(movie);
                    }
                    offset += response.movies.length;
                    if (response.movies.length === 0) {
                        reachedEnd.updateState(true);
                    }
                    isLoading.updateState(false);
                }
            }
            ;
            mount.appendChild(xml.element("div")
                .add(xml.element("div.content")
                .add(renderTextHeader(xml.text("Movies"))))
                .add(xml.element("div.content")
                .add(Grid.make()
                .repeat(movies, (movie) => EntityCard.forMovie(movie))))
                .add(observe(xml.element("div").set("style", "height: 1px;"), load))
                .render());
        }
        else if ((parts = /^video[/]cues[/]([^/?]*)/.exec(uri)) !== null) {
            let encodedQuery = parts[1];
            let offset = 0;
            let reachedEnd = new observers_2.ObservableClass(false);
            let isLoading = new observers_2.ObservableClass(false);
            let cues = new observers_2.ArrayObservable([]);
            async function load() {
                if (!reachedEnd.getState() && !isLoading.getState()) {
                    isLoading.updateState(true);
                    let response = await preq(`/api/video/cues/${encodedQuery}?offset=${offset}&token=${token}`, {});
                    for (let cue of response.cues) {
                        cues.append(cue);
                    }
                    offset += response.cues.length;
                    if (response.cues.length === 0) {
                        reachedEnd.updateState(true);
                    }
                    isLoading.updateState(false);
                }
            }
            ;
            mount.appendChild(xml.element("div.content")
                .add(xml.element("div")
                .set("style", "display: grid; gap: 16px;")
                .repeat(cues, (cue) => EntityRow.forCue(cue)))
                .add(observe(xml.element("div").set("style", "height: 1px;"), load))
                .render());
        }
        else if ((parts = /^video[/]genres[/]([0-9a-f]{16})[/]/.exec(uri)) !== null) {
            let genre_id = parts[1];
            req(`/api/video/genres/${genre_id}/?token=${token}`, {}, (status, response) => {
                let genre = response.genre;
                req(`/api/video/genres/${genre_id}/shows/?token=${token}`, {}, (status, response) => {
                    let shows = response.shows;
                    let offset = 0;
                    let reachedEnd = new observers_2.ObservableClass(false);
                    let isLoading = new observers_2.ObservableClass(false);
                    let movies = new observers_2.ArrayObservable([]);
                    async function load() {
                        if (!reachedEnd.getState() && !isLoading.getState()) {
                            isLoading.updateState(true);
                            let response = await preq(`/api/video/genres/${genre_id}/movies/?offset=${offset}&token=${token}`, {});
                            for (let movie of response.movies) {
                                movies.append(movie);
                            }
                            offset += response.movies.length;
                            if (response.movies.length === 0) {
                                reachedEnd.updateState(true);
                            }
                            isLoading.updateState(false);
                        }
                    }
                    ;
                    mount.appendChild(xml.element("div")
                        .add(xml.element("div.content")
                        .add(renderTextHeader(xml.text(genre.title))))
                        .add(shows.length === 0 ? undefined : xml.element("div.content")
                        .set("style", "display: grid; gap: 24px;")
                        .add(renderTextHeader(xml.text("Shows")))
                        .add(carouselFactory.make(...shows.map((show) => EntityCard.forShow(show)))))
                        .add(xml.element("div.content")
                        .bind("data-hide", movies.compute((movies) => movies.length === 0))
                        .set("style", "display: grid; gap: 24px;")
                        .add(renderTextHeader(xml.text("Movies")))
                        .add(Grid.make()
                        .repeat(movies, (movie) => EntityCard.forMovie(movie))))
                        .add(observe(xml.element("div").set("style", "height: 1px;"), load))
                        .render());
                });
            });
        }
        else if ((parts = /^video[/]genres[/]([^/?]*)/.exec(uri)) !== null) {
            let encodedQuery = parts[1];
            req(`/api/video/genres/${encodedQuery}?token=${token}`, {}, (status, response) => {
                let genres = response.genres;
                mount.appendChild(xml.element("div")
                    .add(xml.element("div.content")
                    .add(Grid.make({ mini: true })
                    .add(...genres.map((genre) => makeIconLink(Icon.makePieChart(), genre.title, `video/genres/${genre.genre_id}/`)))))
                    .render());
            });
        }
        else if ((parts = /^video[/]/.exec(uri)) !== null) {
            mount.appendChild(xml.element("div")
                .add(xml.element("div.content")
                .add(Grid.make({ mini: true })
                .add(makeIconLink(Icon.makeStar(), "Movies", "video/movies/"))
                .add(makeIconLink(Icon.makeMonitor(), "Shows", "video/shows/"))
                .add(makeIconLink(Icon.makePieChart(), "Genres", "video/genres/"))
                .add(makeIconLink(Icon.makePerson(), "Actors", "actors/"))))
                .render());
        }
        else if ((parts = /^search[/]([^/]*)/.exec(uri)) !== null) {
            let query = new observers_2.ObservableClass(decodeURIComponent(parts[1]));
            let offset = 0;
            let reachedEnd = new observers_2.ObservableClass(false);
            let isLoading = new observers_2.ObservableClass(false);
            let entities = new observers_2.ArrayObservable([]);
            async function load() {
                if (!reachedEnd.getState() && !isLoading.getState()) {
                    isLoading.updateState(true);
                    let response = await preq(`/api/search/${encodeURIComponent(query.getState())}?offset=${offset}&token=${token}`, {});
                    for (let entity of response.entities) {
                        entities.append(entity);
                    }
                    offset += response.entities.length;
                    if (response.entities.length === 0) {
                        reachedEnd.updateState(true);
                    }
                    isLoading.updateState(false);
                }
            }
            ;
            let headEntities = new observers_2.ArrayObservable([]);
            let tailEntities = new observers_2.ArrayObservable([]);
            entities.addObserver({
                onappend(entity) {
                    if (headEntities.getState().length === 0) {
                        headEntities.append(entity);
                    }
                    else {
                        tailEntities.append(entity);
                    }
                }
            });
            mount.appendChild(xml.element("div.content")
                .add(xml.element("div")
                .set("style", "position: relative;")
                .add(xml.element("input")
                .set("type", "text")
                .set("spellcheck", "false")
                .set("placeholder", "Search...")
                .bind2("value", query)
                .on("keyup", (event) => {
                if (event.code === "Enter") {
                    navigate(`search/${encodeURIComponent(query.getState())}`);
                }
            }))
                .add(Icon.makeMagnifyingGlass()
                .set("style", "fill: rgb(255, 255, 255); position: absolute; left: 0px; top: 50%; transform: translate(100%, -50%);")))
                .add(xml.element("div")
                .set("style", "display: grid; gap: 24px;")
                .bind("data-hide", headEntities.compute((v) => v.length === 0))
                .repeat(headEntities, (entity) => EntityCard.forEntity(entity, { compactDescription: false })))
                .add(xml.element("div")
                .set("style", "display: grid; gap: 16px;")
                .bind("data-hide", tailEntities.compute((v) => v.length === 0))
                .repeat(tailEntities, (entity) => EntityRow.forEntity(entity)))
                .add(observe(xml.element("div").set("style", "height: 1px;"), load))
                .render());
        }
        else if ((parts = /^years[/]([0-9a-f]{16})[/]/.exec(uri)) !== null) {
            let year_id = parts[1];
            preq(`/api/years/${year_id}/?token=${token}`, {}).then((response) => {
                let year = response.year;
                let movies = response.movies;
                let albums = response.albums;
                mount.appendChild(xml.element("div")
                    .add(xml.element("div.content")
                    .add(renderTextHeader(xml.text(`${year.year}`)))
                    .add(xml.element("div")
                    .set("style", "display: grid; gap: 24px;")
                    .set("data-hide", `${movies.length === 0}`)
                    .add(renderTextHeader(xml.text("Movies")))
                    .add(carouselFactory.make(...movies.map((movie) => EntityCard.forMovie(movie)))))
                    .add(xml.element("div")
                    .set("style", "display: grid; gap: 24px;")
                    .set("data-hide", `${albums.length === 0}`)
                    .add(renderTextHeader(xml.text("Albums")))
                    .add(Grid.make()
                    .add(...albums.map((album) => EntityCard.forAlbum(album))))))
                    .render());
            });
        }
        else if ((parts = /^years[/]([^/]*)/.exec(uri)) !== null) {
            let encodedQuery = parts[1];
            preq(`/api/years/${encodedQuery}?length=100&token=${token}`, {}).then((response) => {
                let years = response.years;
                mount.appendChild(xml.element("div")
                    .add(xml.element("div.content")
                    .add(Grid.make({ mini: true })
                    .add(...years.map((year) => makeIconLink(Icon.makeCalendar(), `${year.year}`, `years/${year.year_id}/`)))))
                    .render());
            });
        }
        else {
            mount.appendChild(xml.element("div")
                .add(xml.element("div.content")
                .add(Grid.make({ mini: true })
                .add(makeIconLink(Icon.makeMonitor(), "Watch", "video/"))
                .add(makeIconLink(Icon.makeSpeaker(), "Listen", "audio/"))
                .add(makeIconLink(Icon.makeMagnifyingGlass(), "Search", "search/"))
                .add(makeIconLink(Icon.makeCalendar(), "Revisit", "years/"))))
                .render());
        }
    };
    let get_basehref = () => {
        let element = document.head.querySelector('base[href]');
        if (element !== null) {
            let attribute = element.getAttribute('href');
            if (attribute !== null) {
                return attribute;
            }
        }
        return "/";
    };
    let get_route = (pathname = window.location.pathname, basehref = get_basehref()) => {
        let pn = pathname.split('/');
        let bh = basehref.split('/');
        let i = 0;
        while (i < pn.length && i < bh.length && pn[i] === bh[i]) {
            i++;
        }
        let uri = pn.slice(i).join('/');
        //return uri === '' ? './' : uri;
        return uri;
    };
    let mount_cache = new Array();
    let mounted_uri;
    function navigate(uri, use_cache = false) {
        if (is.present(mounted_uri)) {
            let entry = mount_cache.find((entry) => entry.uri === mounted_uri);
            if (is.present(entry)) {
                mount_cache.splice(mount_cache.indexOf(entry), 1);
                entry.x = mount.scrollLeft;
                entry.y = mount.scrollTop;
            }
            else {
                entry = {
                    uri: mounted_uri,
                    element: mount.firstChild,
                    x: mount.scrollLeft,
                    y: mount.scrollTop
                };
            }
            mount_cache.unshift(entry);
        }
        mount_cache = mount_cache.slice(0, 10);
        while (is.present(mount.lastChild)) {
            mount.lastChild.remove();
        }
        let entry = mount_cache.find((entry) => entry.uri === uri);
        if (is.present(entry) && use_cache) {
            mount.appendChild(entry.element);
            mount.scrollLeft = entry.x;
            mount.scrollTop = entry.y;
        }
        else {
            updateviewforuri(uri);
        }
        if (is.absent(window.history.state)) {
            window.history.replaceState({ uri, index: historyIndex.getState() }, "", uri);
        }
        else {
            if (uri !== window.history.state.uri) {
                window.history.pushState({ uri, index: historyIndex.getState() + 1 }, "", uri);
                historyIndex.updateState(historyIndex.getState() + 1);
                historyLength.updateState(historyIndex.getState() + 1);
            }
            else {
                historyIndex.updateState(window.history.state.index);
            }
        }
        mounted_uri = uri;
    }
    function setupRouting() {
        window.addEventListener("popstate", (event) => {
            let uri = event.state.uri;
            navigate(uri, true);
        });
        navigate(get_route());
    }
    setupRouting();
});
function define(e,t,l){null==this.x&&(this.x=new Map),null==this.z&&(this.z=(e=>require(e))),null==this.y&&(this.y=(e=>{let t=this.x.get(e);if(null==t||null!=t.module)return;let l=Array(),u={exports:{}};for(let e of t.dependencies){if("require"===e){l.push(this.z);continue}if("module"===e){l.push(u);continue}if("exports"===e){l.push(u.exports);continue}try{l.push(this.z(e));continue}catch(e){}let t=this.x.get(e);if(null==t||null==t.module)return;l.push(t.module.exports)}t.callback(...l),t.module=u;for(let e of t.dependencies)this.y(e)}));let u=this.x.get(e);if(null!=u)throw'Duplicate module found with name "'+e+'"!';u={callback:l,dependencies:t,module:null},this.x.set(e,u),this.y(e)}