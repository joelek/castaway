// This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.

import * as autoguard from "@joelek/ts-autoguard";
import * as shared from "./index";

export const makeServer = (routes: autoguard.api.Server<shared.Autoguard.Requests, shared.Autoguard.Responses>, options?: Partial<{ urlPrefix: string }>): autoguard.api.RequestListener => {
	let endpoints = new Array<autoguard.api.Endpoint>();
	endpoints.push((raw, auxillary) => {
		let method = "POST";
		let components = new Array<[string, string]>();
		components.push(["", decodeURIComponent("auth")]);
		components.push(["", decodeURIComponent("")]);
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, components),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options = autoguard.api.combineKeyValuePairs(raw.parameters);
				let headers = autoguard.api.combineKeyValuePairs(raw.headers);
				headers["x-circus-username"] = autoguard.api.getValue(raw.headers, "x-circus-username", true);
				headers["x-circus-password"] = autoguard.api.getValue(raw.headers, "x-circus-password", true);
				let payload = await autoguard.api.deserializePayload(raw.payload);
				let guard = shared.Autoguard.Requests["POST:/auth/"];
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["POST:/auth/"](new autoguard.api.ClientRequest(request, auxillary));
						return {
							validateResponse: async () => {
								let guard = shared.Autoguard.Responses["POST:/auth/"];
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								autoguard.api.appendKeyValuePair(headers, "x-circus-token", response.headers?.["x-circus-token"], true);
								headers.push(...autoguard.api.extractKeyValuePairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								return autoguard.api.finalizeResponse({ status, headers, payload }, "application/octet-stream");
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "POST";
		let components = new Array<[string, string]>();
		components.push(["", decodeURIComponent("users")]);
		components.push(["", decodeURIComponent("")]);
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, components),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options = autoguard.api.combineKeyValuePairs(raw.parameters);
				let headers = autoguard.api.combineKeyValuePairs(raw.headers);
				let payload = await autoguard.api.deserializePayload(raw.payload);
				let guard = shared.Autoguard.Requests["POST:/users/"];
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["POST:/users/"](new autoguard.api.ClientRequest(request, auxillary));
						return {
							validateResponse: async () => {
								let guard = shared.Autoguard.Responses["POST:/users/"];
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.extractKeyValuePairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								return autoguard.api.finalizeResponse({ status, headers, payload }, "application/json; charset=utf-8");
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let components = new Array<[string, string]>();
		components.push(["query", raw.components[0]]);
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, components),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options = autoguard.api.combineKeyValuePairs(raw.parameters);
				options["query"] = autoguard.api.getValue(components, "query", true);
				options["token"] = autoguard.api.getValue(raw.parameters, "token", true);
				options["offset"] = autoguard.api.getValue(raw.parameters, "offset", false);
				options["limit"] = autoguard.api.getValue(raw.parameters, "limit", false);
				options["cues"] = autoguard.api.getValue(raw.parameters, "cues", false);
				let headers = autoguard.api.combineKeyValuePairs(raw.headers);
				let payload = await autoguard.api.deserializePayload(raw.payload);
				let guard = shared.Autoguard.Requests["GET:/<query>"];
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/<query>"](new autoguard.api.ClientRequest(request, auxillary));
						return {
							validateResponse: async () => {
								let guard = shared.Autoguard.Responses["GET:/<query>"];
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.extractKeyValuePairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								return autoguard.api.finalizeResponse({ status, headers, payload }, "application/json; charset=utf-8");
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let components = new Array<[string, string]>();
		components.push(["", decodeURIComponent("actors")]);
		components.push(["query", raw.components[1]]);
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, components),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options = autoguard.api.combineKeyValuePairs(raw.parameters);
				options["query"] = autoguard.api.getValue(components, "query", true);
				options["token"] = autoguard.api.getValue(raw.parameters, "token", true);
				options["offset"] = autoguard.api.getValue(raw.parameters, "offset", false);
				options["limit"] = autoguard.api.getValue(raw.parameters, "limit", false);
				let headers = autoguard.api.combineKeyValuePairs(raw.headers);
				let payload = await autoguard.api.deserializePayload(raw.payload);
				let guard = shared.Autoguard.Requests["GET:/actors/<query>"];
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/actors/<query>"](new autoguard.api.ClientRequest(request, auxillary));
						return {
							validateResponse: async () => {
								let guard = shared.Autoguard.Responses["GET:/actors/<query>"];
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.extractKeyValuePairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								return autoguard.api.finalizeResponse({ status, headers, payload }, "application/json; charset=utf-8");
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let components = new Array<[string, string]>();
		components.push(["", decodeURIComponent("actors")]);
		components.push(["actor_id", raw.components[1]]);
		components.push(["", decodeURIComponent("")]);
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, components),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options = autoguard.api.combineKeyValuePairs(raw.parameters);
				options["actor_id"] = autoguard.api.getValue(components, "actor_id", true);
				options["token"] = autoguard.api.getValue(raw.parameters, "token", true);
				let headers = autoguard.api.combineKeyValuePairs(raw.headers);
				let payload = await autoguard.api.deserializePayload(raw.payload);
				let guard = shared.Autoguard.Requests["GET:/actors/<actor_id>/"];
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/actors/<actor_id>/"](new autoguard.api.ClientRequest(request, auxillary));
						return {
							validateResponse: async () => {
								let guard = shared.Autoguard.Responses["GET:/actors/<actor_id>/"];
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.extractKeyValuePairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								return autoguard.api.finalizeResponse({ status, headers, payload }, "application/json; charset=utf-8");
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let components = new Array<[string, string]>();
		components.push(["", decodeURIComponent("actors")]);
		components.push(["actor_id", raw.components[1]]);
		components.push(["", decodeURIComponent("movies")]);
		components.push(["", decodeURIComponent("")]);
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, components),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options = autoguard.api.combineKeyValuePairs(raw.parameters);
				options["actor_id"] = autoguard.api.getValue(components, "actor_id", true);
				options["token"] = autoguard.api.getValue(raw.parameters, "token", true);
				options["offset"] = autoguard.api.getValue(raw.parameters, "offset", false);
				options["limit"] = autoguard.api.getValue(raw.parameters, "limit", false);
				let headers = autoguard.api.combineKeyValuePairs(raw.headers);
				let payload = await autoguard.api.deserializePayload(raw.payload);
				let guard = shared.Autoguard.Requests["GET:/actors/<actor_id>/movies/"];
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/actors/<actor_id>/movies/"](new autoguard.api.ClientRequest(request, auxillary));
						return {
							validateResponse: async () => {
								let guard = shared.Autoguard.Responses["GET:/actors/<actor_id>/movies/"];
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.extractKeyValuePairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								return autoguard.api.finalizeResponse({ status, headers, payload }, "application/json; charset=utf-8");
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let components = new Array<[string, string]>();
		components.push(["", decodeURIComponent("actors")]);
		components.push(["actor_id", raw.components[1]]);
		components.push(["", decodeURIComponent("shows")]);
		components.push(["", decodeURIComponent("")]);
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, components),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options = autoguard.api.combineKeyValuePairs(raw.parameters);
				options["actor_id"] = autoguard.api.getValue(components, "actor_id", true);
				options["token"] = autoguard.api.getValue(raw.parameters, "token", true);
				options["offset"] = autoguard.api.getValue(raw.parameters, "offset", false);
				options["limit"] = autoguard.api.getValue(raw.parameters, "limit", false);
				let headers = autoguard.api.combineKeyValuePairs(raw.headers);
				let payload = await autoguard.api.deserializePayload(raw.payload);
				let guard = shared.Autoguard.Requests["GET:/actors/<actor_id>/shows/"];
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/actors/<actor_id>/shows/"](new autoguard.api.ClientRequest(request, auxillary));
						return {
							validateResponse: async () => {
								let guard = shared.Autoguard.Responses["GET:/actors/<actor_id>/shows/"];
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.extractKeyValuePairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								return autoguard.api.finalizeResponse({ status, headers, payload }, "application/json; charset=utf-8");
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let components = new Array<[string, string]>();
		components.push(["", decodeURIComponent("albums")]);
		components.push(["query", raw.components[1]]);
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, components),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options = autoguard.api.combineKeyValuePairs(raw.parameters);
				options["query"] = autoguard.api.getValue(components, "query", true);
				options["token"] = autoguard.api.getValue(raw.parameters, "token", true);
				options["offset"] = autoguard.api.getValue(raw.parameters, "offset", false);
				options["limit"] = autoguard.api.getValue(raw.parameters, "limit", false);
				let headers = autoguard.api.combineKeyValuePairs(raw.headers);
				let payload = await autoguard.api.deserializePayload(raw.payload);
				let guard = shared.Autoguard.Requests["GET:/albums/<query>"];
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/albums/<query>"](new autoguard.api.ClientRequest(request, auxillary));
						return {
							validateResponse: async () => {
								let guard = shared.Autoguard.Responses["GET:/albums/<query>"];
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.extractKeyValuePairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								return autoguard.api.finalizeResponse({ status, headers, payload }, "application/json; charset=utf-8");
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let components = new Array<[string, string]>();
		components.push(["", decodeURIComponent("albums")]);
		components.push(["album_id", raw.components[1]]);
		components.push(["", decodeURIComponent("")]);
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, components),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options = autoguard.api.combineKeyValuePairs(raw.parameters);
				options["album_id"] = autoguard.api.getValue(components, "album_id", true);
				options["token"] = autoguard.api.getValue(raw.parameters, "token", true);
				let headers = autoguard.api.combineKeyValuePairs(raw.headers);
				let payload = await autoguard.api.deserializePayload(raw.payload);
				let guard = shared.Autoguard.Requests["GET:/albums/<album_id>/"];
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/albums/<album_id>/"](new autoguard.api.ClientRequest(request, auxillary));
						return {
							validateResponse: async () => {
								let guard = shared.Autoguard.Responses["GET:/albums/<album_id>/"];
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.extractKeyValuePairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								return autoguard.api.finalizeResponse({ status, headers, payload }, "application/json; charset=utf-8");
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let components = new Array<[string, string]>();
		components.push(["", decodeURIComponent("artists")]);
		components.push(["query", raw.components[1]]);
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, components),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options = autoguard.api.combineKeyValuePairs(raw.parameters);
				options["query"] = autoguard.api.getValue(components, "query", true);
				options["token"] = autoguard.api.getValue(raw.parameters, "token", true);
				options["offset"] = autoguard.api.getValue(raw.parameters, "offset", false);
				options["limit"] = autoguard.api.getValue(raw.parameters, "limit", false);
				let headers = autoguard.api.combineKeyValuePairs(raw.headers);
				let payload = await autoguard.api.deserializePayload(raw.payload);
				let guard = shared.Autoguard.Requests["GET:/artists/<query>"];
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/artists/<query>"](new autoguard.api.ClientRequest(request, auxillary));
						return {
							validateResponse: async () => {
								let guard = shared.Autoguard.Responses["GET:/artists/<query>"];
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.extractKeyValuePairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								return autoguard.api.finalizeResponse({ status, headers, payload }, "application/json; charset=utf-8");
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let components = new Array<[string, string]>();
		components.push(["", decodeURIComponent("artists")]);
		components.push(["artist_id", raw.components[1]]);
		components.push(["", decodeURIComponent("")]);
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, components),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options = autoguard.api.combineKeyValuePairs(raw.parameters);
				options["artist_id"] = autoguard.api.getValue(components, "artist_id", true);
				options["token"] = autoguard.api.getValue(raw.parameters, "token", true);
				let headers = autoguard.api.combineKeyValuePairs(raw.headers);
				let payload = await autoguard.api.deserializePayload(raw.payload);
				let guard = shared.Autoguard.Requests["GET:/artists/<artist_id>/"];
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/artists/<artist_id>/"](new autoguard.api.ClientRequest(request, auxillary));
						return {
							validateResponse: async () => {
								let guard = shared.Autoguard.Responses["GET:/artists/<artist_id>/"];
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.extractKeyValuePairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								return autoguard.api.finalizeResponse({ status, headers, payload }, "application/json; charset=utf-8");
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let components = new Array<[string, string]>();
		components.push(["", decodeURIComponent("discs")]);
		components.push(["query", raw.components[1]]);
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, components),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options = autoguard.api.combineKeyValuePairs(raw.parameters);
				options["query"] = autoguard.api.getValue(components, "query", true);
				options["token"] = autoguard.api.getValue(raw.parameters, "token", true);
				options["offset"] = autoguard.api.getValue(raw.parameters, "offset", false);
				options["limit"] = autoguard.api.getValue(raw.parameters, "limit", false);
				let headers = autoguard.api.combineKeyValuePairs(raw.headers);
				let payload = await autoguard.api.deserializePayload(raw.payload);
				let guard = shared.Autoguard.Requests["GET:/discs/<query>"];
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/discs/<query>"](new autoguard.api.ClientRequest(request, auxillary));
						return {
							validateResponse: async () => {
								let guard = shared.Autoguard.Responses["GET:/discs/<query>"];
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.extractKeyValuePairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								return autoguard.api.finalizeResponse({ status, headers, payload }, "application/json; charset=utf-8");
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let components = new Array<[string, string]>();
		components.push(["", decodeURIComponent("discs")]);
		components.push(["disc_id", raw.components[1]]);
		components.push(["", decodeURIComponent("")]);
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, components),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options = autoguard.api.combineKeyValuePairs(raw.parameters);
				options["disc_id"] = autoguard.api.getValue(components, "disc_id", true);
				options["token"] = autoguard.api.getValue(raw.parameters, "token", true);
				let headers = autoguard.api.combineKeyValuePairs(raw.headers);
				let payload = await autoguard.api.deserializePayload(raw.payload);
				let guard = shared.Autoguard.Requests["GET:/discs/<disc_id>/"];
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/discs/<disc_id>/"](new autoguard.api.ClientRequest(request, auxillary));
						return {
							validateResponse: async () => {
								let guard = shared.Autoguard.Responses["GET:/discs/<disc_id>/"];
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.extractKeyValuePairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								return autoguard.api.finalizeResponse({ status, headers, payload }, "application/json; charset=utf-8");
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let components = new Array<[string, string]>();
		components.push(["", decodeURIComponent("episodes")]);
		components.push(["query", raw.components[1]]);
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, components),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options = autoguard.api.combineKeyValuePairs(raw.parameters);
				options["query"] = autoguard.api.getValue(components, "query", true);
				options["token"] = autoguard.api.getValue(raw.parameters, "token", true);
				options["offset"] = autoguard.api.getValue(raw.parameters, "offset", false);
				options["limit"] = autoguard.api.getValue(raw.parameters, "limit", false);
				let headers = autoguard.api.combineKeyValuePairs(raw.headers);
				let payload = await autoguard.api.deserializePayload(raw.payload);
				let guard = shared.Autoguard.Requests["GET:/episodes/<query>"];
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/episodes/<query>"](new autoguard.api.ClientRequest(request, auxillary));
						return {
							validateResponse: async () => {
								let guard = shared.Autoguard.Responses["GET:/episodes/<query>"];
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.extractKeyValuePairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								return autoguard.api.finalizeResponse({ status, headers, payload }, "application/json; charset=utf-8");
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let components = new Array<[string, string]>();
		components.push(["", decodeURIComponent("episodes")]);
		components.push(["episode_id", raw.components[1]]);
		components.push(["", decodeURIComponent("")]);
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, components),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options = autoguard.api.combineKeyValuePairs(raw.parameters);
				options["episode_id"] = autoguard.api.getValue(components, "episode_id", true);
				options["token"] = autoguard.api.getValue(raw.parameters, "token", true);
				let headers = autoguard.api.combineKeyValuePairs(raw.headers);
				let payload = await autoguard.api.deserializePayload(raw.payload);
				let guard = shared.Autoguard.Requests["GET:/episodes/<episode_id>/"];
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/episodes/<episode_id>/"](new autoguard.api.ClientRequest(request, auxillary));
						return {
							validateResponse: async () => {
								let guard = shared.Autoguard.Responses["GET:/episodes/<episode_id>/"];
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.extractKeyValuePairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								return autoguard.api.finalizeResponse({ status, headers, payload }, "application/json; charset=utf-8");
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let components = new Array<[string, string]>();
		components.push(["", decodeURIComponent("genres")]);
		components.push(["query", raw.components[1]]);
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, components),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options = autoguard.api.combineKeyValuePairs(raw.parameters);
				options["query"] = autoguard.api.getValue(components, "query", true);
				options["token"] = autoguard.api.getValue(raw.parameters, "token", true);
				options["offset"] = autoguard.api.getValue(raw.parameters, "offset", false);
				options["limit"] = autoguard.api.getValue(raw.parameters, "limit", false);
				let headers = autoguard.api.combineKeyValuePairs(raw.headers);
				let payload = await autoguard.api.deserializePayload(raw.payload);
				let guard = shared.Autoguard.Requests["GET:/genres/<query>"];
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/genres/<query>"](new autoguard.api.ClientRequest(request, auxillary));
						return {
							validateResponse: async () => {
								let guard = shared.Autoguard.Responses["GET:/genres/<query>"];
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.extractKeyValuePairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								return autoguard.api.finalizeResponse({ status, headers, payload }, "application/json; charset=utf-8");
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let components = new Array<[string, string]>();
		components.push(["", decodeURIComponent("genres")]);
		components.push(["genre_id", raw.components[1]]);
		components.push(["", decodeURIComponent("")]);
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, components),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options = autoguard.api.combineKeyValuePairs(raw.parameters);
				options["genre_id"] = autoguard.api.getValue(components, "genre_id", true);
				options["token"] = autoguard.api.getValue(raw.parameters, "token", true);
				let headers = autoguard.api.combineKeyValuePairs(raw.headers);
				let payload = await autoguard.api.deserializePayload(raw.payload);
				let guard = shared.Autoguard.Requests["GET:/genres/<genre_id>/"];
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/genres/<genre_id>/"](new autoguard.api.ClientRequest(request, auxillary));
						return {
							validateResponse: async () => {
								let guard = shared.Autoguard.Responses["GET:/genres/<genre_id>/"];
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.extractKeyValuePairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								return autoguard.api.finalizeResponse({ status, headers, payload }, "application/json; charset=utf-8");
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let components = new Array<[string, string]>();
		components.push(["", decodeURIComponent("genres")]);
		components.push(["genre_id", raw.components[1]]);
		components.push(["", decodeURIComponent("movies")]);
		components.push(["", decodeURIComponent("")]);
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, components),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options = autoguard.api.combineKeyValuePairs(raw.parameters);
				options["genre_id"] = autoguard.api.getValue(components, "genre_id", true);
				options["token"] = autoguard.api.getValue(raw.parameters, "token", true);
				options["offset"] = autoguard.api.getValue(raw.parameters, "offset", false);
				options["limit"] = autoguard.api.getValue(raw.parameters, "limit", false);
				let headers = autoguard.api.combineKeyValuePairs(raw.headers);
				let payload = await autoguard.api.deserializePayload(raw.payload);
				let guard = shared.Autoguard.Requests["GET:/genres/<genre_id>/movies/"];
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/genres/<genre_id>/movies/"](new autoguard.api.ClientRequest(request, auxillary));
						return {
							validateResponse: async () => {
								let guard = shared.Autoguard.Responses["GET:/genres/<genre_id>/movies/"];
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.extractKeyValuePairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								return autoguard.api.finalizeResponse({ status, headers, payload }, "application/json; charset=utf-8");
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let components = new Array<[string, string]>();
		components.push(["", decodeURIComponent("genres")]);
		components.push(["genre_id", raw.components[1]]);
		components.push(["", decodeURIComponent("shows")]);
		components.push(["", decodeURIComponent("")]);
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, components),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options = autoguard.api.combineKeyValuePairs(raw.parameters);
				options["genre_id"] = autoguard.api.getValue(components, "genre_id", true);
				options["token"] = autoguard.api.getValue(raw.parameters, "token", true);
				options["offset"] = autoguard.api.getValue(raw.parameters, "offset", false);
				options["limit"] = autoguard.api.getValue(raw.parameters, "limit", false);
				let headers = autoguard.api.combineKeyValuePairs(raw.headers);
				let payload = await autoguard.api.deserializePayload(raw.payload);
				let guard = shared.Autoguard.Requests["GET:/genres/<genre_id>/shows/"];
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/genres/<genre_id>/shows/"](new autoguard.api.ClientRequest(request, auxillary));
						return {
							validateResponse: async () => {
								let guard = shared.Autoguard.Responses["GET:/genres/<genre_id>/shows/"];
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.extractKeyValuePairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								return autoguard.api.finalizeResponse({ status, headers, payload }, "application/json; charset=utf-8");
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let components = new Array<[string, string]>();
		components.push(["", decodeURIComponent("movies")]);
		components.push(["query", raw.components[1]]);
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, components),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options = autoguard.api.combineKeyValuePairs(raw.parameters);
				options["query"] = autoguard.api.getValue(components, "query", true);
				options["token"] = autoguard.api.getValue(raw.parameters, "token", true);
				options["offset"] = autoguard.api.getValue(raw.parameters, "offset", false);
				options["limit"] = autoguard.api.getValue(raw.parameters, "limit", false);
				let headers = autoguard.api.combineKeyValuePairs(raw.headers);
				let payload = await autoguard.api.deserializePayload(raw.payload);
				let guard = shared.Autoguard.Requests["GET:/movies/<query>"];
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/movies/<query>"](new autoguard.api.ClientRequest(request, auxillary));
						return {
							validateResponse: async () => {
								let guard = shared.Autoguard.Responses["GET:/movies/<query>"];
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.extractKeyValuePairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								return autoguard.api.finalizeResponse({ status, headers, payload }, "application/json; charset=utf-8");
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let components = new Array<[string, string]>();
		components.push(["", decodeURIComponent("movies")]);
		components.push(["movie_id", raw.components[1]]);
		components.push(["", decodeURIComponent("")]);
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, components),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options = autoguard.api.combineKeyValuePairs(raw.parameters);
				options["movie_id"] = autoguard.api.getValue(components, "movie_id", true);
				options["token"] = autoguard.api.getValue(raw.parameters, "token", true);
				let headers = autoguard.api.combineKeyValuePairs(raw.headers);
				let payload = await autoguard.api.deserializePayload(raw.payload);
				let guard = shared.Autoguard.Requests["GET:/movies/<movie_id>/"];
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/movies/<movie_id>/"](new autoguard.api.ClientRequest(request, auxillary));
						return {
							validateResponse: async () => {
								let guard = shared.Autoguard.Responses["GET:/movies/<movie_id>/"];
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.extractKeyValuePairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								return autoguard.api.finalizeResponse({ status, headers, payload }, "application/json; charset=utf-8");
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let components = new Array<[string, string]>();
		components.push(["", decodeURIComponent("movies")]);
		components.push(["movie_id", raw.components[1]]);
		components.push(["", decodeURIComponent("suggestions")]);
		components.push(["", decodeURIComponent("")]);
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, components),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options = autoguard.api.combineKeyValuePairs(raw.parameters);
				options["movie_id"] = autoguard.api.getValue(components, "movie_id", true);
				options["token"] = autoguard.api.getValue(raw.parameters, "token", true);
				options["offset"] = autoguard.api.getValue(raw.parameters, "offset", false);
				options["limit"] = autoguard.api.getValue(raw.parameters, "limit", false);
				let headers = autoguard.api.combineKeyValuePairs(raw.headers);
				let payload = await autoguard.api.deserializePayload(raw.payload);
				let guard = shared.Autoguard.Requests["GET:/movies/<movie_id>/suggestions/"];
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/movies/<movie_id>/suggestions/"](new autoguard.api.ClientRequest(request, auxillary));
						return {
							validateResponse: async () => {
								let guard = shared.Autoguard.Responses["GET:/movies/<movie_id>/suggestions/"];
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.extractKeyValuePairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								return autoguard.api.finalizeResponse({ status, headers, payload }, "application/json; charset=utf-8");
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let components = new Array<[string, string]>();
		components.push(["", decodeURIComponent("playlists")]);
		components.push(["query", raw.components[1]]);
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, components),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options = autoguard.api.combineKeyValuePairs(raw.parameters);
				options["query"] = autoguard.api.getValue(components, "query", true);
				options["token"] = autoguard.api.getValue(raw.parameters, "token", true);
				options["offset"] = autoguard.api.getValue(raw.parameters, "offset", false);
				options["limit"] = autoguard.api.getValue(raw.parameters, "limit", false);
				let headers = autoguard.api.combineKeyValuePairs(raw.headers);
				let payload = await autoguard.api.deserializePayload(raw.payload);
				let guard = shared.Autoguard.Requests["GET:/playlists/<query>"];
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/playlists/<query>"](new autoguard.api.ClientRequest(request, auxillary));
						return {
							validateResponse: async () => {
								let guard = shared.Autoguard.Responses["GET:/playlists/<query>"];
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.extractKeyValuePairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								return autoguard.api.finalizeResponse({ status, headers, payload }, "application/json; charset=utf-8");
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let components = new Array<[string, string]>();
		components.push(["", decodeURIComponent("playlists")]);
		components.push(["playlist_id", raw.components[1]]);
		components.push(["", decodeURIComponent("")]);
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, components),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options = autoguard.api.combineKeyValuePairs(raw.parameters);
				options["playlist_id"] = autoguard.api.getValue(components, "playlist_id", true);
				options["token"] = autoguard.api.getValue(raw.parameters, "token", true);
				let headers = autoguard.api.combineKeyValuePairs(raw.headers);
				let payload = await autoguard.api.deserializePayload(raw.payload);
				let guard = shared.Autoguard.Requests["GET:/playlists/<playlist_id>/"];
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/playlists/<playlist_id>/"](new autoguard.api.ClientRequest(request, auxillary));
						return {
							validateResponse: async () => {
								let guard = shared.Autoguard.Responses["GET:/playlists/<playlist_id>/"];
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.extractKeyValuePairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								return autoguard.api.finalizeResponse({ status, headers, payload }, "application/json; charset=utf-8");
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let components = new Array<[string, string]>();
		components.push(["", decodeURIComponent("seasons")]);
		components.push(["query", raw.components[1]]);
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, components),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options = autoguard.api.combineKeyValuePairs(raw.parameters);
				options["query"] = autoguard.api.getValue(components, "query", true);
				options["token"] = autoguard.api.getValue(raw.parameters, "token", true);
				options["offset"] = autoguard.api.getValue(raw.parameters, "offset", false);
				options["limit"] = autoguard.api.getValue(raw.parameters, "limit", false);
				let headers = autoguard.api.combineKeyValuePairs(raw.headers);
				let payload = await autoguard.api.deserializePayload(raw.payload);
				let guard = shared.Autoguard.Requests["GET:/seasons/<query>"];
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/seasons/<query>"](new autoguard.api.ClientRequest(request, auxillary));
						return {
							validateResponse: async () => {
								let guard = shared.Autoguard.Responses["GET:/seasons/<query>"];
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.extractKeyValuePairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								return autoguard.api.finalizeResponse({ status, headers, payload }, "application/json; charset=utf-8");
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let components = new Array<[string, string]>();
		components.push(["", decodeURIComponent("seasons")]);
		components.push(["season_id", raw.components[1]]);
		components.push(["", decodeURIComponent("")]);
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, components),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options = autoguard.api.combineKeyValuePairs(raw.parameters);
				options["season_id"] = autoguard.api.getValue(components, "season_id", true);
				options["token"] = autoguard.api.getValue(raw.parameters, "token", true);
				let headers = autoguard.api.combineKeyValuePairs(raw.headers);
				let payload = await autoguard.api.deserializePayload(raw.payload);
				let guard = shared.Autoguard.Requests["GET:/seasons/<season_id>/"];
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/seasons/<season_id>/"](new autoguard.api.ClientRequest(request, auxillary));
						return {
							validateResponse: async () => {
								let guard = shared.Autoguard.Responses["GET:/seasons/<season_id>/"];
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.extractKeyValuePairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								return autoguard.api.finalizeResponse({ status, headers, payload }, "application/json; charset=utf-8");
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let components = new Array<[string, string]>();
		components.push(["", decodeURIComponent("shows")]);
		components.push(["query", raw.components[1]]);
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, components),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options = autoguard.api.combineKeyValuePairs(raw.parameters);
				options["query"] = autoguard.api.getValue(components, "query", true);
				options["token"] = autoguard.api.getValue(raw.parameters, "token", true);
				options["offset"] = autoguard.api.getValue(raw.parameters, "offset", false);
				options["limit"] = autoguard.api.getValue(raw.parameters, "limit", false);
				let headers = autoguard.api.combineKeyValuePairs(raw.headers);
				let payload = await autoguard.api.deserializePayload(raw.payload);
				let guard = shared.Autoguard.Requests["GET:/shows/<query>"];
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/shows/<query>"](new autoguard.api.ClientRequest(request, auxillary));
						return {
							validateResponse: async () => {
								let guard = shared.Autoguard.Responses["GET:/shows/<query>"];
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.extractKeyValuePairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								return autoguard.api.finalizeResponse({ status, headers, payload }, "application/json; charset=utf-8");
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let components = new Array<[string, string]>();
		components.push(["", decodeURIComponent("shows")]);
		components.push(["show_id", raw.components[1]]);
		components.push(["", decodeURIComponent("")]);
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, components),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options = autoguard.api.combineKeyValuePairs(raw.parameters);
				options["show_id"] = autoguard.api.getValue(components, "show_id", true);
				options["token"] = autoguard.api.getValue(raw.parameters, "token", true);
				let headers = autoguard.api.combineKeyValuePairs(raw.headers);
				let payload = await autoguard.api.deserializePayload(raw.payload);
				let guard = shared.Autoguard.Requests["GET:/shows/<show_id>/"];
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/shows/<show_id>/"](new autoguard.api.ClientRequest(request, auxillary));
						return {
							validateResponse: async () => {
								let guard = shared.Autoguard.Responses["GET:/shows/<show_id>/"];
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.extractKeyValuePairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								return autoguard.api.finalizeResponse({ status, headers, payload }, "application/json; charset=utf-8");
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let components = new Array<[string, string]>();
		components.push(["", decodeURIComponent("tracks")]);
		components.push(["query", raw.components[1]]);
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, components),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options = autoguard.api.combineKeyValuePairs(raw.parameters);
				options["query"] = autoguard.api.getValue(components, "query", true);
				options["token"] = autoguard.api.getValue(raw.parameters, "token", true);
				options["offset"] = autoguard.api.getValue(raw.parameters, "offset", false);
				options["limit"] = autoguard.api.getValue(raw.parameters, "limit", false);
				let headers = autoguard.api.combineKeyValuePairs(raw.headers);
				let payload = await autoguard.api.deserializePayload(raw.payload);
				let guard = shared.Autoguard.Requests["GET:/tracks/<query>"];
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/tracks/<query>"](new autoguard.api.ClientRequest(request, auxillary));
						return {
							validateResponse: async () => {
								let guard = shared.Autoguard.Responses["GET:/tracks/<query>"];
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.extractKeyValuePairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								return autoguard.api.finalizeResponse({ status, headers, payload }, "application/json; charset=utf-8");
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let components = new Array<[string, string]>();
		components.push(["", decodeURIComponent("tracks")]);
		components.push(["track_id", raw.components[1]]);
		components.push(["", decodeURIComponent("")]);
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, components),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options = autoguard.api.combineKeyValuePairs(raw.parameters);
				options["track_id"] = autoguard.api.getValue(components, "track_id", true);
				options["token"] = autoguard.api.getValue(raw.parameters, "token", true);
				let headers = autoguard.api.combineKeyValuePairs(raw.headers);
				let payload = await autoguard.api.deserializePayload(raw.payload);
				let guard = shared.Autoguard.Requests["GET:/tracks/<track_id>/"];
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/tracks/<track_id>/"](new autoguard.api.ClientRequest(request, auxillary));
						return {
							validateResponse: async () => {
								let guard = shared.Autoguard.Responses["GET:/tracks/<track_id>/"];
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.extractKeyValuePairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								return autoguard.api.finalizeResponse({ status, headers, payload }, "application/json; charset=utf-8");
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let components = new Array<[string, string]>();
		components.push(["", decodeURIComponent("tracks")]);
		components.push(["track_id", raw.components[1]]);
		components.push(["", decodeURIComponent("playlists")]);
		components.push(["", decodeURIComponent("")]);
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, components),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options = autoguard.api.combineKeyValuePairs(raw.parameters);
				options["track_id"] = autoguard.api.getValue(components, "track_id", true);
				options["token"] = autoguard.api.getValue(raw.parameters, "token", true);
				options["offset"] = autoguard.api.getValue(raw.parameters, "offset", false);
				options["limit"] = autoguard.api.getValue(raw.parameters, "limit", false);
				let headers = autoguard.api.combineKeyValuePairs(raw.headers);
				let payload = await autoguard.api.deserializePayload(raw.payload);
				let guard = shared.Autoguard.Requests["GET:/tracks/<track_id>/playlists/"];
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/tracks/<track_id>/playlists/"](new autoguard.api.ClientRequest(request, auxillary));
						return {
							validateResponse: async () => {
								let guard = shared.Autoguard.Responses["GET:/tracks/<track_id>/playlists/"];
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.extractKeyValuePairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								return autoguard.api.finalizeResponse({ status, headers, payload }, "application/json; charset=utf-8");
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let components = new Array<[string, string]>();
		components.push(["", decodeURIComponent("users")]);
		components.push(["query", raw.components[1]]);
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, components),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options = autoguard.api.combineKeyValuePairs(raw.parameters);
				options["query"] = autoguard.api.getValue(components, "query", true);
				options["token"] = autoguard.api.getValue(raw.parameters, "token", true);
				options["offset"] = autoguard.api.getValue(raw.parameters, "offset", false);
				options["limit"] = autoguard.api.getValue(raw.parameters, "limit", false);
				let headers = autoguard.api.combineKeyValuePairs(raw.headers);
				let payload = await autoguard.api.deserializePayload(raw.payload);
				let guard = shared.Autoguard.Requests["GET:/users/<query>"];
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/users/<query>"](new autoguard.api.ClientRequest(request, auxillary));
						return {
							validateResponse: async () => {
								let guard = shared.Autoguard.Responses["GET:/users/<query>"];
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.extractKeyValuePairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								return autoguard.api.finalizeResponse({ status, headers, payload }, "application/json; charset=utf-8");
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let components = new Array<[string, string]>();
		components.push(["", decodeURIComponent("users")]);
		components.push(["user_id", raw.components[1]]);
		components.push(["", decodeURIComponent("")]);
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, components),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options = autoguard.api.combineKeyValuePairs(raw.parameters);
				options["user_id"] = autoguard.api.getValue(components, "user_id", true);
				options["token"] = autoguard.api.getValue(raw.parameters, "token", true);
				let headers = autoguard.api.combineKeyValuePairs(raw.headers);
				let payload = await autoguard.api.deserializePayload(raw.payload);
				let guard = shared.Autoguard.Requests["GET:/users/<user_id>/"];
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/users/<user_id>/"](new autoguard.api.ClientRequest(request, auxillary));
						return {
							validateResponse: async () => {
								let guard = shared.Autoguard.Responses["GET:/users/<user_id>/"];
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.extractKeyValuePairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								return autoguard.api.finalizeResponse({ status, headers, payload }, "application/json; charset=utf-8");
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let components = new Array<[string, string]>();
		components.push(["", decodeURIComponent("users")]);
		components.push(["user_id", raw.components[1]]);
		components.push(["", decodeURIComponent("albums")]);
		components.push(["", decodeURIComponent("")]);
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, components),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options = autoguard.api.combineKeyValuePairs(raw.parameters);
				options["user_id"] = autoguard.api.getValue(components, "user_id", true);
				options["token"] = autoguard.api.getValue(raw.parameters, "token", true);
				options["offset"] = autoguard.api.getValue(raw.parameters, "offset", false);
				options["limit"] = autoguard.api.getValue(raw.parameters, "limit", false);
				let headers = autoguard.api.combineKeyValuePairs(raw.headers);
				let payload = await autoguard.api.deserializePayload(raw.payload);
				let guard = shared.Autoguard.Requests["GET:/users/<user_id>/albums/"];
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/users/<user_id>/albums/"](new autoguard.api.ClientRequest(request, auxillary));
						return {
							validateResponse: async () => {
								let guard = shared.Autoguard.Responses["GET:/users/<user_id>/albums/"];
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.extractKeyValuePairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								return autoguard.api.finalizeResponse({ status, headers, payload }, "application/json; charset=utf-8");
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let components = new Array<[string, string]>();
		components.push(["", decodeURIComponent("users")]);
		components.push(["user_id", raw.components[1]]);
		components.push(["", decodeURIComponent("playlists")]);
		components.push(["", decodeURIComponent("")]);
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, components),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options = autoguard.api.combineKeyValuePairs(raw.parameters);
				options["user_id"] = autoguard.api.getValue(components, "user_id", true);
				options["token"] = autoguard.api.getValue(raw.parameters, "token", true);
				options["offset"] = autoguard.api.getValue(raw.parameters, "offset", false);
				options["limit"] = autoguard.api.getValue(raw.parameters, "limit", false);
				let headers = autoguard.api.combineKeyValuePairs(raw.headers);
				let payload = await autoguard.api.deserializePayload(raw.payload);
				let guard = shared.Autoguard.Requests["GET:/users/<user_id>/playlists/"];
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/users/<user_id>/playlists/"](new autoguard.api.ClientRequest(request, auxillary));
						return {
							validateResponse: async () => {
								let guard = shared.Autoguard.Responses["GET:/users/<user_id>/playlists/"];
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.extractKeyValuePairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								return autoguard.api.finalizeResponse({ status, headers, payload }, "application/json; charset=utf-8");
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let components = new Array<[string, string]>();
		components.push(["", decodeURIComponent("users")]);
		components.push(["user_id", raw.components[1]]);
		components.push(["", decodeURIComponent("shows")]);
		components.push(["", decodeURIComponent("")]);
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, components),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options = autoguard.api.combineKeyValuePairs(raw.parameters);
				options["user_id"] = autoguard.api.getValue(components, "user_id", true);
				options["token"] = autoguard.api.getValue(raw.parameters, "token", true);
				options["offset"] = autoguard.api.getValue(raw.parameters, "offset", false);
				options["limit"] = autoguard.api.getValue(raw.parameters, "limit", false);
				let headers = autoguard.api.combineKeyValuePairs(raw.headers);
				let payload = await autoguard.api.deserializePayload(raw.payload);
				let guard = shared.Autoguard.Requests["GET:/users/<user_id>/shows/"];
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/users/<user_id>/shows/"](new autoguard.api.ClientRequest(request, auxillary));
						return {
							validateResponse: async () => {
								let guard = shared.Autoguard.Responses["GET:/users/<user_id>/shows/"];
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.extractKeyValuePairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								return autoguard.api.finalizeResponse({ status, headers, payload }, "application/json; charset=utf-8");
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let components = new Array<[string, string]>();
		components.push(["", decodeURIComponent("years")]);
		components.push(["query", raw.components[1]]);
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, components),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options = autoguard.api.combineKeyValuePairs(raw.parameters);
				options["query"] = autoguard.api.getValue(components, "query", true);
				options["token"] = autoguard.api.getValue(raw.parameters, "token", true);
				options["offset"] = autoguard.api.getValue(raw.parameters, "offset", false);
				options["limit"] = autoguard.api.getValue(raw.parameters, "limit", false);
				let headers = autoguard.api.combineKeyValuePairs(raw.headers);
				let payload = await autoguard.api.deserializePayload(raw.payload);
				let guard = shared.Autoguard.Requests["GET:/years/<query>"];
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/years/<query>"](new autoguard.api.ClientRequest(request, auxillary));
						return {
							validateResponse: async () => {
								let guard = shared.Autoguard.Responses["GET:/years/<query>"];
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.extractKeyValuePairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								return autoguard.api.finalizeResponse({ status, headers, payload }, "application/json; charset=utf-8");
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let components = new Array<[string, string]>();
		components.push(["", decodeURIComponent("years")]);
		components.push(["year_id", raw.components[1]]);
		components.push(["", decodeURIComponent("")]);
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, components),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options = autoguard.api.combineKeyValuePairs(raw.parameters);
				options["year_id"] = autoguard.api.getValue(components, "year_id", true);
				options["token"] = autoguard.api.getValue(raw.parameters, "token", true);
				let headers = autoguard.api.combineKeyValuePairs(raw.headers);
				let payload = await autoguard.api.deserializePayload(raw.payload);
				let guard = shared.Autoguard.Requests["GET:/years/<year_id>/"];
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/years/<year_id>/"](new autoguard.api.ClientRequest(request, auxillary));
						return {
							validateResponse: async () => {
								let guard = shared.Autoguard.Responses["GET:/years/<year_id>/"];
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.extractKeyValuePairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								return autoguard.api.finalizeResponse({ status, headers, payload }, "application/json; charset=utf-8");
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let components = new Array<[string, string]>();
		components.push(["", decodeURIComponent("years")]);
		components.push(["year_id", raw.components[1]]);
		components.push(["", decodeURIComponent("albums")]);
		components.push(["", decodeURIComponent("")]);
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, components),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options = autoguard.api.combineKeyValuePairs(raw.parameters);
				options["year_id"] = autoguard.api.getValue(components, "year_id", true);
				options["token"] = autoguard.api.getValue(raw.parameters, "token", true);
				options["offset"] = autoguard.api.getValue(raw.parameters, "offset", false);
				options["limit"] = autoguard.api.getValue(raw.parameters, "limit", false);
				let headers = autoguard.api.combineKeyValuePairs(raw.headers);
				let payload = await autoguard.api.deserializePayload(raw.payload);
				let guard = shared.Autoguard.Requests["GET:/years/<year_id>/albums/"];
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/years/<year_id>/albums/"](new autoguard.api.ClientRequest(request, auxillary));
						return {
							validateResponse: async () => {
								let guard = shared.Autoguard.Responses["GET:/years/<year_id>/albums/"];
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.extractKeyValuePairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								return autoguard.api.finalizeResponse({ status, headers, payload }, "application/json; charset=utf-8");
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let components = new Array<[string, string]>();
		components.push(["", decodeURIComponent("years")]);
		components.push(["year_id", raw.components[1]]);
		components.push(["", decodeURIComponent("movies")]);
		components.push(["", decodeURIComponent("")]);
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, components),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options = autoguard.api.combineKeyValuePairs(raw.parameters);
				options["year_id"] = autoguard.api.getValue(components, "year_id", true);
				options["token"] = autoguard.api.getValue(raw.parameters, "token", true);
				options["offset"] = autoguard.api.getValue(raw.parameters, "offset", false);
				options["limit"] = autoguard.api.getValue(raw.parameters, "limit", false);
				let headers = autoguard.api.combineKeyValuePairs(raw.headers);
				let payload = await autoguard.api.deserializePayload(raw.payload);
				let guard = shared.Autoguard.Requests["GET:/years/<year_id>/movies/"];
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/years/<year_id>/movies/"](new autoguard.api.ClientRequest(request, auxillary));
						return {
							validateResponse: async () => {
								let guard = shared.Autoguard.Responses["GET:/years/<year_id>/movies/"];
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.extractKeyValuePairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								return autoguard.api.finalizeResponse({ status, headers, payload }, "application/json; charset=utf-8");
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let components = new Array<[string, string]>();
		components.push(["", decodeURIComponent("files")]);
		components.push(["file_id", raw.components[1]]);
		components.push(["", decodeURIComponent("")]);
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, components),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options = autoguard.api.combineKeyValuePairs(raw.parameters);
				options["file_id"] = autoguard.api.getValue(components, "file_id", true);
				options["token"] = autoguard.api.getValue(raw.parameters, "token", true);
				let headers = autoguard.api.combineKeyValuePairs(raw.headers);
				let payload = await autoguard.api.deserializePayload(raw.payload);
				let guard = shared.Autoguard.Requests["GET:/files/<file_id>/"];
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/files/<file_id>/"](new autoguard.api.ClientRequest(request, auxillary));
						return {
							validateResponse: async () => {
								let guard = shared.Autoguard.Responses["GET:/files/<file_id>/"];
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.extractKeyValuePairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload;
								return autoguard.api.finalizeResponse({ status, headers, payload }, "application/octet-stream");
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let components = new Array<[string, string]>();
		components.push(["", decodeURIComponent("statistics")]);
		components.push(["", decodeURIComponent("")]);
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, components),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options = autoguard.api.combineKeyValuePairs(raw.parameters);
				options["token"] = autoguard.api.getValue(raw.parameters, "token", true);
				let headers = autoguard.api.combineKeyValuePairs(raw.headers);
				let payload = await autoguard.api.deserializePayload(raw.payload);
				let guard = shared.Autoguard.Requests["GET:/statistics/"];
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/statistics/"](new autoguard.api.ClientRequest(request, auxillary));
						return {
							validateResponse: async () => {
								let guard = shared.Autoguard.Responses["GET:/statistics/"];
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.extractKeyValuePairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								return autoguard.api.finalizeResponse({ status, headers, payload }, "application/json; charset=utf-8");
							}
						};
					}
				};
			}
		};
	});
	return (request, response) => autoguard.api.route(endpoints, request, response, options?.urlPrefix);
};
