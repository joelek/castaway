// This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.

import * as autoguard from "@joelek/ts-autoguard/dist/lib-shared";

export const VideoFrame = autoguard.guards.Object.of({
	"pkt_pts_time": autoguard.guards.String
});

export type VideoFrame = ReturnType<typeof VideoFrame["as"]>;

export const FramesResult = autoguard.guards.Object.of({
	"frames": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => VideoFrame))
});

export type FramesResult = ReturnType<typeof FramesResult["as"]>;

export const StreamCommon = autoguard.guards.Object.of({
	"codec_name": autoguard.guards.String
});

export type StreamCommon = ReturnType<typeof StreamCommon["as"]>;

export const AudioStream = autoguard.guards.Intersection.of(
	autoguard.guards.Reference.of(() => StreamCommon),
	autoguard.guards.Object.of({
		"codec_type": autoguard.guards.StringLiteral.of("audio"),
		"start_time": autoguard.guards.String,
		"duration": autoguard.guards.String
	})
);

export type AudioStream = ReturnType<typeof AudioStream["as"]>;

export const ImageStream = autoguard.guards.Intersection.of(
	autoguard.guards.Reference.of(() => StreamCommon),
	autoguard.guards.Object.of({
		"codec_type": autoguard.guards.StringLiteral.of("video"),
		"codec_time_base": autoguard.guards.StringLiteral.of("0/1"),
		"width": autoguard.guards.Number,
		"height": autoguard.guards.Number
	})
);

export type ImageStream = ReturnType<typeof ImageStream["as"]>;

export const SubtitleStream = autoguard.guards.Intersection.of(
	autoguard.guards.Reference.of(() => StreamCommon),
	autoguard.guards.Object.of({
		"codec_type": autoguard.guards.StringLiteral.of("subtitle")
	})
);

export type SubtitleStream = ReturnType<typeof SubtitleStream["as"]>;

export const VideoStream = autoguard.guards.Intersection.of(
	autoguard.guards.Reference.of(() => StreamCommon),
	autoguard.guards.Object.of({
		"codec_type": autoguard.guards.StringLiteral.of("video"),
		"start_time": autoguard.guards.String,
		"duration": autoguard.guards.String,
		"width": autoguard.guards.Number,
		"height": autoguard.guards.Number
	})
);

export type VideoStream = ReturnType<typeof VideoStream["as"]>;

export const Stream = autoguard.guards.Union.of(
	autoguard.guards.Reference.of(() => AudioStream),
	autoguard.guards.Reference.of(() => ImageStream),
	autoguard.guards.Reference.of(() => SubtitleStream),
	autoguard.guards.Reference.of(() => VideoStream)
);

export type Stream = ReturnType<typeof Stream["as"]>;

export const StreamsResult = autoguard.guards.Object.of({
	"streams": autoguard.guards.Array.of(autoguard.guards.Reference.of(() => Stream))
});

export type StreamsResult = ReturnType<typeof StreamsResult["as"]>;

export const Format = autoguard.guards.Object.of({
	"format_name": autoguard.guards.String,
	"tags": autoguard.guards.Union.of(
		autoguard.guards.Object.of({
			"title": autoguard.guards.Union.of(
				autoguard.guards.String,
				autoguard.guards.Undefined
			),
			"date": autoguard.guards.Union.of(
				autoguard.guards.String,
				autoguard.guards.Undefined
			),
			"comment": autoguard.guards.Union.of(
				autoguard.guards.String,
				autoguard.guards.Undefined
			),
			"show": autoguard.guards.Union.of(
				autoguard.guards.String,
				autoguard.guards.Undefined
			),
			"episode_id": autoguard.guards.Union.of(
				autoguard.guards.String,
				autoguard.guards.Undefined
			),
			"episode_sort": autoguard.guards.Union.of(
				autoguard.guards.String,
				autoguard.guards.Undefined
			),
			"season_number": autoguard.guards.Union.of(
				autoguard.guards.String,
				autoguard.guards.Undefined
			),
			"track": autoguard.guards.Union.of(
				autoguard.guards.String,
				autoguard.guards.Undefined
			),
			"artist": autoguard.guards.Union.of(
				autoguard.guards.String,
				autoguard.guards.Undefined
			),
			"album_artist": autoguard.guards.Union.of(
				autoguard.guards.String,
				autoguard.guards.Undefined
			),
			"album": autoguard.guards.Union.of(
				autoguard.guards.String,
				autoguard.guards.Undefined
			),
			"disc": autoguard.guards.Union.of(
				autoguard.guards.String,
				autoguard.guards.Undefined
			)
		}),
		autoguard.guards.Undefined
	)
});

export type Format = ReturnType<typeof Format["as"]>;

export const FormatResult = autoguard.guards.Object.of({
	"format": autoguard.guards.Reference.of(() => Format)
});

export type FormatResult = ReturnType<typeof FormatResult["as"]>;

export namespace Autoguard {
	export const Guards = {
		"VideoFrame": autoguard.guards.Reference.of(() => VideoFrame),
		"FramesResult": autoguard.guards.Reference.of(() => FramesResult),
		"StreamCommon": autoguard.guards.Reference.of(() => StreamCommon),
		"AudioStream": autoguard.guards.Reference.of(() => AudioStream),
		"ImageStream": autoguard.guards.Reference.of(() => ImageStream),
		"SubtitleStream": autoguard.guards.Reference.of(() => SubtitleStream),
		"VideoStream": autoguard.guards.Reference.of(() => VideoStream),
		"Stream": autoguard.guards.Reference.of(() => Stream),
		"StreamsResult": autoguard.guards.Reference.of(() => StreamsResult),
		"Format": autoguard.guards.Reference.of(() => Format),
		"FormatResult": autoguard.guards.Reference.of(() => FormatResult)
	};

	export type Guards = { [A in keyof typeof Guards]: ReturnType<typeof Guards[A]["as"]>; };

	export const Requests = {};

	export type Requests = { [A in keyof typeof Requests]: ReturnType<typeof Requests[A]["as"]>; };

	export const Responses = {};

	export type Responses = { [A in keyof typeof Responses]: ReturnType<typeof Responses[A]["as"]>; };
};
